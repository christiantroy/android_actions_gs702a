From 717ed5adea176645baef3bcb0fa9701f571b9cb7 Mon Sep 17 00:00:00 2001
From: Alan Marchesan <justcavalli@gmail.com>
Date: Thu, 3 Oct 2013 06:42:21 +0200
Subject: [PATCH] gs702a: initial merge of Actions code by ChristianTroy

---
 include/alsp/inc/ALdec_plugin.h                    |  243 +
 include/alsp/inc/ALenc_plugin.h                    |  436 ++
 include/alsp/inc/ActDataSource.h                   |   44 +
 include/alsp/inc/actal_libc_dev.h                  |   85 +
 include/alsp/inc/actal_posix_dev.h                 |   54 +
 include/alsp/inc/al_libc_dll.h                     |    7 +
 include/alsp/inc/alsp_includes.h                   |   55 +
 include/alsp/inc/alsp_incs.h                       |   12 +
 include/alsp/inc/audio_decoder_lib_dev.h           |   92 +
 include/alsp/inc/audio_encoder_lib_dev.h           |   71 +
 include/alsp/inc/common/al_libc.h                  |  107 +
 include/alsp/inc/common/audioin_pcm.h              |   40 +
 include/alsp/inc/common/audiout_pcm.h              |   42 +
 include/alsp/inc/common/buf_header.h               |   39 +
 include/alsp/inc/common/enc_audio.h                |   39 +
 include/alsp/inc/common/extdef.h                   |   71 +
 include/alsp/inc/common/music_info.h               |   43 +
 include/alsp/inc/common/storageio.h                |   36 +
 include/alsp/inc/common/stream_input.h             |   16 +
 include/alsp/inc/format_dev.h                      |   42 +
 include/alsp/inc/id3parse.h                        |  123 +
 include/alsp/inc/music_parser_lib_dev.h            |  109 +
 include/alsp/inc/muxer_wav.h                       |   49 +
 include/alsp/inc/parser_aac.h                      |   34 +
 include/alsp/inc/parser_ac3.h                      |   32 +
 include/alsp/inc/parser_mp3.h                      |    8 +
 include/alsp/inc/parser_pcm.h                      |   43 +
 include/alsp/inc/parser_ra.h                       |   43 +
 include/alsp/inc/uconv_dev.h                       |   22 +
 include/alsp/inc/vde_core.h                        |  175 +
 include/alsp/inc/vde_drv.h                         |   56 +
 include/alsp/inc/venc_common.h                     |   31 +
 include/media/MediaPlayerInterface.h               |    2 +-
 include/media/MediaProfiles.h                      |    2 +
 include/media/mediaplayer.h                        |    3 +
 include/media/mediarecorder.h                      |   11 +
 include/media/stagefright/ACodec.h                 |    7 +
 include/media/stagefright/ActAudioWriter.h         |   71 +
 include/media/stagefright/AudioPlayer.h            |    1 +
 include/media/stagefright/DataSource.h             |    3 +
 include/media/stagefright/MediaCodecList.h         |    2 +-
 include/media/stagefright/MediaDefs.h              |   33 +
 include/media/stagefright/MediaErrors.h            |    3 +
 include/media/stagefright/MediaExtractor.h         |   15 +-
 include/media/stagefright/MetaData.h               |    9 +
 include/media/stagefright/OMXCodec.h               |    5 +
 .../stagefrightshells/src/VideoEditor3gpReader.cpp |    9 +
 media/libmedia/IMediaMetadataRetriever.cpp         |   17 +-
 media/libmedia/MediaProfiles.cpp                   |   18 +
 media/libmedia/MediaScannerClient.cpp              |  202 +-
 media/libmedia/autodetect.cpp                      |   81 +-
 media/libmedia/autodetect.h                        |    3 +-
 media/libmedia/mediaplayer.cpp                     |    2 +-
 media/libmediaplayerservice/Android.mk             |    4 +-
 media/libmediaplayerservice/MediaPlayerFactory.cpp |   11 +-
 media/libmediaplayerservice/MediaPlayerService.cpp |   59 +
 media/libmediaplayerservice/MediaPlayerService.h   |    1 +
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  103 +-
 media/libmediaplayerservice/StagefrightRecorder.h  |    1 +
 .../nuplayer/HTTPLiveSource.cpp                    |   36 +-
 .../nuplayer/HTTPLiveSource.h                      |    1 +
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  201 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |   11 +
 .../nuplayer/NuPlayerDecoder.cpp                   |    3 +-
 .../nuplayer/NuPlayerDriver.cpp                    |   20 +-
 .../nuplayer/NuPlayerDriver.h                      |    2 +
 .../nuplayer/NuPlayerRenderer.cpp                  |  127 +-
 .../nuplayer/NuPlayerRenderer.h                    |   15 +
 .../libmediaplayerservice/nuplayer/RTSPSource.cpp  |    4 +
 media/libstagefright/AACWriter.cpp                 |    6 +
 media/libstagefright/ACodec.cpp                    |  403 +-
 media/libstagefright/ActAudioDecoder.cpp           |  553 +++
 media/libstagefright/ActAudioDownMix.cpp           |  466 ++
 media/libstagefright/ActAudioEncoder.cpp           |  430 ++
 media/libstagefright/ActAudioExtractor.cpp         |  515 +++
 media/libstagefright/ActAudioWriter.cpp            |  307 ++
 media/libstagefright/ActDataSource.cpp             |  229 +
 media/libstagefright/ActVideoExtractor.cpp         | 2216 +++++++++
 media/libstagefright/Android.mk                    |   23 +-
 media/libstagefright/AudioPlayer.cpp               |   13 +-
 media/libstagefright/AwesomePlayer.cpp             |  205 +-
 media/libstagefright/CameraSource.cpp              |   50 +-
 media/libstagefright/CameraSourceTimeLapse.cpp     |    7 +-
 media/libstagefright/FLACExtractor.cpp             |   61 +-
 media/libstagefright/MPEG4Writer.cpp               |  493 ++-
 media/libstagefright/MediaCodecList.cpp            |   10 +-
 media/libstagefright/MediaDefs.cpp                 |   36 +-
 media/libstagefright/MediaExtractor.cpp            |  206 +-
 media/libstagefright/MetaData.cpp                  |    1 +
 media/libstagefright/NuCachedSource2.cpp           |    9 +
 media/libstagefright/NuMediaExtractor.cpp          |    3 +-
 media/libstagefright/OMXCodec.cpp                  |  635 ++-
 media/libstagefright/StagefrightMediaScanner.cpp   |   20 +
 .../StagefrightMetadataRetriever.cpp               |   73 +-
 media/libstagefright/SurfaceMediaSource.cpp        |    7 +-
 media/libstagefright/Utils.cpp                     |   55 +-
 media/libstagefright/WAVExtractor.cpp              |    6 +-
 media/libstagefright/avc_utils.cpp                 |   72 +
 .../chromium_http/ChromiumHTTPDataSource.cpp       |   31 +-
 media/libstagefright/chromium_http/support.cpp     |   87 +-
 media/libstagefright/chromium_http/support.h       |    7 +-
 media/libstagefright/codecs/aacdec/SoftAAC2.cpp    |    7 +-
 media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp  |    2 +-
 .../codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp       |    3 +-
 .../codecs/m4v_h263/enc/src/mp4enc_api.cpp         |    2 +-
 .../codecs/vorbis/dec/SoftVorbis.cpp               |    2 +-
 media/libstagefright/httplive/LiveSession.cpp      |  327 +-
 media/libstagefright/httplive/M3UParser.cpp        |    5 +-
 media/libstagefright/include/ActAudioDecoder.h     |  181 +
 media/libstagefright/include/ActAudioDownMix.h     |  138 +
 media/libstagefright/include/ActAudioEncoder.h     |   71 +
 media/libstagefright/include/ActAudioExtractor.h   |   68 +
 media/libstagefright/include/ActVideoExtractor.h   |  224 +
 media/libstagefright/include/AwesomePlayer.h       |    5 +
 .../include/ChromiumHTTPDataSource.h               |    2 +
 media/libstagefright/include/LiveSession.h         |   18 +-
 media/libstagefright/include/avc_utils.h           |    3 +
 media/libstagefright/mp4/FragmentedMP4Parser.cpp   |    4 +
 media/libstagefright/mpeg2ts/ATSParser.cpp         |   16 +-
 media/libstagefright/mpeg2ts/Android.mk            |    2 +
 media/libstagefright/mpeg2ts/ESQueue.cpp           |   21 +-
 media/libstagefright/mpeg2ts/ESQueue.h             |    1 +
 media/libstagefright/rtsp/ARTPConnection.cpp       |    3 +-
 media/libstagefright/rtsp/MyHandler.h              |   20 +-
 media/libstagefright/vendor/Android.mk             |    4 +
 media/libstagefright/vendor/ID3parser/Android.mk   |   21 +
 .../libstagefright/vendor/ID3parser/Android.mk.bak |   19 +
 .../vendor/ID3parser/ape_id3parse.cpp              |  292 ++
 .../vendor/ID3parser/flac_id3parse.cpp             |  231 +
 .../vendor/ID3parser/flac_id3parse.h               |   26 +
 .../libstagefright/vendor/ID3parser/id3_helper.cpp |  785 ++++
 .../libstagefright/vendor/ID3parser/id3fileIO.cpp  |   35 +
 .../vendor/ID3parser/mp3_id3parse.cpp              | 1090 +++++
 .../vendor/ID3parser/ogg_id3parse.cpp              |  282 ++
 .../vendor/ID3parser/wma_id3parse.cpp              |  543 +++
 media/libstagefright/vendor/al_libc/Android.mk     |   39 +
 media/libstagefright/vendor/al_libc/SinoDetect.cpp | 4682 ++++++++++++++++++++
 media/libstagefright/vendor/al_libc/SinoDetect.h   |   72 +
 media/libstagefright/vendor/al_libc/al_detect.cpp  |   40 +
 media/libstagefright/vendor/al_libc/al_libc.c      |  598 +++
 media/libstagefright/vendor/al_libc/al_uconv.c     |   75 +
 media/libstagefright/vendor/al_libc/ion.c          |  153 +
 media/libstagefright/vendor/al_libc/ion.h          |   33 +
 media/libstagefright/vendor/mmminfo/Android.mk     |   21 +
 media/libstagefright/vendor/mmminfo/Makefile       |   50 +
 media/libstagefright/vendor/mmminfo/aac_check.c    |  505 +++
 media/libstagefright/vendor/mmminfo/dts_check.c    |   99 +
 media/libstagefright/vendor/mmminfo/format_check.c |  464 ++
 media/libstagefright/vendor/mmminfo/format_check.h |   29 +
 media/libstagefright/vendor/mmminfo/getinfo.c      |  230 +
 media/libstagefright/vendor/mmminfo/getinfo.h      |   10 +
 media/libstagefright/vendor/mmminfo/mp3_check.c    |  302 ++
 media/libstagefright/vendor/mmminfo/rm_check.c     |  240 +
 media/libstagefright/vendor/mmminfo/ts_check.c     |   68 +
 media/libstagefright/vendor/mmminfo/wma_check.c    |  154 +
 media/libstagefright/vendor/plugin_link/Android.mk |   66 +
 .../vendor/plugin_link/liblink_decoder.a           |  Bin 0 -> 2944 bytes
 .../vendor/plugin_link/liblink_encoder.a           |  Bin 0 -> 2944 bytes
 .../vendor/plugin_link/liblink_parser.a            |  Bin 0 -> 2952 bytes
 .../vendor/plugin_link/liblink_video_decoder.a     |  Bin 0 -> 2964 bytes
 .../vendor/plugin_link/liblink_video_parser.a      |  Bin 0 -> 2952 bytes
 .../vendor/plugin_link/link_decoder.c              |   28 +
 .../vendor/plugin_link/link_encoder.c              |   28 +
 .../vendor/plugin_link/link_parser.c               |   28 +
 .../vendor/plugin_link/link_video_decoder.c        |   22 +
 .../vendor/plugin_link/link_video_parser.c         |    6 +
 .../wifi-display/ANetworkSession.cpp               |    2 +-
 .../wifi-display/source/Converter.cpp              |   31 +-
 .../wifi-display/source/PlaybackSession.cpp        |    2 +-
 .../libstagefright/wifi-display/source/Sender.cpp  |   18 +-
 .../wifi-display/source/WifiDisplaySource.cpp      |    4 +-
 services/audioflinger/AudioPolicyService.cpp       |   14 +-
 services/audioflinger/AudioResampler.cpp           |    2 +-
 services/audioflinger/AudioResampler.h             |    2 +-
 174 files changed, 22787 insertions(+), 415 deletions(-)
 create mode 100755 include/alsp/inc/ALdec_plugin.h
 create mode 100755 include/alsp/inc/ALenc_plugin.h
 create mode 100755 include/alsp/inc/ActDataSource.h
 create mode 100755 include/alsp/inc/actal_libc_dev.h
 create mode 100755 include/alsp/inc/actal_posix_dev.h
 create mode 100755 include/alsp/inc/al_libc_dll.h
 create mode 100755 include/alsp/inc/alsp_includes.h
 create mode 100755 include/alsp/inc/alsp_incs.h
 create mode 100755 include/alsp/inc/audio_decoder_lib_dev.h
 create mode 100755 include/alsp/inc/audio_encoder_lib_dev.h
 create mode 100755 include/alsp/inc/common/al_libc.h
 create mode 100755 include/alsp/inc/common/audioin_pcm.h
 create mode 100755 include/alsp/inc/common/audiout_pcm.h
 create mode 100755 include/alsp/inc/common/buf_header.h
 create mode 100755 include/alsp/inc/common/enc_audio.h
 create mode 100755 include/alsp/inc/common/extdef.h
 create mode 100755 include/alsp/inc/common/music_info.h
 create mode 100755 include/alsp/inc/common/storageio.h
 create mode 100755 include/alsp/inc/common/stream_input.h
 create mode 100755 include/alsp/inc/format_dev.h
 create mode 100755 include/alsp/inc/id3parse.h
 create mode 100755 include/alsp/inc/music_parser_lib_dev.h
 create mode 100755 include/alsp/inc/muxer_wav.h
 create mode 100755 include/alsp/inc/parser_aac.h
 create mode 100755 include/alsp/inc/parser_ac3.h
 create mode 100755 include/alsp/inc/parser_mp3.h
 create mode 100755 include/alsp/inc/parser_pcm.h
 create mode 100755 include/alsp/inc/parser_ra.h
 create mode 100755 include/alsp/inc/uconv_dev.h
 create mode 100755 include/alsp/inc/vde_core.h
 create mode 100755 include/alsp/inc/vde_drv.h
 create mode 100755 include/alsp/inc/venc_common.h
 create mode 100755 include/media/stagefright/ActAudioWriter.h
 create mode 100755 media/libstagefright/ActAudioDecoder.cpp
 create mode 100755 media/libstagefright/ActAudioDownMix.cpp
 create mode 100755 media/libstagefright/ActAudioEncoder.cpp
 create mode 100755 media/libstagefright/ActAudioExtractor.cpp
 create mode 100755 media/libstagefright/ActAudioWriter.cpp
 create mode 100755 media/libstagefright/ActDataSource.cpp
 create mode 100755 media/libstagefright/ActVideoExtractor.cpp
 create mode 100755 media/libstagefright/include/ActAudioDecoder.h
 create mode 100755 media/libstagefright/include/ActAudioDownMix.h
 create mode 100755 media/libstagefright/include/ActAudioEncoder.h
 create mode 100755 media/libstagefright/include/ActAudioExtractor.h
 create mode 100755 media/libstagefright/include/ActVideoExtractor.h
 create mode 100755 media/libstagefright/vendor/Android.mk
 create mode 100755 media/libstagefright/vendor/ID3parser/Android.mk
 create mode 100755 media/libstagefright/vendor/ID3parser/Android.mk.bak
 create mode 100755 media/libstagefright/vendor/ID3parser/ape_id3parse.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/flac_id3parse.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/flac_id3parse.h
 create mode 100755 media/libstagefright/vendor/ID3parser/id3_helper.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/id3fileIO.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/mp3_id3parse.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/ogg_id3parse.cpp
 create mode 100755 media/libstagefright/vendor/ID3parser/wma_id3parse.cpp
 create mode 100755 media/libstagefright/vendor/al_libc/Android.mk
 create mode 100755 media/libstagefright/vendor/al_libc/SinoDetect.cpp
 create mode 100755 media/libstagefright/vendor/al_libc/SinoDetect.h
 create mode 100755 media/libstagefright/vendor/al_libc/al_detect.cpp
 create mode 100755 media/libstagefright/vendor/al_libc/al_libc.c
 create mode 100755 media/libstagefright/vendor/al_libc/al_uconv.c
 create mode 100755 media/libstagefright/vendor/al_libc/ion.c
 create mode 100755 media/libstagefright/vendor/al_libc/ion.h
 create mode 100755 media/libstagefright/vendor/mmminfo/Android.mk
 create mode 100755 media/libstagefright/vendor/mmminfo/Makefile
 create mode 100755 media/libstagefright/vendor/mmminfo/aac_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/dts_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/format_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/format_check.h
 create mode 100755 media/libstagefright/vendor/mmminfo/getinfo.c
 create mode 100755 media/libstagefright/vendor/mmminfo/getinfo.h
 create mode 100755 media/libstagefright/vendor/mmminfo/mp3_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/rm_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/ts_check.c
 create mode 100755 media/libstagefright/vendor/mmminfo/wma_check.c
 create mode 100755 media/libstagefright/vendor/plugin_link/Android.mk
 create mode 100755 media/libstagefright/vendor/plugin_link/liblink_decoder.a
 create mode 100755 media/libstagefright/vendor/plugin_link/liblink_encoder.a
 create mode 100755 media/libstagefright/vendor/plugin_link/liblink_parser.a
 create mode 100755 media/libstagefright/vendor/plugin_link/liblink_video_decoder.a
 create mode 100755 media/libstagefright/vendor/plugin_link/liblink_video_parser.a
 create mode 100755 media/libstagefright/vendor/plugin_link/link_decoder.c
 create mode 100755 media/libstagefright/vendor/plugin_link/link_encoder.c
 create mode 100755 media/libstagefright/vendor/plugin_link/link_parser.c
 create mode 100755 media/libstagefright/vendor/plugin_link/link_video_decoder.c
 create mode 100755 media/libstagefright/vendor/plugin_link/link_video_parser.c

diff --git a/include/alsp/inc/ALdec_plugin.h b/include/alsp/inc/ALdec_plugin.h
new file mode 100755
index 0000000..a876bdb
--- /dev/null
+++ b/include/alsp/inc/ALdec_plugin.h
@@ -0,0 +1,243 @@
+#ifndef ALDEC_PLUGIN_H
+#define ALDEC_PLUGIN_H
+
+#ifdef WIN32
+#include "al_libc_dll.h"
+#endif
+#include "./common/stream_input.h"
+#include "./common/extdef.h"
+#include "./common/buf_header.h"
+
+#define _ISPRAM_CODE_
+#define _ISPRAM_SECTION_NAME_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*图像格式类型*/
+#define YUV420_SEMI_PLANAR         0x00
+#define YUV420_PLANAR              0x01
+
+/*最大audio和video包长度*/
+#define AUDIO_MAX_PKT_SIZE        204800
+#define VIDEO_MAX_PKT_SIZE        2048000
+
+/* 定义插件返回错误号*/
+typedef enum
+{
+	PLUGIN_RETURN_ERR = -1,
+	PLUGIN_RETURN_NORMAL = 0,
+	PLUGIN_RETURN_FILE_END,
+	PLUGIN_RETURN_NOT_SUPPORT,
+	PLUGIN_RETURN_PKT_NOTEND,
+	PLUGIN_RETURN_SEEK_ERR
+}plugin_err_no_t;
+
+
+/*parser和decoder之间的传递包的数据结构*/
+typedef struct
+{
+	unsigned char *data;
+	unsigned int data_len;
+}av_buf_t;
+
+/*中间件发给插件ex_ops接口的命令字（后续会有拓展）*/
+typedef enum
+{
+	SET_SUBPIC,
+	SET_TRACK,
+	NORMAL_PLAY,
+	DISCARD_FRAMES,
+	NOTIFY_REF_FRAME_NUM,
+	NOTIFY_FIFO_RESET,
+	WAIT_FOR_HANTRO,
+	SET_FOURCC,
+	FLUSH_BUFFERS_REMAINING
+}plugin_ex_ops_cmd_t;
+
+typedef struct{
+	unsigned int a_pos;	
+	unsigned int v_pos;	
+	int a_pts;
+	int v_pts;
+	int cur_time;
+	int subpic_num;
+}subpic_param_t;
+
+typedef struct{
+	unsigned int a_pos;	
+	unsigned int v_pos;	
+	int a_pts;
+	int v_pts;
+	int cur_time;
+	int track_num;	
+	int out_basetime;//返回值
+}track_param_t;
+
+/*parser_format可选值*/
+typedef enum
+{
+	AVI = 0,
+	MP4,
+	MKV
+} fileFormat_t;
+
+//中间件切音轨/字幕时传给parser的数据结构
+typedef struct{
+	unsigned int audio_offset;
+	unsigned int audio_ts;
+	unsigned int video_offset;
+	unsigned int video_ts;
+	unsigned int subpic_offset;
+	unsigned int subpic_ts;
+}switch_audio_subpic_t;
+
+typedef enum
+{
+	IS_AUDIO = 1,
+	IS_VIDEO,
+	IS_AV
+}media_type_t;
+
+typedef struct
+{
+    char extension[8];      /* 解码库的后缀 */	
+    unsigned int sample_rate;		/* 采样率，单位hz */
+    unsigned int channels;			/* 声道数 */
+    void *buf;  
+    void *private_data;            /* 指向特定的音频格式数据结构 */
+    unsigned int audio_bitrate;
+    unsigned int a_max_pkt_size;
+} parser_audio_t;
+
+typedef struct{
+	char extension[8];
+	unsigned int width;
+	unsigned int height;
+	unsigned int frame_rate;
+	void *buf;		
+	unsigned int video_bitrate;
+	unsigned int v_max_pkt_size;	
+}parser_video_t;
+
+typedef struct{
+	unsigned int drm_flag;
+	char *license_info;
+	char *special_info;
+}parser_drm_t;
+
+typedef struct
+{
+    char extension[8];      /* 解码库的后缀 */    
+    void *buf;  
+    void *private_data;            /* 指向特定的音频格式数据结构 */
+} parser_subtitle_t;
+
+typedef struct{	
+	parser_audio_t parser_audio[16];//多达16条音轨
+	parser_video_t parser_video;
+	parser_drm_t parser_drm;
+	parser_subtitle_t parser_subtitle[16];
+	unsigned int sub_num;
+	unsigned int audio_num;		
+    unsigned int media_type;
+	unsigned int total_time;
+	unsigned int first_audio_time;	
+	unsigned int index_flag;    	
+	unsigned int a_len_array[32];
+	unsigned int v_len_array[32];
+}media_info_t;
+
+
+/* 定义codec不支持特性*/
+typedef enum
+{
+	PLUGIN_SUPPORTED,//支持
+	PLUGIN_NOT_SUPPORTED_FIELDMOD,//h264/xvid场模式不支持
+	PLUGIN_NOT_SUPPORTED_YUV444,//h264的yuv444不支持
+	PLUGIN_NOT_SUPPORTED_GMC,//xvid sprite,gmc特性不支持
+	PLUGIN_NOT_SUPPORTED_RPR,//rv变分辨率不支持
+	PLUGIN_NOT_SUPPORTED_ADVANCED,//vc1的advanced profile不支持
+	PLUGIN_NOT_SUPPORTED_OTHER//其他不支持
+}video_plugin_supported_t;
+
+typedef struct{
+         unsigned int width;//宽
+         unsigned int height;//高
+         unsigned int src_width;//源宽
+         unsigned int src_height;//源高
+         unsigned int xpos;//起始刷屏点x轴,无padding则为0
+         unsigned int ypos;//起始刷屏点y轴,无padding则为0 
+         unsigned int ref_num; //参考帧个数
+         unsigned int extra_frame_size;//根据该值中间件分配相应内存
+         video_plugin_supported_t supported; // 根据spec设计玫举类型
+}video_codec_info_t;
+
+typedef struct fb_port_s 
+{
+    void *(*get_wbuf)(struct fb_port_s *port,unsigned int buf_size);     
+    void *(*try_get_wbuf)(struct fb_port_s *port,unsigned int buf_size);     
+} fb_port_t;
+
+
+typedef struct {
+	unsigned int display_flag;    //本帧可以显示--1，不能显示--0
+	unsigned int use_flag;  //本帧正在被使用--1，没被使用--0    
+	unsigned int time_stamp;    //本帧的时间戳
+	unsigned int width;        //高
+	unsigned int height;         //宽
+	unsigned int format;         //数据格式，虽然与open接口处的format重复，但还是保留   
+	unsigned int reserved1;
+	unsigned int reserved2;
+}dec_buf_t;
+
+/*解码器和中间件之间传递的空白帧的数据结构*/
+typedef struct
+{
+	dec_buf_t *vo_frame_info;
+	unsigned char* vir_addr;
+	unsigned char* phy_addr;
+	unsigned int size;
+}frame_buf_handle;
+/*parser和decoder之间的传递包的数据结构*/
+typedef struct
+{
+	unsigned char *vir_addr;
+	unsigned char *phy_addr;
+	unsigned int data_len;
+	void *reserved;
+}stream_buf_handle;
+
+typedef struct{
+		char file_extension[8];
+		void *(*open)(void *input,void *media_info);		/*open插件时需要告诉当前插件的输入输出*/		
+		int (*parse_stream)(void *handle,av_buf_t *ao_buf,av_buf_t *vo_buf);
+		int (*seek)(void *handle,void *time4seek);
+		int (*dispose)(void *handle);	
+		int (*ex_ops)(void *handle,int cmd,unsigned int arg);
+}demux_plugin_t;
+
+typedef struct{
+		char extension[8];
+		void *(*open)(void *ap_param,void *init_param,void *fb_vo);		
+		int (*decode_data)(void *handle,stream_buf_handle *bitstream_buf);
+		int (*dispose)(void *handle); 
+		int (*ex_ops)(void *handle,int cmd,unsigned int arg);
+		int (*probe)(void *init_buf,stream_buf_handle *bitstream_buf,video_codec_info_t *info);          
+}videodec_plugin_t;
+
+typedef struct
+{
+/*用于输入*/
+  unsigned int seek_time;// 需要跳到的时间
+  unsigned int cur_time; // 当前正播放到的时间，可能用于无index表搜索，无需求的不用该项
+/*用于输出*/
+  unsigned int found_audio_time;//跳到的文件位置的audio时间
+  unsigned int found_video_time;//跳到的文件位置的video时间
+} time_stuct_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/include/alsp/inc/ALenc_plugin.h b/include/alsp/inc/ALenc_plugin.h
new file mode 100755
index 0000000..c7b5a71
--- /dev/null
+++ b/include/alsp/inc/ALenc_plugin.h
@@ -0,0 +1,436 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: AVE recorder
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       noahkong    2009-06-08 15:00     1.0             build this file 
+*******************************************************************************/
+#ifndef __ALENC_PLUGIN_H__
+#define __ALENC_PLUGIN_H__
+
+//#ifdef _OS_UX_
+#include "./common/al_libc.h"
+#include "./common/stream_input.h"
+//#endif
+
+/*disk manager seek*/
+#define		DSEEK_SET		0x01
+#define		DSEEK_END		0x02
+#define		DSEEK_CUR		0x03
+
+#ifndef NULL
+#define		NULL		        0
+#endif
+
+/* used by muxer packet flag */
+#define		IS_AUDIO				0x01			//contains only audio
+#define		IS_VIDEO				0x02			//contains only video	
+#define		IS_AV					  0x03			//contains audio and video
+
+/* 定义了不同的插件类型常量，这些常量用于插件信息的type字段 */
+#define 	PLUGIN_MUX		        0x05			//plugin for muxer
+#define		PLUGIN_VIDEO_ENCODER	0x07			//plugin for video encoder
+#define 	PLUGIN_IMAGE_ENCODER	0x08			//plugin for img encoder
+//#define (_SIG_TEST_)||(_SDK_227D_)
+//#ifdef _SIG_TEST_
+//  #include "./common/al_libc.h"
+//  #include "./common/stream_input.h"
+//#else
+//  
+//  #ifdef _USDK_227D_
+//    #include "./common/al_libc.h"
+//    #include "./common/stream_input.h"    
+//  #else
+//    #ifdef _OS_UC_
+//      typedef struct stream_input_s
+//      {
+//              int(*read)(struct stream_input_s *manager, char *buf, unsigned int len);
+//              int(*write)(struct stream_input_s *manager, char *buf, unsigned int len);
+//              int(*seek)(struct stream_input_s *manager, long long offset, int original);
+//              long long(*tell)(struct stream_input_s *manager);
+//      }stream_input_t;
+//    #endif
+//  #endif
+  
+//#endif
+
+/*!
+ * \brief
+ *      图像数据格式
+ */         
+typedef struct{		
+	unsigned int formate;
+	unsigned int bpp;		
+	unsigned int width;
+	unsigned int height;		
+	unsigned char *buf;
+	unsigned int len;
+	/*! rgb565背景图 + alpha 图，总bk_width*bk_height*2 + bk_width*bk_height*/
+	unsigned int bk_buf;
+	/*背景图宽*/ 
+	unsigned int bk_width;
+	/*背景图高*/
+	unsigned int bk_height;
+}image_info_t;
+
+/*!
+ * \brief
+ *      拍照初始化信息
+ */
+typedef struct
+{
+         /*! 标志照片是否打上日期 */  
+         unsigned int photo_data_flag;
+         /*! 日期信息(点阵) */
+         unsigned char *photo_data; 
+         /*! 日期信息(点阵)宽 */
+         unsigned int  pd_width;
+         /*! 日期信息(点阵)高 */
+         unsigned int  pd_height;
+         /*! exif设置信息 */
+         unsigned char *exif_info; 
+         /*! 是否缩放,0: normal; 1: scaler */
+         unsigned int   scale_mode;
+         /*! 是否启动大头帖, 0: 无; 1: 启动 */
+         unsigned int   func_mode;
+         /*! 图片编码后的宽 */
+         unsigned int dst_width; 
+         /*! 图片编码后的高 */
+         unsigned int dst_height;
+         /*! 数码变焦参数的分子 */
+         unsigned int fr; 
+         /*! 数码变焦参数的分母 */
+         unsigned int br; 
+}camera_init_t;
+
+
+#define SET_FACE_MASK_ON 0xb100
+#if 0
+/*!
+ * \brief
+ *      拍照时，所需人脸信息进行特效组合
+ */
+typedef struct {  
+        /*! 人脸特征信息 */
+        ALFace_appout_t *face_app;
+        /*! 拍照大图指针 */
+        image_info_t img;
+        /*! 备份信息 */
+        unsigned int bk_info;
+}ALFace_info_t;
+#endif
+/*!
+ * \brief
+ *      拍照接口
+ */
+typedef struct camera_plugin_s{
+	int (*init)(void *plugin, camera_init_t *param);
+	int (*encode_img)(void *plugin, image_info_t *img);
+	int (*dispose)(void *plugin);
+//#ifdef _USDK_227D_
+	int (*exop)(void *plugin,int cmd,unsigned int args);
+//#endif
+}camera_plugin_t;                                                         
+
+
+/*!
+ * \brief
+ *      显示使能接口（无使用）
+ */ 
+typedef  struct{
+        /* encoder显示功能是否使能 1：使能；0：不使能 */
+        int    enable_display;     
+        int    width;
+        int    height;
+} display_resolution_t;
+
+
+/*!
+ * \brief
+ *      音频编码器初始化参数
+ */ 
+typedef struct{
+        /* fmt of audio output */
+        char *audio_fmt;		         
+        /* 当前音频数据的分辨率 */
+        unsigned int bpp;
+        /* 编码后的比特率 */		         
+        unsigned int bitrate;	
+        /* 采样率 */
+        unsigned int sample_rate;	   	
+        /* 当前的通道数 */
+        unsigned int channels;		   
+        /* 编码模式立体声、联合立体声等等 */
+        unsigned int encode_mode;	   
+}ae_param_t;
+
+/*!
+ * \brief
+ *      音频编码器初始化参数
+ */ 
+typedef struct{
+        /* 编码后的宽 */
+        int width;
+        /* 编码后的高 */
+        int height;
+        /* 数据源的宽 */
+        int src_width;  
+        /* 数据源的高 */              
+        int src_height;    
+        /* 默认1 */            
+        int fincr;  
+        /* 与framerate等同 */                   
+        int fbase; 
+        /* 帧率 */                    
+        int framerate;	
+        /* I帧间距，（强制） xvid：3，mjpg：1 */	             
+        int max_key_interval;	
+        /* 初始量化比 */         
+        int quanty;
+        /* frame dropping: 0=drop none... 100=drop all */ 		                 
+        int frame_drop_ratio;  
+        /* B祯的个数,（强制）：0 */       
+        int max_bframes;
+        /* 暂时无效，0 */             
+        int video_bitrate;
+        /* 暂时无效，0 */             
+        int bQOffset;	
+        /* 暂时无效，0 */                 
+        int bQRatio;	
+        /* 存储外设 */	               
+        int cardtype;
+        /* reserved[2] is used for backup vidfmt*/
+        int reserved[9];
+}ve_param_t;
+
+/*!
+ * \brief
+ *      mux初始化参数
+ */ 
+typedef struct{
+        /* 文件格式 */
+        char file_fmt[12];
+        /* 流类型 */
+        unsigned int streamer_type;	
+        /* 音频参数 */	
+        ae_param_t audio_param;
+        /* 视频参数 */
+        ve_param_t video_param;
+        /* 音频格式　*/
+        char audio_fmt[12];
+        /* 视频格式　*/
+        char video_fmt[12];
+        /* no use　*/
+        unsigned char *tbl_buf; 		
+        unsigned int tbl_buf_len;
+}ave_param_t;
+
+/*!
+ * \brief
+ *      编码数据格式
+ */ 
+typedef struct{
+	unsigned char *data;
+	int  data_len;
+	/* 音频数据时为 0；视频 0 - 非关键祯，1 - 关键祯 */
+	int  is_key_frame; 
+	/* 时间戳 */	
+	int  encode_type;	
+}encode_frame_t;
+
+/*!
+ * \brief
+ *      打包数据格式
+ */ 
+typedef struct{
+        /*chunk类型：使用常量定义IS_AUDIO//IS_VIDEO// */
+	int media_type; 	
+	char *data;
+	int data_len;	
+	int is_key_frame;
+	/* 时间戳 */
+	int  time_stamp;	
+	int reserved[9];
+}av_chunk_t;
+
+
+typedef struct {
+  ave_param_t *ave_param;
+  stream_input_t *input;
+	unsigned int 	 reserved[2];
+}mux_input_attr_t;	
+					
+/* mux当前需要audio packet还是video packet */
+#define GET_PACKET_TYPE     0xc001    
+/* 获取mux状态信息 */                                  
+#define GET_MUXER_STATUS    0xc002   
+/* 重新初始化 */
+#define RESET_MUXER         0xc003
+
+
+/*!
+ * \brief
+ *      mux当前的编码信息
+ */
+typedef  enum{
+    EITHER_OK,
+    AUDIO_PACKET,
+    VIDEO_PACKET	
+}packet_type_t;
+
+/*!
+ * \brief
+ *      mux当前的状态信息
+ */
+typedef struct {
+        /* including audio and video frames or other */
+	unsigned int     total_frames;		 
+	unsigned int     video_frames;
+	unsigned int     audio_frames;
+	/* 文件位置 低32位 */
+	unsigned int     movi_length_L;	
+	/* 文件位置 高32位 */     
+	unsigned int     movi_length_H;		 
+	unsigned int 	 reserved[5];	
+}mux_output_attr_t;						         
+
+/*!
+ * \brief
+ *      编码输出数据
+ */
+typedef struct{
+	char *data;
+	int data_len;
+	//音频数据时为 0；视频 0 - 非关键祯，1 - 关键祯
+	int is_key_frame;
+	//时间戳 	
+	int  encode_type;	
+}av_frame_t;
+
+/* 获取encoder属性信息，包括是否具有动静监测功能 */
+#define GET_ENCODER_ATTR     0xb001  
+/* 获取encoder状态信息，当前帧是否运动 */
+#define GET_ENCODER_STATUS   0xb002  
+/* display_resolution_t结构指针，显示分辨率 */
+#define SET_DISPLAY_PARAM    0xb005    
+
+/*!
+ * \brief
+ *      编码器当前状态
+ */
+typedef struct {
+        /* current(accurately last) frame encode type I/P/B/SKip */
+	unsigned int frame_type;
+	/* current(accurately last) frame encode length (bytes)	*/    
+	unsigned int frame_size;
+	/* current(accurately last) quality */	    
+	unsigned int cur_quality;	
+	/* current(accurately last) I maxinterval */   
+	unsigned int cur_interval;
+	/* 当前检测得到的状态 */	  
+	unsigned int cur_suv_status; 
+	/* 输出的display buffer */
+	unsigned int display_buf; 
+	/* 输出的中间参数 */    
+	unsigned int inter_param;   
+	/* display buffer中图像的宽 */  
+	unsigned short out_width;   
+	/* display buffer中图像的高 */ 
+	unsigned short out_height;  
+	/* display buffer中图像格式; 1: 4Y4U4Y4V, 2:YUV_4_2_0_PLANAR */  
+	unsigned short out_format;    
+}videoenc_output_attr_t;		    
+
+/* 设置动静监测参数 */
+#define  SET_MOTION_PARAM      0xb003   
+/* 设置数码变焦参数 */
+#define  SET_ZOOM_PARAM        0xb004   
+/* 设置数码变焦窗口 */ 
+#define  SET_SOURCE_WINDOWN    0xb008
+/* 设置IP间隔 */
+#define  SET_FRM_INTVAL        0xb009
+
+/*!
+ * \brief
+ *      动静监测参数
+ */
+typedef struct {
+        /* current(accurately last) quality */
+	unsigned int cur_quality;	
+	/* current(accurately last) I maxinterval */     
+	unsigned int cur_interval;
+	/* 检测模式, 动静监测是否使能 */	   
+	int          sur_field_mode; 
+	/* default:3 */  
+	unsigned short md_throld0;
+	/* default:2 */ 
+	unsigned short md_throld1;
+	/* default:2 */
+	unsigned short md_throld2;
+	/* default:2 */   
+	unsigned short md_throld3;
+	unsigned int   reserved[3];
+}videoenc_input_attr_t;			   
+
+/*!
+ * \brief
+ *      数码变焦参数
+ */
+typedef  struct{
+        /* 数码变焦功能是否使能 1：使能；0：不使能 */
+        int    enable_zoom ;      
+        int    fr;
+        int    br;
+} encoder_zoom_t;
+
+/*!
+ * \brief
+ *      输入图像窗口参数
+ */
+typedef  struct{
+        int    width;
+        int    height;
+} encoder_srcwin_t;
+
+/*!
+ * \brief
+ *      插件结构
+ */
+typedef struct{
+        char type;
+        char *extension;
+        void *(*open)(void *plugio);		/*open插件时需要告诉当前插件的输入输出*/
+        int (*get_file_info)(stream_input_t *input,void *file_info);
+}plugin_info_t;
+
+/*!
+ * \brief
+ *      视频编码器插件
+ */
+typedef struct video_encoder_s{
+        int (*init)(struct video_encoder_s *plugin,ve_param_t *param);
+        int (*encode_data)(struct video_encoder_s *plugin,av_frame_t *src_frame,av_frame_t *dest_frame);
+        int (*set_attribute)(struct video_encoder_s *plugin,int attrib_id,void *param);
+        int (*get_attribute)(struct video_encoder_s *plugin,int attrib_id,void *param);
+        int (*get_err)(struct video_encoder_s *plugin);
+        int (*dispose)(struct video_encoder_s *plugin);
+}video_encoder_t;
+
+/*!
+ * \brief
+ *      音视频合流器插件
+ */
+typedef struct mux_plugin_s{
+        int (*init)(struct mux_plugin_s *plugin,ave_param_t *param);
+        int (*write_header)(struct mux_plugin_s *plugin);
+        int (*write_chunk)(struct mux_plugin_s *plugin,av_chunk_t *chunk);
+        int (*set_attribute)(struct mux_plugin_s *plugin,int attrib_id,void *param);
+        int (*get_attribute)(struct mux_plugin_s *plugin,int attrib_id,void *param);
+        int (*get_error)(struct mux_plugin_s *plugin);
+        int (*dispose)(struct mux_plugin_s *plugin);
+}mux_plugin_t;
+
+#endif
diff --git a/include/alsp/inc/ActDataSource.h b/include/alsp/inc/ActDataSource.h
new file mode 100755
index 0000000..22364fb
--- /dev/null
+++ b/include/alsp/inc/ActDataSource.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ACT_DATA_SOURCE_H_
+#define ACT_DATA_SOURCE_H_
+    
+#include <media/stagefright/DataSource.h>
+
+#include "./common/al_libc.h"
+#include "./common/storageio.h"
+#include "./common/stream_input.h"
+
+namespace android {
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+storage_io_t *create_storage_io(void);
+off64_t init_storage_io(storage_io_t *io, const sp<DataSource>& source);
+void dispose_storage_io(storage_io_t *io);
+
+stream_input_t *stream_input_open(void);
+off64_t stream_input_init(stream_input_t *input, const sp<DataSource>& source);
+void stream_input_dispose(stream_input_t *input);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+} // namespace android
+
+#endif  // ACT_DATA_SOURCE_H_
diff --git a/include/alsp/inc/actal_libc_dev.h b/include/alsp/inc/actal_libc_dev.h
new file mode 100755
index 0000000..839ff27
--- /dev/null
+++ b/include/alsp/inc/actal_libc_dev.h
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: common
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     actal_libc_dev.h
+ * \brief    C库函数声明，屏蔽操作系统以及方案的差别
+ * \author   kkli
+ * \version 1.0
+ * \date  2009/1/1
+*******************************************************************************/
+#ifndef __ACTAL_LIBC_DEV_H__
+#define __ACTAL_LIBC_DEV_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef long long int64_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+
+#include "./common/al_libc.h"
+
+#define NULL        0
+#define TRUE        1
+#define FALSE       0
+
+/*!
+ * \brief  
+ *      文件系统相关操作声明，仅适用于debug
+ */
+typedef int FILE;
+
+#define SEEK_SET    0
+#define SEEK_CUR    1
+#define SEEK_END    2
+
+FILE *fopen(const char *, const char *);
+int fread(void *, int, int, FILE *);
+int fwrite(void *, int, int, FILE *);
+int fseek(FILE *, int, int);
+int ftell(FILE *);
+int feof(FILE *);
+int fprintf(FILE *, const char *, ...);
+char *fgets(char *, int, FILE *);
+int fclose(FILE *);
+
+void *memcmp(const void *, const void *, int);
+void *memmove(void *, const void *, int);
+/*!
+ * \brief  
+ *      字符串相关操作声明
+ */
+char *strcpy(char *, const char *);
+char *strncpy(char *, const char *, int);
+char *strcat(char *, const char *);
+char *strchr(const char *, int);
+char *strstr(const char *, const char *);
+int strcmp(const char *, const char *);
+int strncmp(const char *, const char *, int);
+int strlen(const char *);
+int sprintf(char *, const char *, ...);
+int sscanf(const char *, const char *, ... );
+int atoi(const char *);
+/*!
+ * \brief  
+ *      打印操作声明
+ */
+int printf(const char *, ...); 
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+#endif // __ACTAL_LIBC_DEV_H__
diff --git a/include/alsp/inc/actal_posix_dev.h b/include/alsp/inc/actal_posix_dev.h
new file mode 100755
index 0000000..dc6d75b
--- /dev/null
+++ b/include/alsp/inc/actal_posix_dev.h
@@ -0,0 +1,54 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: common
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-02-01 15:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     actal_posix_dev.h
+ * \brief    算法posix thread接口
+ * \author   kkli
+ * \version 1.0
+ * \date  2009/2/1
+*******************************************************************************/
+#ifndef __ACTAL_POSIX_DEV_H__
+#define __ACTAL_POSIX_DEV_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <unistd.h>         /* for write */
+#include <errno.h>
+#include <pthread.h>        /* pthread_cond_*, pthread_mutex_* */
+#include <semaphore.h>      /* sem_wait, sem_post */
+#include <signal.h>
+
+#include <sys/mman.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <stdarg.h>
+
+#include <sys/types.h>
+#include <linux/asoc_ion.h>
+#include "./common/al_libc.h"
+
+
+#define TRUE            1
+#define FALSE           0
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __ACTAL_POSIX_DEV_H__
diff --git a/include/alsp/inc/al_libc_dll.h b/include/alsp/inc/al_libc_dll.h
new file mode 100755
index 0000000..9eb2768
--- /dev/null
+++ b/include/alsp/inc/al_libc_dll.h
@@ -0,0 +1,7 @@
+typedef __int64 mmm_off_t;
+#define actal_free free
+#define actal_malloc malloc
+#define actal_memset memset
+#define actal_memcpy memcpy
+
+
diff --git a/include/alsp/inc/alsp_includes.h b/include/alsp/inc/alsp_includes.h
new file mode 100755
index 0000000..ca597f0
--- /dev/null
+++ b/include/alsp/inc/alsp_includes.h
@@ -0,0 +1,55 @@
+#ifndef __ALSP_INCLUDES_H__
+#define __ALSP_INCLUDES_H__
+
+// 系统相关的外部头文件, 主要用于中间件等系统相关模块
+
+
+
+
+#if defined(_OS_UC_)
+#include <libc/stdio.h>
+#include <libc/stdlib.h>
+#include <libc/stdarg.h>
+#include <libc/string.h>
+#include <libc/pthread.h>
+#include <libc/fcntl.h>
+#include <libc/time.h>
+#include <libc/sys/ioctl.h>
+#include <libc/sys/types.h>
+#include <libc/sys/mman.h>
+#include <libc/dlfcn.h>
+#include <libc/unistd.h>
+#include <libc/semaphore.h>
+#include "asm-mips/mach-atj228x/actions_reg_gl5005.h"
+#include "ucos/page.h"
+#include "act_mem.h"
+#include "fb.h"
+#endif
+
+
+
+#ifdef _OS_UX_
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <time.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <dlfcn.h>
+#include <unistd.h>
+#include <semaphore.h>
+#include "actions_reg_gl5005.h"
+#include "dma_mem.h"
+#include "fb_drv.h"                /////////atv600x framebuffer的头文件
+#include "asoc_ioctl.h"            /////////该方案的ioctl命令字定义
+
+#endif
+
+extern int actal_error(const char *format, ...);
+extern int actal_printf(const char *format, ...);
+
+#endif //#ifndef __ALSP_INCLUDES_H__
diff --git a/include/alsp/inc/alsp_incs.h b/include/alsp/inc/alsp_incs.h
new file mode 100755
index 0000000..bd33317
--- /dev/null
+++ b/include/alsp/inc/alsp_incs.h
@@ -0,0 +1,12 @@
+#ifndef __ALSP_INCS_H__
+#define __ALSP_INCS_H__
+
+
+
+
+// 只和alsp内部相关的内部头文件，主要用于codec
+#include "actal_libc_dev.h"
+
+
+#endif
+
diff --git a/include/alsp/inc/audio_decoder_lib_dev.h b/include/alsp/inc/audio_decoder_lib_dev.h
new file mode 100755
index 0000000..49d322d
--- /dev/null
+++ b/include/alsp/inc/audio_decoder_lib_dev.h
@@ -0,0 +1,92 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicdec
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-18 15:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     audio_decoder_lib_dev.h
+ * \brief    音频解码库所需要的头文件
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/18
+*******************************************************************************/
+#ifndef __AUDIO_DECODER_LIB_DEV_H__
+#define __AUDIO_DECODER_LIB_DEV_H__
+
+#include "./common/audiout_pcm.h"
+#include "./common/extdef.h"
+
+typedef enum
+{
+    EX_OPS_SPDIF_OUTPUT     = 0x455801,
+    EX_OPS_CHUNK_RESET      = 0x455802,
+} audiodec_ex_ops_cmd_t;
+/*!
+ * \brief
+ *      定义音频解码插件返回的类型
+ */
+typedef enum
+{
+    /*! 一般未知错误 */
+    AD_RET_UNEXPECTED = -3,
+    /*! 内存空间不够 */
+    AD_RET_OUTOFMEMORY,
+    /*! 格式不支持，不能继续解码 */
+    AD_RET_UNSUPPORTED,
+    /*! 正常 */
+    AD_RET_OK,
+    /*! 输入数据不够 */
+    AD_RET_DATAUNDERFLOW,
+} audiodec_ret_t;
+/*!
+ * \brief
+ *      定义音频解码插件需提供的数据结构
+ */
+typedef struct
+{
+    /*! 插件库后缀，大写，例："COOK"，参考头文件定义 */
+    char extension[MAX_EXT_SIZE];
+
+    /*!
+     * \par  Description:
+     *	  打开插件
+     * \param[in]   init_buf 初始化信息，由parser和解码库自行约定数据结构
+     * \return      插件句柄
+     * \retval           others sucess
+     * \retval           NULL failed
+     */
+    void *(*open)(void *init_buf);
+    /*!
+     * \par  Description:
+     *	  解码一帧数据
+     * \param[in]   handle 插件句柄
+     * \param[in]   input 输入数据的起始地址
+     * \param[in]   input_bytes 输入数据的长度
+     * \param[out]  aout 解码输出，结构参考audiout_pcm_t
+     * \param[out]  bytes_used 解码当前帧用的字节数
+     * \return      the result (audiodec_ret_t)
+     */
+    int (*frame_decode)(void *handle, const char *input, const int input_bytes, audiout_pcm_t *aout, int *bytes_used);
+    /*!
+     * \par  Description:
+     *	  扩展命令，不需要此功能的实现为空即可
+     * \param[in]   handle 插件句柄
+     * \param[in]   cmd 命令字
+     * \param[in]   args 参数
+     * \return      the result (audiodec_ret_t)
+     */
+    int (*ex_ops)(void *handle, int cmd, int args);
+	/*!
+     * \par  Description:
+     *	  关闭插件
+     * \param[in]   handle 插件句柄
+     */
+    void (*close)(void *handle);
+} audiodec_plugin_t;
+
+#endif  // __AUDIO_DECODER_LIB_DEV_H__
diff --git a/include/alsp/inc/audio_encoder_lib_dev.h b/include/alsp/inc/audio_encoder_lib_dev.h
new file mode 100755
index 0000000..0ef22b4
--- /dev/null
+++ b/include/alsp/inc/audio_encoder_lib_dev.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicenc
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-18 11:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     audio_encoder_lib_dev.h
+ * \brief    定义了audioenc插件通用的接口
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/9/18
+*******************************************************************************/
+#ifndef __AUDIO_ENCODER_LIB_DEV_H__
+#define __AUDIO_ENCODER_LIB_DEV_H__
+
+#include "./common/audioin_pcm.h"
+#include "./common/enc_audio.h"
+#include "./common/extdef.h"
+
+typedef enum
+{
+    /*! 一般未知错误 */
+    AE_RET_UNEXPECTED = -7,
+    /*! 编码库加载出错 */
+    AE_RET_LIBLOAD_ERROR,
+    /*! 加载了非法的编码库 */
+    AE_RET_LIB_ERROR,
+     /*! 编码出错 */
+    AE_RET_ENCODER_ERROR,
+     /*! 采样率错误 */
+    AE_RET_FS_ERROR,
+    /*! 内存空间不够 */
+    AE_RET_OUTOFMEMORY,
+    /*! 格式不支持，不能继续解码 */
+    AE_RET_UNSUPPORTED,
+    /*! 正常 */
+    AE_RET_OK,
+    /*! 输出数据超过缓冲区大小 */
+    AE_RET_DATAOVERFLOW,
+} audioenc_ret_t;
+
+typedef struct
+{
+    /*! 编码一帧所需的样本数 */
+    int samples_per_frame;
+    /*! payload/packet大小，单位字节 */
+    int chunk_size;
+    /*! 初始写入文件起始的数据 */
+    /*! 数据指针 */
+    void *buf;
+    /*! 数据长度 */
+    int buf_len;
+} audioenc_attribute_t;
+
+typedef struct
+{
+    char extension[MAX_EXT_SIZE];
+
+    void *(*open)(enc_audio_t *enc_audio);
+    int (*get_attribute)(void *handle, audioenc_attribute_t *attribute);
+    int (*update_header)(void *handle, char **header_buf, int *header_len);
+    int (*frame_encode)(void *handle, audioin_pcm_t *ain, char *output, int *bytes_used);
+    void (*close)(void *handle);
+} audioenc_plugin_t;
+
+#endif // __AUDIO_ENCODER_LIB_DEV_H__
diff --git a/include/alsp/inc/common/al_libc.h b/include/alsp/inc/common/al_libc.h
new file mode 100755
index 0000000..2cc2920
--- /dev/null
+++ b/include/alsp/inc/common/al_libc.h
@@ -0,0 +1,107 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: common
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     al_libc.h
+ * \brief    al内部实现的C库函数声明，对应于有一个确定的实现
+ * \author   kkli
+ * \version 1.0
+ * \date  2009/1/1
+*******************************************************************************/
+#ifndef __AL_LIBC_H__
+#define __AL_LIBC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define INLINE      inline
+
+typedef int64_t mmm_off_t;
+
+/*!
+ * \brief
+ *      内存相关操作声明
+ */
+void *actal_memcpy(void *, const void *, int32_t);
+void *actal_memset(void *, int32_t, int32_t);
+
+/*!
+ * \brief
+ *      内存管理相关操作声明
+ */
+/*! 申请逻辑地址，参数为长度 */
+void *actal_malloc(int32_t);
+void actal_free(void *);
+/*! 申请物理地址连续的地址，第一个参数为长度，第二个参数为输出的物理地址 */
+void *actal_malloc_dma(int32_t, int32_t *);
+void actal_free_dma(void *);
+/*! 申请物理地址连续的write-through地址，第一个参数为长度，第二个参数为输出的物理地址
+    write-through的特点是：保证了读的速度，写的时候不只是更新到cache
+ */
+void *actal_malloc_wt(int32_t, int32_t *);
+void actal_free_wt(void *);
+void actal_cache_flush(void *, int);
+void actal_cache_env(void *, int);
+/*! 申请物理地址连续的不经过cache的地址，第一个参数为长度，第二个参数为输出的物理地址
+    不经过cache的特点是：对该地址进行操作后可以直接进行dma操作
+ */
+void *actal_malloc_uncache(int32_t, int32_t *);
+void actal_free_uncache(void *);
+/*! 获取物理地址 */
+int actal_get_phyaddr(void *);
+void * actal_get_virtaddr(int );
+/*!
+ * \brief
+ *      按规则打印一段内存地址
+ */
+void actal_dump(int *, int32_t);
+
+/*!
+ * \brief
+ *      获取系统当前时间，单位ms，用于测定性能
+ */
+int64_t actal_get_ts(void);
+
+/*!
+ * \brief
+ *      设定打印输出，可被统一打开或关闭
+ */
+int32_t actal_printf(const char *format, ...);
+/*!
+ * \brief
+ *      设定打印输出，始终打开，字符限制为256个
+ */
+int32_t actal_error(const char *format, ...);
+/*!
+ * \brief
+ *      设定打印输出，发布时关闭
+ */
+int32_t actal_info(const char *format, ...);
+
+/*!
+ * \brief
+ *      设置睡眠一段时间，输入参数毫秒，会导致任务切换
+ */
+void actal_sleep_ms(int32_t);
+/*!
+ * \brief
+ *      获取IC信息，0~7bit表示ic类型，8~15bit表示ic版本，如：0x4303表示5003 C版
+ */
+int actal_get_icinfo(void);
+
+int actal_check_utf8(const char *utf8, int length);
+int actal_convert_ucnv(char *from_charset, char *to_charset, const char *inbuf, int inlen,
+		char *outbuf, int outlen);
+int actal_encode_detect(const char *src, char *encoding);
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+#endif // __AL_LIBC_H__
diff --git a/include/alsp/inc/common/audioin_pcm.h b/include/alsp/inc/common/audioin_pcm.h
new file mode 100755
index 0000000..a141f1c
--- /dev/null
+++ b/include/alsp/inc/common/audioin_pcm.h
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: audio in
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-05 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     audioin_pcm.h
+ * \brief    解码输出的数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/05
+*******************************************************************************/
+#ifndef __AUDIOIN_PCM_H__
+#define __AUDIOIN_PCM_H__
+
+/*!
+ * \brief  
+ *      定义最大的输入声道数
+ */
+#define MAX_CHANNEL_IN     2
+/*!
+ * \brief  
+ *      音频编码插件帧解码的输入或音频输入模块的输出
+ */
+typedef struct
+{
+    /*! pcm数据指针数组 */
+    int pcm[MAX_CHANNEL_IN];
+    /*! 当前输入的channel数 */
+    int channels;
+    /*! 当前输入的sample数 */
+    int samples;
+} audioin_pcm_t;
+
+#endif // __AUDIOIN_PCM_H__
diff --git a/include/alsp/inc/common/audiout_pcm.h b/include/alsp/inc/common/audiout_pcm.h
new file mode 100755
index 0000000..e5969a7
--- /dev/null
+++ b/include/alsp/inc/common/audiout_pcm.h
@@ -0,0 +1,42 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: audio out
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-05 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     audiout_pcm.h
+ * \brief    定义解码输出的数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/05
+*******************************************************************************/
+#ifndef __AUDIOUT_PCM_H__
+#define __AUDIOUT_PCM_H__
+
+/*!
+ * \brief  
+ *      定义最大的输出声道数
+ */
+#define MAX_CHANNEL     6
+/*!
+ * \brief  
+ *      音频解码插件帧解码的输出或音频输出模块的输入
+ */
+typedef struct
+{
+    /*! pcm数据指针数组，包含各声道输出数据的起始地址 */
+    int pcm[MAX_CHANNEL];
+    /*! 当前输出包含的声道数 */
+    int channels;
+    /*! 当前输出包含的样本数，只计单个声道 */
+    int samples;
+    /*! 当前输出小数点的位数，整数取值0 */
+    int frac_bits;
+} audiout_pcm_t;
+
+#endif // __AUDIOUT_PCM_H__
diff --git a/include/alsp/inc/common/buf_header.h b/include/alsp/inc/common/buf_header.h
new file mode 100755
index 0000000..a3dcd1a
--- /dev/null
+++ b/include/alsp/inc/common/buf_header.h
@@ -0,0 +1,39 @@
+#ifndef __BUF_HEADER_H__
+#define __BUF_HEADER_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*包类型*/
+typedef enum
+{
+    AUDIO_PACKET = 0x100,
+    VIDEO_PACKET = 0x200,
+    SUBPIC_PACKET = 0x300
+} packet_type_t;
+
+//音视频包都预留了28个bytes头未用，现将此28bytes数据结构化
+typedef struct{
+	/*包类型*/
+	unsigned int header_type;
+	/*包载荷长度*/
+	unsigned int block_len;
+	/*包的文件位置*/
+	unsigned int packet_offset;
+	/*包的时间戳*/
+	unsigned int packet_ts;
+	/*保留字段1*/
+	unsigned int reserved1;
+	/*保留字段2*/
+	unsigned int reserved2;
+	/*h264得到正确时间戳需要的信息*/
+	unsigned char stream_end_flag;/*1为结束， 0为否*/
+	unsigned char parser_format;
+	unsigned char seek_reset_flag;
+	unsigned char reserved_byte2;
+}packet_header_t;
+#ifdef __cplusplus
+}
+#endif
+#endif // __BUF_HEADER_H__
diff --git a/include/alsp/inc/common/enc_audio.h b/include/alsp/inc/common/enc_audio.h
new file mode 100755
index 0000000..a2a54a3
--- /dev/null
+++ b/include/alsp/inc/common/enc_audio.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicenc
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-18 11:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     enc_audio.h
+ * \brief    定义打开一个音频编码库所需的信息
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/9/18
+*******************************************************************************/
+#ifndef __ENC_AUDIO_H__
+#define __ENC_AUDIO_H__
+
+/*!
+ * \brief  
+ *      打开音频编码库所需的信息
+ */
+typedef struct
+{
+	/*! 采样率，单位hz */
+    int sample_rate;
+    /*! 声道数 */
+    int channels;
+    /*! 歌曲比特率 */
+    int bitrate;
+    /*! 编码库格式，一个加载的编码库里可能包含多个格式，例：IMADPCM */
+    int audio_format;
+    /*! 一次获取到的音频编码后数据播放时长，0说明不限制，单位ms */
+    int chunk_time;   
+} enc_audio_t;
+
+#endif // __ENC_AUDIO_H__
diff --git a/include/alsp/inc/common/extdef.h b/include/alsp/inc/common/extdef.h
new file mode 100755
index 0000000..730c49b
--- /dev/null
+++ b/include/alsp/inc/common/extdef.h
@@ -0,0 +1,71 @@
+/********************************************************************************
+*                              5003
+*                            Module: extension definition
+*                 Copyright(c) 2003-2008 Actions Semiconductor,
+*                            All Rights Reserved.
+*
+* History:
+*      <author>    <time>           <version >             <desc>
+*       kkli     2008-08-26 11:00     1.0             build this file
+********************************************************************************/
+/*!
+* \file     extdef.h
+* \brief    提供后缀名所对应的字符串
+* \author   kkli
+* \version 1.0
+* \date  2008/08/26
+*******************************************************************************/
+#ifndef __EXTDEF_H__
+#define __EXTDEF_H__
+
+/* 最大的后缀名长度 */
+#define MAX_EXT_SIZE            8
+
+/* music related parser */
+#define PARSER_EXT_MP3          "MP3"
+#define PARSER_EXT_AAC          "AAC"
+#define PARSER_EXT_WMA          "WMA"
+#define PARSER_EXT_WMALSL       "WMALSL"
+#define PARSER_EXT_WMAPRO       "WMAPRO"
+#define PARSER_EXT_RMA          "RMA"
+#define PARSER_EXT_WAV          "WAV"
+#define PARSER_EXT_OGG          "OGG"
+#define PARSER_EXT_DTS          "DTS"
+#define PARSER_EXT_AC3          "AC3"
+#define PARSER_EXT_APE          "APE"
+#define PARSER_EXT_FLAC         "FLAC"
+#define PARSER_EXT_MPC          "MPC"
+#define PARSER_EXT_AIFF         "AIFF"
+#define PARSER_EXT_AA           "AA"
+#define PARSER_EXT_AAX          "AAX"
+#define PARSER_EXT_AMR          "AMR"
+#define PARSER_EXT_SAMPLE       "SAMPLE"
+#define PARSER_EXT_ALAC         "ALAC"
+
+/* music related decoder */
+#define DEC_EXT_MP3             "MP3"
+#define DEC_EXT_AAC             "AAC"
+#define DEC_EXT_WMASTD          "WMASTD"
+#define DEC_EXT_WMALSL          "WMALSL"
+#define DEC_EXT_WMAPRO          "WMAPRO"
+#define DEC_EXT_COOK            "COOK"
+#define DEC_EXT_PCM             "PCM"
+#define DEC_EXT_OGG             "OGG"
+#define DEC_EXT_DTS             "DTS"
+#define DEC_EXT_AC3             "AC3"
+#define DEC_EXT_APE             "APE"
+#define DEC_EXT_FLAC            "FLAC"
+#define DEC_EXT_ACELP           "ACELP"
+#define DEC_EXT_MPC             "MPC"
+#define DEC_EXT_AIFF            "AIFF"
+#define DEC_EXT_AMR             "AMR"
+#define DEC_EXT_SAMPLE          "SAMPLE"
+#define DEC_EXT_ALAC            "ALAC"
+#define DEC_EXT_AWB             "AWB"
+
+/* music related encoder */
+#define ENC_EXT_MP3             "MP3"
+#define ENC_EXT_WAV             "WAV"
+#define ENC_EXT_SAMPLE          "SAMPLE"
+
+#endif // __EXTDEF_H__
diff --git a/include/alsp/inc/common/music_info.h b/include/alsp/inc/common/music_info.h
new file mode 100755
index 0000000..6d53f19
--- /dev/null
+++ b/include/alsp/inc/common/music_info.h
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicdec
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-05 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     music_info.h
+ * \brief    定义parser输出的歌曲信息结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/05
+*******************************************************************************/
+#ifndef __MUSIC_INFO_H__
+#define __MUSIC_INFO_H__
+
+/*!
+ * \brief  
+ *      parser插件库返回的信息结构
+ */
+typedef struct
+{
+    /*! 解码库的后缀，大写，例："COOK" */
+    char extension[8];
+    /*! 最大的chunk大小，单位byte */
+    int max_chunksize;
+    /*! 总时间，单位seconds */
+    int total_time;
+    /*! 平均比特率，单位kbps */
+    int avg_bitrate;
+	/*! 采样率，单位hz */
+    int sample_rate;
+    /*! 声道数 */
+    int channels;
+    /*! 打开音频解码插件所需的输入参数，结构由特定格式约定 */
+    void *buf;
+} music_info_t;
+
+#endif // __MUSIC_INFO_H__
diff --git a/include/alsp/inc/common/storageio.h b/include/alsp/inc/common/storageio.h
new file mode 100755
index 0000000..0adf52b
--- /dev/null
+++ b/include/alsp/inc/common/storageio.h
@@ -0,0 +1,36 @@
+/********************************************************************************
+*                              5003
+*                            Module: storage io
+*                 Copyright(c) 2003-2008 Actions Semiconductor,
+*                            All Rights Reserved.
+*
+* History:
+*      <author>    <time>           <version >             <desc>
+*       kkli     2008-09-02 10:00     1.0             build this file
+********************************************************************************/
+/*!
+* \file     storageio.h
+* \brief    定义对存储设备的输入输出接口
+* \author   kkli
+* \version 1.0
+* \date  2008/09/02
+*******************************************************************************/
+#ifndef __STORAGEIO_H__
+#define __STORAGEIO_H__
+
+/*!
+ * \brief
+ *      提供和标准文件系统操作接口一致的存储设备输入输出接口
+ */
+typedef struct storage_io_s {
+    /*! 读数据 */
+    int (*read)(void *buf, int size, int count, struct storage_io_s *io);
+    /*! 写数据 */
+    int (*write)(void *buf, int size, int count, struct storage_io_s *io);
+    /*! 定位 */
+    int (*seek)(struct storage_io_s *io, mmm_off_t offset, int whence);
+    /*! 文件位置 */
+    mmm_off_t (*tell)(struct storage_io_s *io);
+} storage_io_t;
+
+#endif // __STORAGEIO_H__
diff --git a/include/alsp/inc/common/stream_input.h b/include/alsp/inc/common/stream_input.h
new file mode 100755
index 0000000..ad10252
--- /dev/null
+++ b/include/alsp/inc/common/stream_input.h
@@ -0,0 +1,16 @@
+#ifndef __STREAM_INPUT_H__
+#define __STREAM_INPUT_H__
+
+//------------------------------------------------------------------------------------
+/*文件操作*/
+#define		DSEEK_SET		0x01
+#define		DSEEK_END		0x02
+#define		DSEEK_CUR		0x03
+
+typedef struct stream_input_s {
+    int (*read)(struct stream_input_s *stream_input,unsigned char *buf,unsigned int len);
+    int (*write)(struct stream_input_s *stream_input,unsigned char *buf,unsigned int len);
+    int (*seek)(struct stream_input_s *stream_input,mmm_off_t offset,int original);
+    mmm_off_t (*tell)(struct stream_input_s *stream_input);
+} stream_input_t;
+#endif
diff --git a/include/alsp/inc/format_dev.h b/include/alsp/inc/format_dev.h
new file mode 100755
index 0000000..6386e74
--- /dev/null
+++ b/include/alsp/inc/format_dev.h
@@ -0,0 +1,42 @@
+/********************************************************************************
+*                              5003
+*                            Module: storage
+*                 Copyright(c) 2003-2008 Actions Semiconductor,
+*                            All Rights Reserved. 
+*
+* History:         
+*      <author>    <time>           <version >             <desc>
+*       kkli     2008-08-26 11:00     1.0             build this file
+********************************************************************************/
+/*!
+* \file     format_dev.h
+* \brief    提供对格式进行判断
+* \author   kkli
+* \version 1.0
+* \date  2008/08/26
+*******************************************************************************/
+#ifndef __FORMAT_DEV_H__
+#define __FORMAT_DEV_H__
+
+#include "./common/extdef.h"
+#include "./common/storageio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*!                    
+ * \par  Description:
+ *	  获取文件后缀
+ * \param[in]   storage_io_t 文件操作的接口
+ * \param[out]  后缀名字符串
+ * \return      是否能找到有效的后缀名
+ * \retval           0 sucess 
+ * \retval           -1 failed     
+ */   
+int format_check(storage_io_t *, const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __FORMAT_DEV_H__
diff --git a/include/alsp/inc/id3parse.h b/include/alsp/inc/id3parse.h
new file mode 100755
index 0000000..2180fc0
--- /dev/null
+++ b/include/alsp/inc/id3parse.h
@@ -0,0 +1,123 @@
+#ifndef __ID3PARSE_H__
+#define __ID3PARSE_H__
+#include <utils/Log.h>
+
+#include <media/stagefright/DataSource.h>
+#include "actal_posix_dev.h"
+
+namespace android {
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __ITEM_ENCODING__ 1
+#define __ALBUM_ART__  0
+#define  __TRACK_NUM__ 1
+#define  IS_MIN_CHAR(wch)   (((wch) > 0x60) && ((wch) < 0x7b))
+#define  UPPER(s)  (IS_MIN_CHAR(s)?(s-32):(s))
+
+#define ID3_SECTORSIZE  512*10  //cz_20121112 ID3死机原因是这个太小了，目前扩大到5K
+
+enum 
+{
+    ENCODING_NORMAL = 0,
+    ENCODING_UNICODE = 1,
+    ENCODING_UTF8 = 2,
+};
+
+typedef struct _item_info 
+{
+    char encoding;
+    int length;
+    char* content;
+}id3_item_info_t;
+
+typedef struct _image_info
+{
+    int offset;
+    int length;
+    char imageType[8];
+}id3_image_t;
+
+//typedef struct {
+//    int Address;
+//    int len;
+//}id3_item_t;
+
+typedef struct _id3_info {
+  id3_item_info_t author;
+  id3_item_info_t composer;
+  id3_item_info_t album;
+  id3_item_info_t genre;
+  id3_item_info_t track;
+  id3_item_info_t year;
+  id3_item_info_t title;
+  id3_item_info_t comment;
+  id3_item_info_t autoLoop;
+#if __ALBUM_ART__ > 0
+  id3_item_info_t albumArt;
+#endif
+  id3_image_t imageInfo;
+}id3_info_t;
+
+typedef struct
+{
+  unsigned int bitrate;
+  unsigned int sample_rate;
+  unsigned int channel;
+  unsigned int total_time;
+}id3_ext_info;
+
+typedef struct
+{
+  id3_info_t   tag;
+  id3_ext_info extra_info;
+}id3_info_total;
+
+typedef struct {
+    off_t mOffset;
+    off_t mFileSize;
+    sp<DataSource> mSource;
+} ID3file_t;
+
+//void TransToLittleEnd(char *buffer, int bufferLen);
+//int utf8_to_utf16(const unsigned char *utf8, int cc, unsigned short *unicode16);
+int get_audio_id3_info(ID3file_t* fp, char *fileinfo, id3_info_total* info);
+
+//for mp3 id3;
+void get_mp3_audio_info(void* fp,id3_info_total* info);
+void freeallmemory(id3_info_total *Tag);
+
+// for ogg id3
+void get_ogg_audio_info(void* fp,id3_info_total* info);
+
+//for wma id3
+void get_wma_audio_info(void* fp,id3_info_total* info);
+
+//for audible
+//void get_audible_audio_info(char* fp,id3_info_total* info);
+
+//for ape
+void get_ape_audio_info(void* fp,id3_info_total* info);
+void get_flac_audio_info(void *fd, id3_info_total* info);
+
+//void get_mp3_image (FS_Handle pFile, id3_image_t *imageInfo);
+
+int ID3_fseek(void *stream, long offset, int whence);
+int ID3_fread(void *buffer, size_t size, size_t count, void* stream);
+int ID3_getfilelength(void *stream);
+int parse_id3V1(void *fp, id3_info_total* pid3Info);
+int parse_id3V2_3(void *fp, id3_info_total* pid3Info);
+void getgenre(char c, id3_item_info_t* temp);
+void TransToLittleEnd(char *buffer, int bufferLen);
+int Unicode2utf8(char * string, int length);
+int wstrlen(char *buffer, int bufferLen);
+void item_itoa(id3_item_info_t *pitem);
+void freeallmemory(id3_info_total *info);
+void freeItem(id3_item_info_t *item);
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+} // namespace android
+
+#endif
diff --git a/include/alsp/inc/music_parser_lib_dev.h b/include/alsp/inc/music_parser_lib_dev.h
new file mode 100755
index 0000000..d91f45b
--- /dev/null
+++ b/include/alsp/inc/music_parser_lib_dev.h
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicdec
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-12 15:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     music_parser_lib_dev.h
+ * \brief    定义和parser插件有关的数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/18
+*******************************************************************************/
+#ifndef __MUSIC_PARSER_LIB_DEV_H__
+#define __MUSIC_PARSER_LIB_DEV_H__
+
+#include "./common/al_libc.h"
+#include "./common/storageio.h"
+#include "./common/music_info.h"
+#include "./common/extdef.h"
+
+typedef enum
+{
+    EX_OPS_GET_RESTIME     = 0x555801,
+} audioparser_ex_ops_cmd_t;
+/*!
+ * \brief
+ *      定义parser插件返回的类型
+ */
+typedef enum
+{
+    /*! 一般未知错误 */
+    MP_RET_UNEXPECTED = -3,
+    /*! 内存空间不够 */
+    MP_RET_OUTOFMEMORY,
+    /*! 格式不支持 */
+    MP_RET_UNSUPPORTED,
+    /*! 正常 */
+    MP_RET_OK,
+    /*! 文件结束 */
+    MP_RET_ENDFILE
+} music_parser_ret_t;
+/*!
+ * \brief
+ *      定义parser插件需提供的数据结构
+ */
+typedef struct
+{
+    /*! 插件库后缀，大写，例："RM" */
+    char extension[MAX_EXT_SIZE];
+
+    /*!
+     * \par  Description:
+     *	  打开插件
+     * \param[in]   storage_io 对输入进行读/写/定位等文件操作的函数指针，结构参考storage_io_t
+     * \return      插件句柄
+     * \retval           others sucess
+     * \retval           NULL failed
+     */
+    void *(*open)(storage_io_t *storage_io);
+    /*!
+     * \par  Description:
+     *	  解析文件头
+     * \param[in]   handle 插件句柄
+     * \param[out]  music_info 由插件返回的音乐信息，结构参考music_info_t
+     * \return      the result (music_parser_ret_t)
+     */
+    int (*parser_header)(void *handle, music_info_t *music_info);
+    /*!
+     * \par  Description:
+     *	  获取一个chunk的数据(chunk可以认为是多个帧的集合，建议持续时间一秒钟左右)
+     * \param[in]   handle 插件句柄
+     * \param[in]  output 数据输出的起始地址
+     * \param[out]  chunk_bytes 当前输出chunk的字节数
+     * \return      the result (music_parser_ret_t)
+     */
+    int (*get_chunk)(void *handle, char *output, int *chunk_bytes);
+    /*!
+     * \par  Description:
+     *	  定位到文件相应的时间（毫秒）
+     * \param[in]   handle 插件句柄
+     * \param[in]   time_offset 时间偏移量
+     * \param[in]   whence 参照位置（取值同文件seek）
+     * \param[out]  chunk_start_time 完成之后的起始播放时间
+     * \return      the result (music_parser_ret_t)
+     */
+    int (*seek_time)(void *handle, int time_offset, int whence, int *chunk_start_time);
+    /*!
+     * \par  Description:
+     *	  扩展命令，不需要此功能的实现为空即可
+     * \param[in]   handle 插件句柄
+     * \param[in]   cmd 命令字
+     * \param[in]   args 参数
+     * \return      the result (music_parser_ret_t)
+     */
+    int (*ex_ops)(void *handle, int cmd, int args);
+    /*!
+     * \par  Description:
+     *	  关闭插件
+     * \param[in]   handle 插件句柄
+     */
+    void (*close)(void *handle);
+} music_parser_plugin_t;
+
+#endif // __MUSIC_PARSER_LIB_DEV_H__
diff --git a/include/alsp/inc/muxer_wav.h b/include/alsp/inc/muxer_wav.h
new file mode 100755
index 0000000..fb96319
--- /dev/null
+++ b/include/alsp/inc/muxer_wav.h
@@ -0,0 +1,49 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: musicenc
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-20 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     muxer_wav.h
+ * \brief    定义了wav编码需要的一些特殊的字段
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/20
+*******************************************************************************/
+#ifndef __MUXER_WAV_H__
+#define __MUXER_WAV_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define WAV_LPCM        0x1
+#define WAV_MS_ADPCM    0x2
+#define WAV_ALAW        0x6
+#define WAV_ULAW        0x7
+#define WAV_IMA_ADPCM   0x11
+
+typedef struct
+{
+    /*! 采样率，单位Hz */
+    int32_t sample_rate;
+    /*! 比特率，单位bps */
+    int32_t bitrate;
+    /*! 声道 */
+    int32_t channels;
+    /*! chunk时间，单位毫秒 */
+    int32_t chunk_time;
+    /*! 0:纯音乐录音, 1:others，区分是否需要在attribute中预留header的空间 */
+    int32_t mode;
+    /*! 0x1: linear-pcm; 0x2: ms-adpcm; 0x6: alaw; 0x7: ulaw; 0x11: ima-adpcm */
+    int32_t format;
+} wav_audio_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __MUXER_WAV_H__
diff --git a/include/alsp/inc/parser_aac.h b/include/alsp/inc/parser_aac.h
new file mode 100755
index 0000000..8dbfe49
--- /dev/null
+++ b/include/alsp/inc/parser_aac.h
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: aac
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-20 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     parser_aac.h
+ * \brief    定义了parser必须提供给aac解码库的初始化数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/20
+*******************************************************************************/
+#ifndef __PARSER_AAC_H__
+#define __PARSER_AAC_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    int32_t object_type;
+    int32_t sf_index;
+    int32_t channels;
+} parser_aac_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __PARSER_AAC_H__
diff --git a/include/alsp/inc/parser_ac3.h b/include/alsp/inc/parser_ac3.h
new file mode 100755
index 0000000..d43eae1
--- /dev/null
+++ b/include/alsp/inc/parser_ac3.h
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: ac3
+ *                 Copyright(c) 2003-2009 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       chenzhan    2009-11-13 10:08   1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     parser_ac3.h
+ * \brief    定义了parser必须提供给ac3解码库的初始化数据结构
+ * \author   chenzhan
+ * \version 1.0
+ * \date  2009/11/13
+*******************************************************************************/
+#ifndef __PARSER_AC3_H__
+#define __PARSER_AC3_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    int32_t little_endian_flag; //默认输入格式是little模式=0 big模式=1
+} parser_ac3_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __PARSER_AAC_H__
diff --git a/include/alsp/inc/parser_mp3.h b/include/alsp/inc/parser_mp3.h
new file mode 100755
index 0000000..e91c473
--- /dev/null
+++ b/include/alsp/inc/parser_mp3.h
@@ -0,0 +1,8 @@
+typedef struct
+{
+	int stereo;
+	int lsf;
+	int mpeg25;
+	int sampling_frequency;
+}parser_mp3_t;
+
diff --git a/include/alsp/inc/parser_pcm.h b/include/alsp/inc/parser_pcm.h
new file mode 100755
index 0000000..aae1cb4
--- /dev/null
+++ b/include/alsp/inc/parser_pcm.h
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: WAV
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-20 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     parser_pcm.h
+ * \brief    定义了必须提供给pcm音频解码的初始化数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/20
+*******************************************************************************/
+#ifndef __PARSER_PCM_H__
+#define __PARSER_PCM_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define WAV_LPCM        0x1
+#define WAV_MS_ADPCM    0x2
+#define WAV_ALAW        0x6
+#define WAV_ULAW        0x7
+#define WAV_IMA_ADPCM   0x11
+#define WAV_BPCM        0x21  /* */
+
+typedef struct
+{    
+    int32_t format;             /* pcm的类型 */
+    int32_t channels;           /* 声道数 */
+    int32_t samples_per_frame;  /* 每帧包含的样本数 */
+    int32_t bits_per_sample;    /* 每个样本解码出来所应包含的bit数 */
+    int32_t bytes_per_frame;    /* 每帧包含的bytes数 */
+} parser_pcm_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __PARSER_PCM_H__
diff --git a/include/alsp/inc/parser_ra.h b/include/alsp/inc/parser_ra.h
new file mode 100755
index 0000000..ecaeff9
--- /dev/null
+++ b/include/alsp/inc/parser_ra.h
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: ra
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2008-09-20 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     parser_ra.h
+ * \brief    定义了rm parser必须提供给音频解码的初始化数据结构
+ * \author   kkli
+ * \version 1.0
+ * \date  2008/09/20
+*******************************************************************************/
+#ifndef __PARSER_RA_H__
+#define __PARSER_RA_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    int32_t FlavorIndex;
+    int32_t BitsPerFrame;
+    int32_t Channels;
+    
+	int32_t version;
+	int32_t samples;
+	int32_t regions;
+
+	int32_t delay;
+	int32_t cpl_start;
+	int32_t cpl_qbits;
+
+} parser_ra_t;
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __PARSER_RA_H__
diff --git a/include/alsp/inc/uconv_dev.h b/include/alsp/inc/uconv_dev.h
new file mode 100755
index 0000000..6b4390e
--- /dev/null
+++ b/include/alsp/inc/uconv_dev.h
@@ -0,0 +1,22 @@
+#ifndef __UCONV_DEV_H__
+#define __UCONV_DEV_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*!
+ * \brief
+ *		利用ucnv进行转码
+ * */
+int convert_ucnv(char *from_charset, char *to_charset, char *inbuf, int inlen,
+		char *outbuf, int outlen);
+/*!
+ * \brief
+ *		检查是否有效的utf-8格式
+ * */
+int check_valid_utf8(char *utf8, int length);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+#endif
diff --git a/include/alsp/inc/vde_core.h b/include/alsp/inc/vde_core.h
new file mode 100755
index 0000000..238fd7b
--- /dev/null
+++ b/include/alsp/inc/vde_core.h
@@ -0,0 +1,175 @@
+#ifndef _VDE_CORE_H_
+#define _VDE_CORE_H_
+
+typedef enum VDE_REG_NO
+{
+    VDE_REG0 = 0,    
+    VDE_REG1 ,  VDE_REG2,  VDE_REG3,  VDE_REG4,  VDE_REG5,  VDE_REG6,  VDE_REG7,  VDE_REG8, 
+    VDE_REG9 , VDE_REG10, VDE_REG11, VDE_REG12, VDE_REG13, VDE_REG14, VDE_REG15, VDE_REG16,
+    VDE_REG17, VDE_REG18, VDE_REG19, VDE_REG20, VDE_REG21, VDE_REG22, VDE_REG23, VDE_REG24,
+    VDE_REG25, VDE_REG26, VDE_REG27, VDE_REG28, VDE_REG29, VDE_REG30, VDE_REG31, VDE_REG32,
+    VDE_REG33, VDE_REG34, VDE_REG35, VDE_REG36, VDE_REG37, VDE_REG38, VDE_REG39, VDE_REG40,    
+    VDE_REG41, VDE_REG42, VDE_REG43, VDE_REG44, VDE_REG45, VDE_REG46, VDE_REG_MAX,
+} VDE_RegNO_t;   
+
+
+#define MAX_VDE_REG_NUM         (VDE_REG_MAX+1)
+
+
+// 作为一个backdoor, 提供额外的参数输入接口, 使用方法和配置寄存器无异
+#define CODEC_CUSTOMIZE_ADDR            (VDE_REG_MAX)
+#define CODEC_CUSTOMIZE_VALUE_PERFORMANCE  0x00000001
+#define CODEC_CUSTOMIZE_VALUE_LOWPOWER     0x00000002
+#define CODEC_CUSTOMIZE_VALUE_DROPFRAME    0x00000004
+#define CODEC_CUSTOMIZE_VALUE_MAX          0xffffffff
+
+
+typedef enum VDE_STATUS
+{
+    VDE_STATUS_IDLE                 = 0x1,   
+    VDE_STATUS_READY_TO_RUN,                // 当前instance已经执行run, 但vde被其他instance占用
+    VDE_STATUS_RUNING,                      // 正在运行
+    VDE_STATUS_GOTFRAME,                    // 有帧输出
+    VDE_STATUS_JPEG_SLICE_READY     = 0x100, // JPEG 解码一个slice完成, 此时不能被其他instance打断，直到GOTFRAME时才可以被打断
+    VDE_STATUS_DIRECTMV_FULL,               // h264 Direct mv buffer不够用,需要重新申请再启动解码    
+    VDE_STATUS_STREAM_EMPTY,                // 码流消耗完，需要继续配置数据再启动VDE, 5202不允许出现此情况     
+    VDE_STATUS_ASO_DETECTED,                // 检测到h264 ASO, 需要软件做墒解码再启动vde, 5202不允许出现此情况
+    VDE_STATUS_TIMEOUT              = -1,   // timeout
+    VDE_STATUS_STREAM_ERROR         = -2,   // 码流出错        
+    VDE_STATUS_BUS_ERROR            = -3,   // 访问ddr出错, 可能是因为配置的非物理连续内存
+    VDE_STATUS_DEAD                 = -4,   // vpx挂了，无法配置任何寄存器, video中间件需要关闭所有instance    
+    VDE_STATUS_UNKNOWN_ERROR        = -0x100       // 其他错误        
+} VDE_Status_t;
+
+
+typedef struct vde_handle 
+{    
+    // 读寄存器
+    unsigned int (*readReg)(struct vde_handle*, VDE_RegNO_t);
+    
+    // 写寄存器, 状态寄存器(reg1)由驱动统一管理, 不能写, 返回-1；
+    int (*writeReg)(struct vde_handle*, VDE_RegNO_t, const unsigned int);
+
+    // 启动解码, 返回-1，表示vde状态错误，不能启动;
+    int (*run)(struct vde_handle*);
+    
+    // 查询VDE状态，不阻塞版本，vde正在运行返回VDE_STATUS_RUNING
+    int (*query)(struct vde_handle*, VDE_Status_t*);    
+    
+    // 查询VDE状态, 阻塞版本, 直到VDE_STATUS_DEAD或者VDE中断产生, 返回值见VDE_Status_t
+    int (*query_timeout)(struct vde_handle*, VDE_Status_t*);    
+    
+    // 将状态转为idle
+    int (*reset)(struct vde_handle*);   
+    
+} vde_handle_t;
+
+// 获取句柄. 参数错误或者达到最大的运行instance个数，返回NULL;     
+vde_handle_t *vde_getHandle(void);
+
+// 关闭句柄    
+void vde_freeHandle(struct vde_handle*);
+
+// DEBUG, 打开内部打印
+void vde_enable_log(void);
+
+// DEBUG, 关闭内部打印
+void vde_disable_log(void);
+
+// DEBUG 获取当前运行的instance信息和所有寄存器信息, 单次有效
+void vde_dump_info(void);
+
+
+
+/**********************************************************
+设计流程:  vd_h264.so  ----> libvde_core.so ----> vde_drv.ko
+
+限制条件： 不能跨进程使用，即不同instance必须是在同一个进程中。
+
+使用方法：
+    Android.mk中增加 LOCAL_SHARED_LIBRARIES := libvde_core
+    编译时会自动连接libvde_core.so, 就可以自动加载so, 使用api函数, 不需要直接调用vde_drv.ko
+
+额外说明:  reg1(status寄存器）不能写
+
+Example code：
+
+    int vde_close(void *codec_handle)
+    {
+        // ...
+        vde_freeHandle(codec_handle->vde_handle);
+        codec_handle->vde_handle = NULL;
+        // ...        
+    }
+    
+    int vde_init(void *codec_handle)
+    {
+        codec_handle->vde_handle == vde_getHandle();
+        if(codec_handle->vde_handle == NULL) return -1;
+        
+        if(DEBUG)
+            vde_enable_log();           
+        
+        // if you need to know about overload of VDE;
+        vde_dump_info();
+                
+        return 0;
+    }
+    
+    int vde_decode_one_frame(void *codec_handle)
+    {
+        int rt;        
+        unsigned int value;
+        int status;
+        
+        vde_handle_t *vde = codec_handle->vde_handle;                
+                      
+        vde->reset(vde);      
+        
+        value = vde->readReg(vde, REG10);                
+        value &= 0x2;
+        
+        rt = vde->writeReg(vde, REG10, value);
+        if(rt) goto SOMETHING_WRONG;
+        
+        rt = vde->run(vde);
+        if(rt) goto SOMETHING_WRONG;          
+                        
+#if USE_QUERY 
+        // 死查，效率低    
+        while(timeout_ms < 10000)        
+            rt = vde->query(vde, &status);
+            if(rt) return -1;
+            
+            if(status != VDE_STATUS_RUNING && status != VDE_STATUS_IDLE) 
+                break;               
+        }
+#else                
+        // dosomthing else, 再来查，内部有任务调度，可提高cpu利用率
+        rt = vde->query_timeout(vde, &status);
+        if(rt) goto SOMETHING_WRONG;
+
+#endif
+        
+        if(status == VDE_STATUS_GOTFRAME) {                
+            return 0;
+        } else {
+            goto SOMETHING_WRONG;
+        }           
+           
+SOMETHING_WRONG:
+        
+        if(status == VDE_STATUS_DEAD) {
+            ACTAL_ERROR("VDE Died");            
+            return -1; //fatal error here.
+        } else {
+            ACTAL_ERROR("something wrong, check your code")
+            return -1;
+        }       
+                   
+    }
+
+**********************************************************/
+
+#endif//_VDE_CORE_H_
+
diff --git a/include/alsp/inc/vde_drv.h b/include/alsp/inc/vde_drv.h
new file mode 100755
index 0000000..bfb3396
--- /dev/null
+++ b/include/alsp/inc/vde_drv.h
@@ -0,0 +1,56 @@
+
+#if 0 // _GL5201_
+#include "vpx_drv.h"
+
+#define VDE_QUERY               VPX_QUERY
+#define VDE_ENABLE_CLK          VPX_ENABLE_CLK
+#define VDE_DISABLE_CLK         VPX_DISABLE_CLK
+#define VDE_RUN                 VPX_RUN
+#define VDE_REGISTER_BASE       0xb0310000
+
+#else
+
+
+
+//#define VDE_QUERY               0x00
+//#define VDE_ENABLE_CLK          0x01
+//#define VDE_DISABLE_CLK         0x02
+//#define VDE_RUN                 0x03
+//#define VDE_DUMP                0x04
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define VDE_MAGIC_NUMBER                'v'
+/******************************************************************************/
+
+#define VDE_QUERY                        _IOWR(VDE_MAGIC_NUMBER, 0xf0, unsigned long)
+
+#define VDE_ENABLE_CLK                   _IOWR(VDE_MAGIC_NUMBER, 0xf1, unsigned long)
+
+#define VDE_DISABLE_CLK                     _IOWR(VDE_MAGIC_NUMBER, 0xf2, unsigned long)
+
+#define VDE_RUN                     _IOWR(VDE_MAGIC_NUMBER, 0xf3, unsigned long)
+#define VDE_DUMP                    _IOWR(VDE_MAGIC_NUMBER, 0xf4,unsigned long)
+#define VDE_SET_FREQ                     _IOWR(VDE_MAGIC_NUMBER, 0xf5, unsigned long)
+#define VDE_GET_FREQ                    _IOWR(VDE_MAGIC_NUMBER, 0xf6,unsigned long)
+#define VDE_SET_MULTI                   _IOWR(VDE_MAGIC_NUMBER, 0xf7,unsigned long)
+
+
+
+// 20121020 : VDE Clk derived from DISPLAY_PLL, and DISPLAY_PLL is Set to 720M, VDE freq can be set at this levels
+// 20121105 : VDE Clk derived from DISPLAY_PLL, and DISPLAY_PLL is Set to 642M
+#define VDE_FREQ_DEFAULT 360
+#define VDE_FREQ_D1      180 //minimize 4 div
+#define VDE_FREQ_720P    240
+#define VDE_FREQ_1080P   360
+#define VDE_FREQ_MULTI   480
+#define VDE_FREQ_4Kx2K   540
+
+
+
+//#define VDE_REGISTER_BASE       0xb0270000
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/alsp/inc/venc_common.h b/include/alsp/inc/venc_common.h
new file mode 100755
index 0000000..0c411a7
--- /dev/null
+++ b/include/alsp/inc/venc_common.h
@@ -0,0 +1,31 @@
+#ifndef __VENC_COMMON_H__
+#define __VENC_COMMON_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+
+#include "./common/al_libc.h"
+#include "./common/stream_input.h"
+
+typedef enum{
+  DISK_WRITE = 0x0,
+  DISK_READ,
+  DISK_RW,
+}disk_flag_t;
+
+stream_input_t* filestream_init(int cache_size);
+int filestream_dispose(stream_input_t *stream_manage); 
+
+int stream_open_file(stream_input_t *stream_manage,FILE *file_handle,char *file_name,int use_size,int rw_flag);
+int stream_close_file(stream_input_t *stream_manage); 
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __VENC_COMMON_H__
\ No newline at end of file
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index e17bbbe..81987fc 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -57,7 +57,7 @@ enum player_type {
 };
 
 
-#define DEFAULT_AUDIOSINK_BUFFERCOUNT 4
+#define DEFAULT_AUDIOSINK_BUFFERCOUNT 12
 #define DEFAULT_AUDIOSINK_BUFFERSIZE 1200
 #define DEFAULT_AUDIOSINK_SAMPLERATE 44100
 
diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index 9ea3449..5bb1903 100755
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -469,6 +469,8 @@ private:
     static AudioEncoderCap* createDefaultAacEncoderCap();
     static AudioEncoderCap* createDefaultLpcmEncoderCap();
 #endif
+    static AudioEncoderCap* createDefaultAACEncoderCap();//action audio inside
+    static AudioEncoderCap* createDefaultMP3EncoderCap();//action audio inside
 
     static int findTagForName(const NameToTagMap *map, size_t nMappings, const char *name);
 
diff --git a/include/media/mediaplayer.h b/include/media/mediaplayer.h
index d753eba..5e30725 100644
--- a/include/media/mediaplayer.h
+++ b/include/media/mediaplayer.h
@@ -45,6 +45,9 @@ enum media_event_type {
     MEDIA_TIMED_TEXT        = 99,
     MEDIA_ERROR             = 100,
     MEDIA_INFO              = 200,
+    MEDIA_SUB               = 300,
+    MEDIA_REDIRECT          = 400,
+    MEDIA_REDIRECT_NUPLAYER = 700,
 };
 
 // Generic error codes for the media player framework.  Errors are fatal, the
diff --git a/include/media/mediarecorder.h b/include/media/mediarecorder.h
index 6dfa5d9..16f2acd 100644
--- a/include/media/mediarecorder.h
+++ b/include/media/mediarecorder.h
@@ -74,6 +74,10 @@ enum output_format {
     OUTPUT_FORMAT_WAVE = 11, /*WAVE*/
 #endif
 
+    OUTPUT_FORMAT_WAV = 12,
+    OUTPUT_FORMAT_MP3 = 13,    
+    OUTPUT_FORMAT_WMA = 14,
+
     OUTPUT_FORMAT_LIST_END // must be last - used to validate format type
 };
 
@@ -89,6 +93,10 @@ enum audio_encoder {
     AUDIO_ENCODER_QCELP = 7,
     AUDIO_ENCODER_LPCM = 8,
 #endif
+    AUDIO_ENCODER_PCM = 6,
+    AUDIO_ENCODER_ADPCM = 7,
+    AUDIO_ENCODER_MP3 = 8,    
+    AUDIO_ENCODER_WMA = 9,
 
     AUDIO_ENCODER_LIST_END // must be the last - used to validate the audio encoder type
 };
@@ -173,6 +181,9 @@ enum media_recorder_info_type {
 
     MEDIA_RECORDER_INFO_MAX_DURATION_REACHED      = 800,
     MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED      = 801,
+    MEDIA_RECORDER_INFO_COMPLETION_STATUS         = 802,
+    MEDIA_RECORDER_INFO_PROGRESS_FRAME_STATUS     = 803,
+    MEDIA_RECORDER_INFO_PROGRESS_TIME_STATUS      = 804,
 
     // All track related informtional events start here
     MEDIA_RECORDER_TRACK_INFO_LIST_START           = 1000,
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 08601aa..7552214 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -189,6 +189,8 @@ private:
 
     bool mChannelMaskPresent;
     int32_t mChannelMask;
+    int32_t video_display_w;
+    int32_t video_display_h;
 
     status_t setCyclicIntraMacroblockRefresh(const sp<AMessage> &msg, int32_t mode);
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
@@ -281,6 +283,11 @@ private:
     status_t requestIDRFrame();
 
     DISALLOW_EVIL_CONSTRUCTORS(ACodec);
+    
+    sp<ABuffer> special_data;
+    int special_data_cpy_flag;
+    int mpeg4_special_data_flag;
+    bool mIsCodecNeedFlush;
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/ActAudioWriter.h b/include/media/stagefright/ActAudioWriter.h
new file mode 100755
index 0000000..79b9723
--- /dev/null
+++ b/include/media/stagefright/ActAudioWriter.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ACTAUDIO_WRITER_H_
+
+#define ACTAUDIO_WRITER_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/MediaWriter.h>
+#include <utils/threads.h>
+
+namespace android {
+
+struct MediaSource;
+struct MetaData;
+
+struct ActAudioWriter : public MediaWriter {
+    ActAudioWriter(const char *filename);
+    ActAudioWriter(int fd);
+
+    status_t initCheck() const;
+
+    virtual status_t addSource(const sp<MediaSource> &source);
+    virtual bool reachedEOS();
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual status_t pause();
+
+protected:
+    virtual ~ActAudioWriter();
+
+private:
+    FILE *mFile;
+    status_t mInitCheck;
+    sp<MediaSource> mSource;
+    sp<MetaData> mMeta;
+    bool mStarted;
+    volatile bool mPaused;
+    volatile bool mResumed;
+    volatile bool mDone;
+    volatile bool mReachedEOS;
+    pthread_t mThread;
+    int64_t mEstimatedSizeBytes;
+    int64_t mEstimatedDurationUs;
+
+    static void *ThreadWrapper(void *);
+    status_t threadFunc();
+    bool exceedsFileSizeLimit();
+    bool exceedsFileDurationLimit();
+
+    ActAudioWriter(const ActAudioWriter &);
+    ActAudioWriter &operator=(const ActAudioWriter &);
+};
+
+}  // namespace android
+
+#endif  // ActAudio_WRITER_H_
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index 624fe3e..5f03c6d 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -94,6 +94,7 @@ private:
 #ifdef QCOM_HARDWARE
     bool mSourcePaused;
 #endif
+    bool mPause;
 
     bool mIsFirstBuffer;
     status_t mFirstBufferResult;
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 00d583e..2d110cb 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -51,6 +51,9 @@ public:
     virtual status_t initCheck() const = 0;
 
     virtual ssize_t readAt(off64_t offset, void *data, size_t size) = 0;
+    virtual ssize_t readAt64(off64_t offset, void *data, size_t size) {
+       return readAt((off_t)offset, data, size);
+    }
 
     // Convenience methods:
     bool getUInt16(off64_t offset, uint16_t *x);
diff --git a/include/media/stagefright/MediaCodecList.h b/include/media/stagefright/MediaCodecList.h
index 8f2b624..6c31083 100644
--- a/include/media/stagefright/MediaCodecList.h
+++ b/include/media/stagefright/MediaCodecList.h
@@ -64,7 +64,7 @@ private:
     struct CodecInfo {
         AString mName;
         bool mIsEncoder;
-        uint32_t mTypes;
+        uint64_t mTypes;
         uint32_t mQuirks;
     };
 
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index db8d89e..9ae1858 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -79,6 +79,39 @@ extern const char *MEDIA_MIMETYPE_VIDEO_DIVX4;
 extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
 #endif
 
+/*---Action video inside---- */
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIV3;
+extern const char *MEDIA_MIMETYPE_VIDEO_FLV1;
+extern const char *MEDIA_MIMETYPE_VIDEO_RV;
+extern const char *MEDIA_MIMETYPE_VIDEO_AVS;
+extern const char *MEDIA_MIMETYPE_VIDEO_MJPG;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV8;
+extern const char *MEDIA_MIMETYPE_VIDEO_RVG2;
+extern const char *MEDIA_MIMETYPE_VIDEO_VP8;
+extern const char *MEDIA_MIMETYPE_VIDEO_VP6;
+
+/*******************************Actions audio inside*********************************/
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_AAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_MP3;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_WMASTD;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_WMALSL;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_WMAPRO;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_COOK;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_PCM;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_OGG;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_DTS;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_AC3;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_APE;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_FLAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_ACELP;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_MPC;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_AIFF;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_AMR;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_SAMPLE;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_ALAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_ACT_AWB;
+
 }  // namespace android
 
 #endif  // MEDIA_DEFS_H_
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index bb01467..4f8868c 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -41,6 +41,9 @@ enum {
     INFO_FORMAT_CHANGED    = MEDIA_ERROR_BASE - 12,
     INFO_DISCONTINUITY     = MEDIA_ERROR_BASE - 13,
     INFO_OUTPUT_BUFFERS_CHANGED = MEDIA_ERROR_BASE - 14,
+    // used when only has audio not has video in some time,action inside
+    INFO_NO_RAW_DATA_NOW    = MEDIA_ERROR_BASE - 15,
+    ERROR_READ_TIME_OUT_SP  = MEDIA_ERROR_BASE - 16,
 
     // The following constant values should be in sync with
     // drm/drm_framework_common.h
diff --git a/include/media/stagefright/MediaExtractor.h b/include/media/stagefright/MediaExtractor.h
index a458284..f35c99f 100644
--- a/include/media/stagefright/MediaExtractor.h
+++ b/include/media/stagefright/MediaExtractor.h
@@ -20,6 +20,7 @@
 #define MEDIA_EXTRACTOR_H_
 
 #include <utils/RefBase.h>
+#include <utils/Errors.h>
 
 namespace android {
 
@@ -30,7 +31,7 @@ class MetaData;
 class MediaExtractor : public RefBase {
 public:
     static sp<MediaExtractor> Create(
-            const sp<DataSource> &source, const char *mime = NULL);
+            const sp<DataSource> &source, const char *mime = NULL,void* cookie=NULL);
 
     virtual size_t countTracks() = 0;
     virtual sp<MediaSource> getTrack(size_t index) = 0;
@@ -44,6 +45,7 @@ public:
     // Return container specific meta-data. The default implementation
     // returns an empty metadata object.
     virtual sp<MetaData> getMetaData();
+    virtual status_t setAudioTrack(int index, int64_t cur_playing_time) { return NO_ERROR; }
 
     enum Flags {
         CAN_SEEK_BACKWARD  = 1,  // the "seek 10secs back button"
@@ -64,16 +66,25 @@ public:
     bool getDrmFlag() {
         return mIsDrm;
     }
+
+	virtual void setUsingMidwwareFlag(bool usingMidwareFlag) {
+        mIsMidware = usingMidwareFlag;
+    };
+    virtual bool getUsingMidwwareFlag() {
+        return mIsMidware;
+    }
+		
     virtual char* getDrmTrackInfo(size_t trackID, int *len) {
         return NULL;
     }
 
 protected:
-    MediaExtractor() {}
+    MediaExtractor() : mIsDrm(false) {}
     virtual ~MediaExtractor() {}
 
 private:
     bool mIsDrm;
+    bool mIsMidware;
 
     MediaExtractor(const MediaExtractor &);
     MediaExtractor &operator=(const MediaExtractor &);
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index e91904c..39946a5 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -155,6 +155,15 @@ enum {
     kKeyCryptoKey         = 'cryK',  // uint8_t[16]
     kKeyCryptoIV          = 'cryI',  // uint8_t[16]
     kKeyCryptoMode        = 'cryM',  // int32_t
+	// Actions Extrator's media info structure
+    kKeyActMediaInfo     = 'actm',  // pointer to media_info_t
+    kKeyActVDPrv         = 'actv',  // private data for video codecs
+    kKeyActFrmRate     = 'afps',  // frame rate  for video codecs int64_t
+    kKeyActMusicInfo     = 'acta',  // pointer to audio_info_t
+    kKeyActCreateThumbnail   =  'acct',
+    kKeyActNuSeekedListTimeBase = 'nstb',
+    kKeyActMaxSegDuration				='amsd',
+    kKeyActStreamingFlag = 'acsf' 
 };
 
 enum {
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index 630f5af..51a085b 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -235,6 +235,11 @@ private:
 
     bool mPaused;
 
+    /*-----action inside-----*/
+    int32_t mIsStreamingFlag;
+    int64_t mKBufferFilledEventTimeOutNs;
+    int IS_THUMBNAIL;
+
     sp<ANativeWindow> mNativeWindow;
 
     // The index in each of the mPortBuffers arrays of the buffer that will be
diff --git a/libvideoeditor/vss/stagefrightshells/src/VideoEditor3gpReader.cpp b/libvideoeditor/vss/stagefrightshells/src/VideoEditor3gpReader.cpp
index f735c0b..f34c178 100755
--- a/libvideoeditor/vss/stagefrightshells/src/VideoEditor3gpReader.cpp
+++ b/libvideoeditor/vss/stagefrightshells/src/VideoEditor3gpReader.cpp
@@ -1589,6 +1589,15 @@ M4OSA_ERR VideoEditor3gpReader_getNextStreamHandler(M4OSA_Context context,
                             DecoderSpecificInfo = M4OSA_NULL;
                         }
                     }
+                    else{
+                    	(*pStreamHandler)->m_pDecoderSpecificInfo = M4OSA_NULL;
+                        (*pStreamHandler)->m_decoderSpecificInfoSize = 0;
+                        (*pStreamHandler)->m_H264decoderSpecificInfoSize = 0;
+                        (*pStreamHandler)->m_pH264DecoderSpecificInfo =
+                            M4OSA_NULL;
+                        (*pStreamHandler)->m_pESDSInfo = M4OSA_NULL;
+                        (*pStreamHandler)->m_ESDSInfoSize = 0;
+                    }
                     (*pStreamHandler)->m_pESDSInfo = M4OSA_NULL;
                     (*pStreamHandler)->m_ESDSInfoSize = 0;
 
diff --git a/media/libmedia/IMediaMetadataRetriever.cpp b/media/libmedia/IMediaMetadataRetriever.cpp
index 7e6d54b..bb066a0 100644
--- a/media/libmedia/IMediaMetadataRetriever.cpp
+++ b/media/libmedia/IMediaMetadataRetriever.cpp
@@ -20,6 +20,7 @@
 #include <binder/Parcel.h>
 #include <media/IMediaMetadataRetriever.h>
 #include <utils/String8.h>
+#include <utils/KeyedVector.h>
 
 // The binder is supposed to propagate the scheduler group across
 // the binder interface so that remote calls are executed with
@@ -161,8 +162,22 @@ public:
         if (ret != NO_ERROR) {
             return NULL;
         }
-        return reply.readCString();
+        const char* str = reply.readCString();
+        if (str != NULL) {
+            String8 value(str);
+            if (mMetadata.indexOfKey(keyCode) < 0) {
+                mMetadata.add(keyCode, value);
+            } else {
+                mMetadata.replaceValueFor(keyCode, value);
+            }
+            return mMetadata.valueFor(keyCode).string();
+        } else {
+            return NULL;
+        }
     }
+
+private:
+    KeyedVector<int, String8> mMetadata;
 };
 
 IMPLEMENT_META_INTERFACE(MediaMetadataRetriever, "android.media.IMediaMetadataRetriever");
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index e1299c2..5be8eff 100755
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -47,6 +47,7 @@ const MediaProfiles::NameToTagMap MediaProfiles::sAudioEncoderNameMap[] = {
     {"aac",    AUDIO_ENCODER_AAC},
     {"heaac",  AUDIO_ENCODER_HE_AAC},
     {"aaceld", AUDIO_ENCODER_AAC_ELD},
+    {"mp3",    AUDIO_ENCODER_MP3},
 #ifdef QCOM_HARDWARE
     {"lpcm",  AUDIO_ENCODER_LPCM},
 #endif
@@ -812,6 +813,8 @@ MediaProfiles::createDefaultCamcorderProfiles(MediaProfiles *profiles)
 MediaProfiles::createDefaultAudioEncoders(MediaProfiles *profiles)
 {
     profiles->mAudioEncoders.add(createDefaultAmrNBEncoderCap());
+    profiles->mAudioEncoders.add(createDefaultAACEncoderCap());
+    profiles->mAudioEncoders.add(createDefaultMP3EncoderCap());
 #ifdef QCOM_HARDWARE
     profiles->mAudioEncoders.add(createDefaultAacEncoderCap());
     profiles->mAudioEncoders.add(createDefaultLpcmEncoderCap());
@@ -850,6 +853,21 @@ MediaProfiles::createDefaultAmrNBEncoderCap()
         AUDIO_ENCODER_AMR_NB, 5525, 12200, 8000, 8000, 1, 1);
 }
 
+/*static*/ MediaProfiles::AudioEncoderCap*
+MediaProfiles::createDefaultAACEncoderCap()
+{    
+    //ALOGE("===cz========createDefaultAACEncoderCap");
+    return new MediaProfiles::AudioEncoderCap(
+        AUDIO_ENCODER_AAC, 5525, 73200, 8000, 48000, 1, 2);
+}
+/*static*/ MediaProfiles::AudioEncoderCap*
+MediaProfiles::createDefaultMP3EncoderCap()
+{   
+    //ALOGE("===cz========createDefaultMP3EncoderCap");
+    return new MediaProfiles::AudioEncoderCap(
+        AUDIO_ENCODER_MP3, 5525, 73200, 8000, 48000, 1, 2);
+}
+
 #ifdef QCOM_HARDWARE
 /*static*/ MediaProfiles::AudioEncoderCap*
 MediaProfiles::createDefaultAacEncoderCap()
diff --git a/media/libmedia/MediaScannerClient.cpp b/media/libmedia/MediaScannerClient.cpp
index e1e3348..3acd369 100644
--- a/media/libmedia/MediaScannerClient.cpp
+++ b/media/libmedia/MediaScannerClient.cpp
@@ -27,7 +27,7 @@ namespace android {
 MediaScannerClient::MediaScannerClient()
     :   mNames(NULL),
         mValues(NULL),
-        mLocaleEncoding(kEncodingNone)
+        mLocaleEncoding(kEncodingGBK)
 {
 }
 
@@ -99,28 +99,114 @@ static uint32_t possibleEncodings(const char* s)
     // so we need to reverse the latin-1 -> utf8 conversion to get the native chars back
     uint8_t ch1, ch2;
     uint8_t* chp = (uint8_t *)s;
+    ALOGV("possibleEncodings first TO sixth: %02x %02x %02x %02x %02x %02x", chp[0],chp[1], chp[2],chp[3], chp[4],chp[5]);
 
     while ((ch1 = *chp++)) {
         if (ch1 & 0x80) {
+            /*
             ch2 = *chp++;
             ch1 = ((ch1 << 6) & 0xC0) | (ch2 & 0x3F);
             // ch1 is now the first byte of the potential native char
 
+            */
             ch2 = *chp++;
-            if (ch2 & 0x80)
-                ch2 = ((ch2 << 6) & 0xC0) | (*chp++ & 0x3F);
+            /*if (ch2 & 0x80)
+                ch2 = ((ch2 << 6) & 0xC0) | (*chp++ & 0x3F);*/
             // ch2 is now the second byte of the potential native char
             int ch = (int)ch1 << 8 | (int)ch2;
+            ALOGV("possibleEncodings src: %02x", ch);
             result &= findPossibleEncodings(ch);
         }
         // else ASCII character, which could be anything
     }
-
+    ALOGV("possibleEncodings result: %d", result);
     return result;
 }
 
 void MediaScannerClient::convertValues(uint32_t encoding)
 {
+    const char* enc = "gbk";
+    
+    switch (encoding) {
+        case kEncodingShiftJIS:
+            enc = "shift-jis";
+            break;
+        case kEncodingGBK:
+            enc = "gbk";
+            break;
+        case kEncodingBig5:
+            enc = "Big5";
+            break;
+        case kEncodingEUCKR:
+            enc = "EUC-KR";
+            break;
+    }
+    
+
+    if (enc) {
+        UErrorCode status = U_ZERO_ERROR;
+
+        UConverter *conv = ucnv_open(enc, &status);
+        if (U_FAILURE(status)) {
+            ALOGE("could not create UConverter for %s", enc);
+            return;
+        }
+        UConverter *utf8Conv = ucnv_open("UTF-8", &status);
+        if (U_FAILURE(status)) {
+            ALOGE("could not create UConverter for UTF-8");
+            ucnv_close(conv);
+            return;
+        }
+        // for each value string, convert from native encoding to UTF-8
+        for (int i = 0; i < mNames->size(); i++) 
+        {
+            uint8_t* src    = (uint8_t *)mValues->getEntry(i);
+            int len         = strlen((char *)src);
+            uint8_t* dest   = src + len;
+            
+            ALOGV("convertValues (%s)(%s): %d, %d\n", mNames->getEntry(i),src, src[0]==0xcf ? 0:1, src[1] == 0xcf ? 0:1);                        
+            if ((src[0] == 0xcf) && (src[1] == 0xcf))        
+            {
+                // now convert from native encoding to UTF-8
+                //const char* source  = mValues->getEntry(i);
+                int targetLength    = len * 3 + 1;
+                char* buffer        = new char[targetLength];                
+                
+                if (!buffer)
+                {
+                    break;
+                }
+                
+                src += 2;
+                char* target = buffer;
+    
+                ucnv_convertEx(utf8Conv, conv, &target, target + targetLength,
+                        (const char **)&src, (const char *)dest, NULL, NULL, NULL, NULL, TRUE, TRUE, &status);
+                if (U_FAILURE(status)) 
+                {
+                    ALOGE("ucnv_convertEx failed: %d, (%s)=(%s)\n", status, mNames->getEntry(i), src);
+                    mValues->setEntry(i, "???");
+                } 
+                else 
+                {
+                    // zero terminate
+                    *target = 0;
+                    ALOGV("convertValues (%s) = (%s)\n",src, buffer);
+                    mValues->setEntry(i, buffer);
+                }
+    
+                delete[] buffer;
+            }
+            else
+            {
+                ALOGD("noconvert (%s): (%s),len=%d  \n", mNames->getEntry(i), mValues->getEntry(i), len);
+            }                
+        }  
+        ucnv_close(conv);
+        ucnv_close(utf8Conv);
+    }
+   
+    /*
     const char* enc = NULL;
     switch (encoding) {
         case kEncodingShiftJIS:
@@ -195,20 +281,120 @@ void MediaScannerClient::convertValues(uint32_t encoding)
         ucnv_close(conv);
         ucnv_close(utf8Conv);
     }
+    */
 }
 
 void MediaScannerClient::endFile()
 {
+    /*convertValues(mLocaleEncoding);
+    for (int i = 0; i < mNames->size(); i++) 
+    {
+        //ALOGD("handleStringTag (%s)=(%s)\n",mNames->getEntry(i), mValues->getEntry(i) );
+        status_t status = handleStringTag(mNames->getEntry(i), mValues->getEntry(i));
+        if (status) {
+            ALOGD("handleStringTag break:status(%d)\n",status);
+            break;
+        }
+    }
+    delete mNames;
+    delete mValues;
+    mNames = NULL;
+    mValues = NULL;
+    */
     if (mLocaleEncoding != kEncodingNone) {
         int size = mNames->size();
         uint32_t encoding = kEncodingAll;
 
         // compute a bit mask containing all possible encodings
-        for (int i = 0; i < mNames->size(); i++)
-            encoding &= possibleEncodings(mValues->getEntry(i));
-
+        for (int i = 0; i < mNames->size(); i++){
+            const char* str = mValues->getEntry(i);
+            ALOGE( "mValues: %02x %02x %02x %02x ",mValues->getEntry(i)[0],
+                                                   mValues->getEntry(i)[1],
+                                                   mValues->getEntry(i)[2],
+                                                   mValues->getEntry(i)[3]);
+            if ((str[0] == 0xcf) && (str[1] == 0xcf)) 
+            {
+               str++;
+               str++;               
+            }
+            encoding &= possibleEncodings(str);
+         }
+         ALOGE( "possibleEncodings %d",encoding );
         // if the locale encoding matches, then assume we have a native encoding.
-        if (encoding & mLocaleEncoding)
+        //if (encoding & mLocaleEncoding)
+        uint32_t enc = mLocaleEncoding;
+        switch (mLocaleEncoding) {
+            case kEncodingGBK:
+                if(encoding & kEncodingGBK){
+                   enc = kEncodingGBK;                   
+                }else if(encoding & kEncodingBig5){
+                   enc = kEncodingBig5;                   
+                }else if(encoding & kEncodingShiftJIS){
+                   enc = kEncodingShiftJIS;                   
+                }else if(encoding & kEncodingEUCKR){
+                   enc = kEncodingEUCKR;                  
+                }
+                if((encoding & kEncodingBig5)&&(encoding & kEncodingEUCKR)){
+                   enc = kEncodingBig5;
+                }
+                break;
+            case kEncodingBig5:
+                if(encoding & kEncodingBig5){
+                   enc = kEncodingBig5;                   
+                }else if(encoding & kEncodingGBK){
+                   enc = kEncodingGBK;                   
+                }else if(encoding & kEncodingShiftJIS){
+                   enc = kEncodingShiftJIS;                   
+                }else if(encoding & kEncodingEUCKR){
+                   enc = kEncodingEUCKR;                 
+                }
+                break;
+            case kEncodingShiftJIS:
+                if(encoding & kEncodingShiftJIS){
+                   enc = kEncodingShiftJIS;                                   
+                }else if(encoding & kEncodingGBK){
+                   enc = kEncodingGBK;                  
+                }else if(encoding & kEncodingBig5){
+                   enc = kEncodingBig5;
+                }else if(encoding & kEncodingEUCKR){
+                   enc = kEncodingEUCKR;                  
+                }
+                break;
+            case kEncodingEUCKR:
+                if(encoding & kEncodingEUCKR){
+                   enc = kEncodingEUCKR;                   
+                }else if(encoding & kEncodingShiftJIS){
+                   enc = kEncodingShiftJIS;                   
+                }else if(encoding & kEncodingBig5){
+                   enc = kEncodingBig5;                   
+                }else if(encoding & kEncodingGBK){
+                   enc = kEncodingGBK;                  
+                }
+                break;            
+        }        
+        
+        if(encoding & kEncodingGB2312){
+            enc = kEncodingGBK;
+        }
+        switch (encoding) {
+            case kEncodingShiftJIS:
+                enc = kEncodingShiftJIS;
+                break;
+            case kEncodingGBK:
+                enc = kEncodingGBK;
+                break;
+            case kEncodingBig5:
+                enc = kEncodingBig5;
+                break;
+            case kEncodingEUCKR:
+                enc = kEncodingEUCKR;
+                break;
+            case kEncodingGB2312:
+                enc = kEncodingGBK;
+                break;
+        }
+        mLocaleEncoding=enc;
+        ALOGE( "mLocaleEncoding final %d",mLocaleEncoding );
             convertValues(mLocaleEncoding);
 
         // finally, push all name/value pairs to the client
diff --git a/media/libmedia/autodetect.cpp b/media/libmedia/autodetect.cpp
index be5c3b2..93b7931 100644
--- a/media/libmedia/autodetect.cpp
+++ b/media/libmedia/autodetect.cpp
@@ -15,6 +15,7 @@
  */
 
 #include "autodetect.h"
+#include <utils/Log.h>
 
 struct CharRange {
     uint16_t first;
@@ -846,6 +847,82 @@ static const CharRange kBig5Ranges[] = {
     { 0xF9A1, 0xF9FE },
 };
 
+static const CharRange kGB2312Ranges[] = { 
+    //JAPANESE AND SO on
+    { 0xA4A1, 0xA4F4 },
+    { 0xA5A1, 0xA5F7 },
+    { 0xA8C4, 0xA8EA },
+    //CHINESE 
+    { 0xB0A1, 0xB0FE },    
+    { 0xB1A1, 0xB1FE },
+    { 0xB2A1, 0xB2FE },
+    { 0xB3A1, 0xB3FE },
+    { 0xB4A1, 0xB4FE },    
+    { 0xB5A1, 0xB5FE },
+    { 0xB6A1, 0xB6FE },
+    { 0xB7A1, 0xB7FE },
+    { 0xB8A1, 0xB8FE },
+    { 0xB9A1, 0xB9FE },
+    { 0xBAA1, 0xBAFE },
+    { 0xBBA1, 0xBBFE },
+    { 0xBCA1, 0xBCFE },
+    { 0xBDA1, 0xBDFE },
+    { 0xBEA1, 0xBEFE },
+    { 0xBFA1, 0xBFFE },
+    { 0xC0A1, 0xC0FE },
+    { 0xC1A1, 0xC1FE },
+    { 0xC2A1, 0xC2FE },
+    { 0xC3A1, 0xC3FE },
+    { 0xC4A1, 0xC4FE },
+    { 0xC5A1, 0xC5FE },
+    { 0xC9A1, 0xC9FE },
+    { 0xCAA1, 0xCAFE },
+    { 0xCBA1, 0xCBFE },
+    { 0xCCA1, 0xCCFE },
+    { 0xCDA1, 0xCDFE },
+    { 0xCEA1, 0xCEFE },
+    { 0xCFA1, 0xCFFE },
+    { 0xD0A1, 0xD0FE },
+    { 0xD1A1, 0xD1FE },
+    { 0xD2A1, 0xD2FE },
+    { 0xD3A1, 0xD3FE },
+    { 0xD4A1, 0xD4FE },
+    { 0xD5A1, 0xD5FE },
+    { 0xD6A1, 0xD6FE },   
+    { 0xD7A1, 0xD7FE },
+    { 0xD8A1, 0xD8FE },
+    { 0xD9A1, 0xD9FE },
+    { 0xDAA1, 0xDAFE },
+    { 0xDBA1, 0xDBFE },
+    { 0xDCA1, 0xDCFE },
+    { 0xDDA1, 0xDDFE },
+    { 0xDEA1, 0xDEFE },
+    { 0xDFA1, 0xDFFE },
+    { 0xE0A1, 0xE0FE },
+    { 0xE1A1, 0xE1FE },
+    { 0xE2A1, 0xE2FE },
+    { 0xE3A1, 0xE3FE },
+    { 0xE4A1, 0xE4FE },
+    { 0xE5A1, 0xE5FE },
+    { 0xE6A1, 0xE6FE },
+    { 0xE7A1, 0xE7FE },
+    { 0xE8A1, 0xE8FE },
+    { 0xE9A1, 0xE9FE },
+    { 0xEAA1, 0xEAFE },
+    { 0xEBA1, 0xEBFE },
+    { 0xECA1, 0xECFE },
+    { 0xEDA1, 0xEDFE },
+    { 0xEEA1, 0xEEFE },
+    { 0xEFA1, 0xEFFE },
+    { 0xF0A1, 0xF0FE },
+    { 0xF1A1, 0xF1FE },
+    { 0xF2A1, 0xF2FE },
+    { 0xF3A1, 0xF3FE },
+    { 0xF4A1, 0xF4FE },
+    { 0xF5A1, 0xF5FE },
+    { 0xF6A1, 0xF6FE },
+    { 0xF7A1, 0xF7FE },    
+};
 static bool charMatchesEncoding(int ch, const CharRange* encodingRanges, int rangeCount) {
     // Use binary search to see if the character is contained in the encoding
     int low = 0;
@@ -880,6 +957,8 @@ extern uint32_t findPossibleEncodings(int ch)
         result |= kEncodingBig5;
     if (charMatchesEncoding(ch, kEUCKRRanges, ARRAY_SIZE(kEUCKRRanges)))
         result |= kEncodingEUCKR;
-
+    if (charMatchesEncoding(ch, kGB2312Ranges, ARRAY_SIZE(kGB2312Ranges))){        
+        result |= kEncodingGB2312;        
+     }
     return result;
 }
diff --git a/media/libmedia/autodetect.h b/media/libmedia/autodetect.h
index 9675db3..bfad8ff 100644
--- a/media/libmedia/autodetect.h
+++ b/media/libmedia/autodetect.h
@@ -26,8 +26,9 @@ enum {
     kEncodingGBK                = (1 << 1),
     kEncodingBig5               = (1 << 2),
     kEncodingEUCKR              = (1 << 3),
+    kEncodingGB2312             = (1 << 4),
 
-    kEncodingAll                = (kEncodingShiftJIS | kEncodingGBK | kEncodingBig5 | kEncodingEUCKR),
+    kEncodingAll                = (kEncodingShiftJIS | kEncodingGBK | kEncodingBig5 | kEncodingEUCKR | kEncodingGB2312),
 };
 
 
diff --git a/media/libmedia/mediaplayer.cpp b/media/libmedia/mediaplayer.cpp
index 6073756..ec9b875 100644
--- a/media/libmedia/mediaplayer.cpp
+++ b/media/libmedia/mediaplayer.cpp
@@ -430,7 +430,7 @@ status_t MediaPlayer::seekTo_l(int msec)
             return err;
         }
 
-        if (msec > durationMs) {
+        if ((durationMs > 0) && (msec > durationMs)) {
             ALOGW("Attempt to seek to past end of file: request = %d, "
                   "durationMs = %d",
                   msec,
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 1683db2..ef9f75b 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -50,7 +50,9 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/av/media/libstagefright/rtsp                  \
     $(TOP)/frameworks/av/media/libstagefright/wifi-display          \
     $(TOP)/frameworks/native/include/media/openmax                  \
-    $(TOP)/external/tremolo/Tremolo
+    $(TOP)/external/tremolo/Tremolo                                 \
+    $(TOP)/frameworks/av/include/alsp/inc                           \
+    $(TOP)/frameworks/av/include/alsp/inc/common
 
 ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
     ifeq ($(TARGET_QCOM_MEDIA_VARIANT),caf)
diff --git a/media/libmediaplayerservice/MediaPlayerFactory.cpp b/media/libmediaplayerservice/MediaPlayerFactory.cpp
index ac6decd..94d4743 100644
--- a/media/libmediaplayerservice/MediaPlayerFactory.cpp
+++ b/media/libmediaplayerservice/MediaPlayerFactory.cpp
@@ -213,8 +213,17 @@ class NuPlayerFactory : public MediaPlayerFactory::IFactory {
                 return kOurScore;
             }
 
+            if (strstr(url,".m3u")) {
+                    return kOurScore;
+                }
+            
+            
             if (strstr(url,"m3u8")) {
-                return kOurScore;
+                  if (strstr(url,"/m3u8/")) {
+                      return 0.0;
+                  }else {
+                      return kOurScore;
+                  }
             }
         }
 
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 5b88f5f..24795b6 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -501,6 +501,7 @@ MediaPlayerService::Client::Client(
     mAudioSessionId = audioSessionId;
     mUID = uid;
     mRetransmitEndpointValid = false;
+    mPlayerType = STAGEFRIGHT_PLAYER;
 
 #if CALLBACK_ANTAGONIZER
     ALOGD("create Antagonizer");
@@ -641,6 +642,10 @@ status_t MediaPlayerService::Client::setDataSource(
         return mStatus;
     } else {
         player_type playerType = MediaPlayerFactory::getPlayerType(this, url);
+        // create the right type of player
+        if (playerType != NU_PLAYER) {
+            playerType = (mPlayerType == NU_PLAYER) ? NU_PLAYER : playerType;
+        }
         sp<MediaPlayerBase> p = setDataSource_pre(playerType);
         if (p == NULL) {
             return NO_INIT;
@@ -736,6 +741,13 @@ status_t MediaPlayerService::Client::setVideoSurfaceTexture(
         anw = new SurfaceTextureClient(surfaceTexture);
         status_t err = native_window_api_connect(anw.get(),
                 NATIVE_WINDOW_API_MEDIA);
+        
+        if (err != OK) {
+            ALOGE("setVideoSurfaceTexture failed 1, retrying");
+            usleep(1*1000*1000);
+            err = native_window_api_connect(anw.get(),
+                                            NATIVE_WINDOW_API_MEDIA);
+        }
 
         if (err != OK) {
             ALOGE("setVideoSurfaceTexture failed: %d", err);
@@ -1086,6 +1098,53 @@ void MediaPlayerService::Client::notify(
             client->mNextClient->mClient->notify(MEDIA_INFO, MEDIA_INFO_STARTED_AS_NEXT, 0, obj);
         }
     }
+    
+    if (msg == MEDIA_REDIRECT) {  
+        char * uri  = (char *)malloc(ext2);
+        if (uri != NULL) {
+            ALOGI("notify: malloc %d uri OK", ext2);
+            memset(uri, 0, ext2);
+            strncpy(uri, (char *)ext1, ext2);
+        } else {
+            ALOGE("notify: malloc new uri failed when redirect palyer");
+        }
+        
+        ALOGI("notify: New Url  len: %d uri: %s", ext2, uri);                   
+        player_type playerType = MediaPlayerFactory::getPlayerType(client, uri);
+        if (client->mPlayer->playerType() == playerType) {
+            ALOGI("notify: processing redirect case and meet the same player type as before, and len: %d", ext2);
+            client->mClient->notify(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, ERROR_IO, obj);
+        } else {         
+            client->setDataSource(uri, NULL);       
+            client->prepareAsync();
+        } 
+
+        if (uri) {
+            free(uri);
+            uri = NULL;
+            ALOGI("notify: free uri OK");
+        }
+    } else if (msg == MEDIA_REDIRECT_NUPLAYER) {
+        char * uri  = (char *)malloc(ext2);
+        if (uri != NULL) {
+            ALOGI("notify: malloc %d uri OK", ext2);
+            memset(uri, 0, ext2);
+            strncpy(uri, (char *)ext1, ext2);
+        } else {
+            ALOGE("notify: malloc new uri failed when redirect palyer");
+        }
+
+        ALOGI("notify: New Url  len: %d uri: %s client->mPlayerType: %d", ext2, uri, client->mPlayerType);      
+        client->mPlayerType = NU_PLAYER;
+        client->setDataSource(uri, NULL);       
+        client->prepareAsync();
+
+        if (uri) {
+            free(uri);
+            uri = NULL;
+            ALOGI("notify: free uri OK");
+        }
+    }
 
     if (MEDIA_INFO == msg &&
         MEDIA_INFO_METADATA_UPDATE == ext1) {
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index d41c3b5..21a380f 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -410,6 +410,7 @@ private:
                     bool                        mLoop;
                     int32_t                     mConnId;
                     int                         mAudioSessionId;
+                    int                         mPlayerType;
                     uid_t                       mUID;
                     sp<ANativeWindow>           mConnectedWindow;
                     sp<IBinder>                 mConnectedWindowBinder;
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 4d25277..5418179 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -24,6 +24,9 @@
 #include <media/AudioParameter.h>
 #include "StagefrightRecorder.h"
 
+#include "ActAudioEncoder.h"
+#include <media/stagefright/ActAudioWriter.h>
+
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
 
@@ -836,6 +839,11 @@ status_t StagefrightRecorder::start() {
         case OUTPUT_FORMAT_MPEG2TS:
             status = startMPEG2TSRecording();
             break;
+        case OUTPUT_FORMAT_WAV:
+        case OUTPUT_FORMAT_MP3:            
+        case OUTPUT_FORMAT_WMA:
+            status = startActAudioRecording();
+            break;
 #ifdef QCOM_HARDWARE
         case OUTPUT_FORMAT_QCP:
             status = startExtendedRecording( );
@@ -923,6 +931,7 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
         return NULL;
     }
 
+    sp<MediaSource> audioEncoder;
     sp<MetaData> encMeta = new MetaData;
     const char *mime;
     switch (mAudioEncoder) {
@@ -950,6 +959,18 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
             mime = MEDIA_MIMETYPE_AUDIO_AAC;
             encMeta->setInt32(kKeyAACProfile, OMX_AUDIO_AACObjectELD);
             break;
+        case AUDIO_ENCODER_PCM:
+            mime = "WAV";
+            break;
+        case AUDIO_ENCODER_ADPCM:
+            mime = "ADPCM";
+            break;
+        case AUDIO_ENCODER_MP3:
+            mime = "MP3";
+            break;
+        case AUDIO_ENCODER_WMA:
+            mime = "WMA";
+            break;
 #ifdef QCOM_HARDWARE
         case AUDIO_ENCODER_EVRC:
             mime = MEDIA_MIMETYPE_AUDIO_EVRC;
@@ -977,11 +998,17 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
         encMeta->setInt32(kKeyTimeScale, mAudioTimeScale);
     }
 
-    OMXClient client;
-    CHECK_EQ(client.connect(), (status_t)OK);
-    sp<MediaSource> audioEncoder =
-        OMXCodec::Create(client.interface(), encMeta,
-                         true /* createEncoder */, audioSource);
+    if (mAudioEncoder < AUDIO_ENCODER_PCM) {
+        OMXClient client;
+        CHECK_EQ(client.connect(), (status_t)OK);
+        audioEncoder =
+            OMXCodec::Create(client.interface(), encMeta,
+                            true /* createEncoder */, audioSource);
+        ALOGE("===cz======createAudioSource google done");
+    } else {
+        audioEncoder = new ActAudioEncoder(audioSource, encMeta);
+        ALOGE("===cz======createAudioSource actions done");
+    }
 #ifdef QCOM_HARDWARE
     // If encoder could not be created (as in LPCM), then
     // use the AudioSource directly as the MediaSource.
@@ -1227,6 +1254,23 @@ status_t StagefrightRecorder::startMPEG2TSRecording() {
     return mWriter->start();
 }
 
+status_t StagefrightRecorder::startActAudioRecording() {
+    sp<MediaSource> audioEncoder = createAudioSource();
+    if (audioEncoder == NULL) {
+        return UNKNOWN_ERROR;
+    }
+    mWriter = new ActAudioWriter(dup(mOutputFd));
+    mWriter->addSource(audioEncoder);
+    if (mMaxFileDurationUs != 0) {
+        mWriter->setMaxFileDuration(mMaxFileDurationUs);
+    }
+    if (mMaxFileSizeBytes != 0) {
+        mWriter->setMaxFileSize(mMaxFileSizeBytes);
+    }
+    mWriter->setListener(mListener);
+    return mWriter->start();
+}
+
 void StagefrightRecorder::clipVideoFrameRate() {
     ALOGV("clipVideoFrameRate: encoder %d", mVideoEncoder);
     int minFrameRate = mEncoderProfiles->getVideoEncoderParamByName(
@@ -1509,10 +1553,17 @@ status_t StagefrightRecorder::setupCameraSource(
             return BAD_VALUE;
         }
 
-        mCameraSourceTimeLapse = CameraSourceTimeLapse::CreateFromCamera(
-                mCamera, mCameraProxy, mCameraId,
-                videoSize, mFrameRate, mPreviewSurface,
-                mTimeBetweenTimeLapseFrameCaptureUs);
+        if (mVideoEncoder == VIDEO_ENCODER_H264) {
+            mCameraSourceTimeLapse = CameraSourceTimeLapse::CreateFromCamera(
+                    mCamera, mCameraProxy, mCameraId,
+                    videoSize, mFrameRate, mPreviewSurface,
+                    mTimeBetweenTimeLapseFrameCaptureUs);
+        } else {
+            mCameraSourceTimeLapse = CameraSourceTimeLapse::CreateFromCamera(
+                    mCamera, mCameraProxy, mCameraId,
+                    videoSize, (mFrameRate|0x80000000), mPreviewSurface,
+                    mTimeBetweenTimeLapseFrameCaptureUs);
+        }
         *cameraSource = mCameraSourceTimeLapse;
     } else {
         bool useMeta = true;
@@ -1523,9 +1574,15 @@ status_t StagefrightRecorder::setupCameraSource(
             useMeta = false;
         }
 #endif
-        *cameraSource = CameraSource::CreateFromCamera(
-                mCamera, mCameraProxy, mCameraId, videoSize, mFrameRate,
-                mPreviewSurface, useMeta /*storeMetaDataInVideoBuffers*/);
+        if (mVideoEncoder == VIDEO_ENCODER_H264) {
+            *cameraSource = CameraSource::CreateFromCamera(
+                    mCamera, mCameraProxy, mCameraId, videoSize, mFrameRate,
+                    mPreviewSurface, useMeta /*storeMetaDataInVideoBuffers*/);
+        } else {
+            *cameraSource = CameraSource::CreateFromCamera(
+                    mCamera, mCameraProxy, mCameraId, videoSize, mFrameRate,
+                    mPreviewSurface, false /*storeMetaDataInVideoBuffers*/);
+        }
     }
     mCamera.clear();
     mCameraProxy.clear();
@@ -1595,6 +1652,22 @@ status_t StagefrightRecorder::setupVideoEncoder(
     CHECK(meta->findInt32(kKeySliceHeight, &sliceHeight));
     CHECK(meta->findInt32(kKeyColorFormat, &colorFormat));
 
+    {
+        int frameWidthActual = 0;
+        int frameHeightActual = 0;
+        bool ret = meta->findInt32('pwdt', &frameWidthActual);
+        ret = ret && meta->findInt32('phgt', &frameHeightActual);
+        if (ret) {
+            enc_meta->setInt32('pwdt', frameWidthActual);
+            enc_meta->setInt32('phgt', frameHeightActual);
+        }
+    }
+    
+    enc_meta->setInt32('ctlp', 0);
+    if (mCaptureTimeLapse) {
+        enc_meta->setInt32('ctlp', 1);
+    }
+
     enc_meta->setInt32(kKeyWidth, width);
     enc_meta->setInt32(kKeyHeight, height);
     enc_meta->setInt32(kKeyIFramesInterval, mIFramesIntervalSec);
@@ -1628,7 +1701,9 @@ status_t StagefrightRecorder::setupVideoEncoder(
     CHECK_EQ(client.connect(), (status_t)OK);
 
     uint32_t encoder_flags = 0;
+    encoder_flags |= OMXCodec::kOnlySubmitOneInputBufferAtOneTime;
     if (mIsMetaDataStoredInVideoBuffers) {
+        encoder_flags |= OMXCodec::kHardwareCodecsOnly;
         encoder_flags |= OMXCodec::kStoreMetaDataInVideoBuffers;
     }
 
@@ -1669,6 +1744,10 @@ status_t StagefrightRecorder::setupAudioEncoder(const sp<MediaWriter>& writer) {
         case AUDIO_ENCODER_AAC:
         case AUDIO_ENCODER_HE_AAC:
         case AUDIO_ENCODER_AAC_ELD:
+        case AUDIO_ENCODER_PCM:
+        case AUDIO_ENCODER_ADPCM:
+        case AUDIO_ENCODER_MP3:
+        case AUDIO_ENCODER_WMA:
 #ifdef QCOM_HARDWARE
         case AUDIO_ENCODER_LPCM:
 #endif
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index fd58115..44ca1a7 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -145,6 +145,7 @@ private:
     status_t startRawAudioRecording();
     status_t startRTPRecording();
     status_t startMPEG2TSRecording();
+    status_t startActAudioRecording();
     sp<MediaSource> createAudioSource();
     status_t checkVideoEncoderCapabilities();
     status_t checkAudioEncoderCapabilities();
diff --git a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
index 5dcca12..5f2dff2 100644
--- a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
@@ -67,7 +67,7 @@ NuPlayer::HTTPLiveSource::~HTTPLiveSource() {
 void NuPlayer::HTTPLiveSource::start() {
     mLiveLooper = new ALooper;
     mLiveLooper->setName("http live");
-    mLiveLooper->start();
+    mLiveLooper->start(false, false, ANDROID_PRIORITY_AUDIO); // 
 
     mLiveSession = new LiveSession(
             (mFlags & kFlagIncognito) ? LiveSession::kFlagIncognito : 0,
@@ -92,6 +92,18 @@ sp<MetaData> NuPlayer::HTTPLiveSource::getFormatMeta(bool audio) {
         return NULL;
     }
 
+	if (!audio) {
+		int64_t seekedListTimeBase=0;
+		int64_t maxSegDuration=0ll;
+		mLiveSession->getSeekedListTimeBase(&seekedListTimeBase);
+		mLiveSession->getMaxSegDuration(&maxSegDuration);
+		sp<MetaData> meta = source->getFormat();
+		if (meta != NULL) {
+			meta->setInt64(kKeyActNuSeekedListTimeBase, seekedListTimeBase);
+			meta->setInt64(kKeyActMaxSegDuration, maxSegDuration);
+		}
+		//LOGI("getFormat: seekedListTimeBase: %lld maxSegDuration: %lld", seekedListTimeBase, maxSegDuration);
+	}
     return source->getFormat();
 }
 
@@ -103,7 +115,7 @@ status_t NuPlayer::HTTPLiveSource::feedMoreTSData() {
     sp<LiveDataSource> source =
         static_cast<LiveDataSource *>(mLiveSession->getDataSource().get());
 
-    for (int32_t i = 0; i < 50; ++i) {
+    for (int32_t i = 0; i < 50; ++i) {// default: 50
         char buffer[188];
         ssize_t n = source->readAtNonBlocking(mOffset, buffer, sizeof(buffer));
 
@@ -111,13 +123,17 @@ status_t NuPlayer::HTTPLiveSource::feedMoreTSData() {
             break;
         } else if (n < 0) {
             if (n != ERROR_END_OF_STREAM) {
-                ALOGI("input data EOS reached, error %ld", n);
+                //ALOGI("feedMoreTSData: input data EOS reached, error %ld", n);
+                continue;
             } else {
-                ALOGI("input data EOS reached.");
+            	  mTSParser->signalEOS(n);
+            	  mFinalResult = n;
+                ALOGI("feedMoreTSData: input data EOS reached.");
+                break;
             }
-            mTSParser->signalEOS(n);
-            mFinalResult = n;
-            break;
+            //mTSParser->signalEOS(n);
+            //mFinalResult = n;
+            //break;
         } else {
             if (buffer[0] == 0x00) {
                 // XXX legacy
@@ -183,10 +199,10 @@ status_t NuPlayer::HTTPLiveSource::getDuration(int64_t *durationUs) {
 status_t NuPlayer::HTTPLiveSource::seekTo(int64_t seekTimeUs) {
     // We need to make sure we're not seeking until we have seen the very first
     // PTS timestamp in the whole stream (from the beginning of the stream).
-    while (!mTSParser->PTSTimeDeltaEstablished() && feedMoreTSData() == OK) {
+	
+    /*while (!mTSParser->PTSTimeDeltaEstablished() && feedMoreTSData() == OK) {
         usleep(100000);
-    }
-
+    }*/
     mLiveSession->seekTo(seekTimeUs);
 
     return OK;
diff --git a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
index 79f4ab8..512f0ba 100644
--- a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
+++ b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
@@ -65,6 +65,7 @@ private:
     sp<ALooper> mLiveLooper;
     sp<LiveSession> mLiveSession;
     sp<ATSParser> mTSParser;
+    int64_t mSeekedListTimeBase;
 
     DISALLOW_EVIL_CONSTRUCTORS(HTTPLiveSource);
 };
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index ff27873..8aca5fd 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -67,10 +67,18 @@ NuPlayer::NuPlayer()
       mResetPostponed(false),
       mSkipRenderingAudioUntilMediaTimeUs(-1ll),
       mSkipRenderingVideoUntilMediaTimeUs(-1ll),
+	  mLastSegPosition(0ll),
+	  mCurrentPosition(0ll),
+	  mLastPositionUs(0ll),
+	  mSeekFlag(false),
+	  mSeekPostionFlag(false),
       mVideoLateByUs(0ll),
       mNumFramesTotal(0ll),
       mNumFramesDropped(0ll),
-      mVideoScalingMode(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW) {
+      mVideoScalingMode(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW),
+	  mMaxSegDuration(0ll),
+      mChangingVideoSurfaceTexture(false),
+      mDuration(0x80000000000){
 }
 
 NuPlayer::~NuPlayer() {
@@ -109,6 +117,9 @@ static bool IsHTTPLiveURL(const char *url) {
 
         if (strstr(url,"m3u8")) {
             return true;
+        }       
+         if (strstr(url,"m3u")) {
+            return true;
         }
     }
 
@@ -241,6 +252,9 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
             CHECK(msg->findObject("native-window", &obj));
 
             mNativeWindow = static_cast<NativeWindowWrapper *>(obj.get());
+			
+			if (mVideoDecoder != NULL) 
+			      mChangingVideoSurfaceTexture = true;
 
             // XXX - ignore error from setVideoScalingMode for now
             setVideoScalingMode(mVideoScalingMode);
@@ -336,7 +350,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
             if ((mAudioDecoder == NULL && mAudioSink != NULL)
                     || (mVideoDecoder == NULL && mNativeWindow != NULL)) {
-                msg->post(100000ll);
+                msg->post(10000ll);
                 mScanSourcesPending = true;
             }
             break;
@@ -365,16 +379,11 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
             } else if (what == ACodec::kWhatEOS) {
                 int32_t err;
                 CHECK(codecRequest->findInt32("err", &err));
-
-                if (err == ERROR_END_OF_STREAM) {
-                    ALOGV("got %s decoder EOS", audio ? "audio" : "video");
-                } else {
-                    ALOGV("got %s decoder EOS w/ error %d",
-                         audio ? "audio" : "video",
-                         err);
-                }
-
-                mRenderer->queueEOS(audio, err);
+                ALOGE("kWhatEOS: %s decoder meet: %s 0x%x", audio ? "audio" : "video", (err == ERROR_END_OF_STREAM)  ? "EOS" : "error");
+				if ((err == ERROR_END_OF_STREAM)||(err == ERROR_IO) || (err == ERROR_UNSUPPORTED)) {
+                       if (!IsFlushingState(audio ? mFlushingAudio : mFlushingVideo)) 
+                        mRenderer->queueEOS(audio, err);
+				}
             } else if (what == ACodec::kWhatFlushCompleted) {
                 bool needShutdown;
 
@@ -491,8 +500,21 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
             } else if (what == ACodec::kWhatError) {
                 ALOGE("Received error from %s decoder, aborting playback.",
                      audio ? "audio" : "video");
-
-                mRenderer->queueEOS(audio, UNKNOWN_ERROR);
+				int32_t err;
+				CHECK(codecRequest->findInt32("err", &err));
+				ALOGW("err:%d",err);
+                if (err == OMX_ErrorallocateBuffersFailed) {
+					 ALOGW("%d %d %d",mChangingVideoSurfaceTexture,mFlushingAudio,mFlushingVideo);
+					    usleep(3000000);
+					    if ( mFlushingAudio ==  NONE && mFlushingVideo == NONE){
+							ALOGW("OMX_ErrorallocateBuffersFailed flushDecoder");
+						    flushDecoder(false, true);
+				            mFlushingAudio = SHUT_DOWN;
+							mChangingVideoSurfaceTexture = false;
+					}
+				}else{				
+                  mRenderer->queueEOS(audio, UNKNOWN_ERROR);				
+				}
             } else if (what == ACodec::kWhatDrainThisBuffer) {
                 renderBuffer(audio, codecRequest);
             } else {
@@ -539,14 +561,29 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 CHECK(msg->findInt64("positionUs", &positionUs));
 
                 CHECK(msg->findInt64("videoLateByUs", &mVideoLateByUs));
-
+                
                 if (mDriver != NULL) {
                     sp<NuPlayerDriver> driver = mDriver.promote();
                     if (driver != NULL) {
-                        driver->notifyPosition(positionUs);
-
-                        driver->notifyFrameStats(
-                                mNumFramesTotal, mNumFramesDropped);
+					   //ALOGW("mCurrentPosition:%lld isSeeking:%d positionUs:%lld,mLastPositionUs:%lld",
+					   //	mCurrentPosition,mSeekPostionFlag,positionUs,mLastPositionUs);
+                       if(mSeekPostionFlag == true) {
+						   mLastPositionUs = positionUs;
+						   mSeekPostionFlag = false;
+                       }
+
+                        int64_t durationUs;
+                        if(mMaxSegDuration != 0){
+                          if(positionUs - mLastPositionUs < 2 * 1000 * 1000 &&
+                            positionUs - mLastPositionUs > -1 * 1000 * 1000){     
+                            mCurrentPosition += positionUs - mLastPositionUs;
+                            }
+                        }else {
+                          mCurrentPosition = positionUs;
+                        }
+                       mLastPositionUs = positionUs;
+                       driver->notifyPosition(mCurrentPosition);                 
+                       driver->notifyFrameStats(mNumFramesTotal, mNumFramesDropped);
                     }
                 }
             } else if (what == Renderer::kWhatFlushComplete) {
@@ -578,10 +615,11 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 // buffers and is paused, therefore the decoder will not read
                 // more input data and will never encounter the matching
                 // discontinuity. To avoid this, we resume the renderer.
-
-                if (mFlushingAudio == AWAITING_DISCONTINUITY
-                        || mFlushingVideo == AWAITING_DISCONTINUITY) {
-                    mRenderer->resume();
+                if ((mFlushingAudio == AWAITING_DISCONTINUITY) || (mFlushingVideo == AWAITING_DISCONTINUITY)) {
+                    //NU_LOGW("kWhatReset: --> mRenderer->resume()");
+                    //mRenderer->resume();
+					mFlushingAudio = NONE;
+					mFlushingVideo = NONE;
                 }
             }
 
@@ -619,19 +657,47 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
         {
             int64_t seekTimeUs;
             CHECK(msg->findInt64("seekTimeUs", &seekTimeUs));
-
-            ALOGV("kWhatSeek seekTimeUs=%lld us (%.2f secs)",
-                 seekTimeUs, seekTimeUs / 1E6);
-
-            mSource->seekTo(seekTimeUs);
-
+            bool skipSeek = false;
+			
+            ALOGW("kWhatSeek seekTimeUs=%lld us frome %Lld",
+                 seekTimeUs, mCurrentPosition);
+
+
+			if (mMaxSegDuration && 
+				seekTimeUs - mCurrentPosition < 5 * 1000 * 1000 && 
+			   seekTimeUs - mCurrentPosition > -5 * 1000 * 1000) {
+			   ALOGW("====dismiss a nonsense seek");
+			   skipSeek = true;
+			}
+
+			 if (mDuration && 
+			 	seekTimeUs - mDuration < 2 * 1000 * 1000 && 
+				seekTimeUs - mDuration > -5 * 1000 * 1000) {
+				ALOGW("=== in file end so do not skip");
+				skipSeek = false;
+			 }
+			 
+		 	if (mChangingVideoSurfaceTexture) {
+				ALOGW("kWhatSeek seek must be done because mChangingVideoSurfaceTexture");
+				skipSeek = false;
+			 }
+			if (skipSeek == false) {
+				 mSeekFlag = true;
+				 mSeekingTime = seekTimeUs;
+				 mSource->seekTo(seekTimeUs);
+				 mRenderer->Seek(true);
+			}
+		   
+
+				
             if (mDriver != NULL) {
                 sp<NuPlayerDriver> driver = mDriver.promote();
                 if (driver != NULL) {
-                    driver->notifySeekComplete();
+					  ALOGW("onMessageReceived: kWhatSeek call notifySeekComple11te()");
+					driver->notifyPosition(seekTimeUs);					
+					driver->notifySeekComplete();
                 }
-            }
-
+            }            
             break;
         }
 
@@ -656,11 +722,12 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 }
 
 void NuPlayer::finishFlushIfPossible() {
-    if (mFlushingAudio != FLUSHED && mFlushingAudio != SHUT_DOWN) {
+
+    if (mFlushingVideo != FLUSHED && mFlushingVideo != SHUT_DOWN) {
         return;
     }
 
-    if (mFlushingVideo != FLUSHED && mFlushingVideo != SHUT_DOWN) {
+    if (mFlushingAudio != FLUSHED && mFlushingAudio != SHUT_DOWN) {
         return;
     }
 
@@ -734,21 +801,48 @@ status_t NuPlayer::instantiateDecoder(bool audio, sp<Decoder> *decoder) {
         return OK;
     }
 
-    sp<AMessage> format = mSource->getFormat(audio);
+    sp<AMessage> format = mSource->getFormat(audio);   	
 
     if (format == NULL) {
         return -EWOULDBLOCK;
     }
+    ALOGI("NuPlayer::instantiateDecoder %s",audio?"audio":"video");
 
     if (!audio) {
         AString mime;
+        int64_t seekedListTimeBase=0ll;
+        int64_t maxSegDuration=0ll;
         CHECK(format->findString("mime", &mime));
         mVideoIsAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());
+        format->findInt64("nu-seeked-time", &seekedListTimeBase);
+        format->findInt64("max-seg-duration", &maxSegDuration);
+
+        mMaxSegDuration = maxSegDuration;
+        if (mSeekFlag == true ) {
+            if (maxSegDuration) {
+                if(mChangingVideoSurfaceTexture){
+                    mCurrentPosition = mSeekingTime - 1000*1000;
+                    mRenderer->DiscardForward(mSeekingTime - seekedListTimeBase);
+                    ALOGW("ChangingVideoSurfaceTexture from %lld to %lld because of seek",seekedListTimeBase,mSeekingTime);
+                } else {                
+                   mCurrentPosition = seekedListTimeBase;
+                }
+            } else {
+                 mCurrentPosition = mSeekingTime;
+            }
+            mChangingVideoSurfaceTexture = false;           
+            mLastSegPosition = seekedListTimeBase;
+            mSeekFlag = false;
+            mSeekPostionFlag = true;
+            mSeekingTime = 0;
+            mRenderer->Seek(false);
+        }
     }
 
     sp<AMessage> notify =
         new AMessage(audio ? kWhatAudioNotify : kWhatVideoNotify,
                      id());
+    ALOGI("NuPlayer::instantiateDecoder2 %s",audio?"audio":"video");
 
     *decoder = audio ? new Decoder(notify) :
                        new Decoder(notify, mNativeWindow);
@@ -756,11 +850,12 @@ status_t NuPlayer::instantiateDecoder(bool audio, sp<Decoder> *decoder) {
 
     (*decoder)->configure(format);
 
-    int64_t durationUs;
+    int64_t durationUs=0ll;
     if (mDriver != NULL && mSource->getDuration(&durationUs) == OK) {
         sp<NuPlayerDriver> driver = mDriver.promote();
         if (driver != NULL) {
             driver->notifyDuration(durationUs);
+			mDuration = durationUs;
         }
     }
 
@@ -770,13 +865,37 @@ status_t NuPlayer::instantiateDecoder(bool audio, sp<Decoder> *decoder) {
 status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
     sp<AMessage> reply;
     CHECK(msg->findMessage("reply", &reply));
-
+	if (mScanSourcesPending == true) {
+        ALOGW("feedDecoderInputData decode: %s wait",audio?"audio":"video");
+         return -EWOULDBLOCK;         
+    }
+    if (audio && mFlushingAudio == SHUT_DOWN)		
+	    return -EWOULDBLOCK;
+	
+    //if (!audio && mFlushingVideo == SHUTTING_DOWN_DECODER){
+    //    ALOGW("feedDecoderInputData error,SHUTTING_DOWN_DECODER");
+    //    reply->setInt32("err", INFO_DISCONTINUITY);
+    //    reply->post();
+    //    return OK;
+   // }
+	
     if ((audio && IsFlushingState(mFlushingAudio))
             || (!audio && IsFlushingState(mFlushingVideo))) {
+        ALOGW("feedDecoderInputData error,INFO_DISCONTINUITY %s",audio?"audio":"video");
         reply->setInt32("err", INFO_DISCONTINUITY);
         reply->post();
         return OK;
     }
+	
+    //if (mChangingVideoSurfaceTexture && !audio &&
+		//mFlushingAudio ==  NONE && mFlushingVideo == NONE){
+			//ALOGW("feedDecoderInputData flushDecoder");
+		    //flushDecoder(false, true);
+           //mFlushingAudio = SHUT_DOWN;
+			//mChangingVideoSurfaceTexture = false;
+		   // return -EWOULDBLOCK;
+	//}
+    
 
     sp<ABuffer> accessUnit;
 
@@ -833,9 +952,11 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
                     mTimeDiscontinuityPending || timeChange;
 
                 if (formatChange || timeChange) {
+			          		ALOGW("feedDecoderInputData start flush %s",audio ? "audio" : "video");
                     flushDecoder(audio, formatChange);
                 } else {
                     // This stream is unaffected by the discontinuity
+				           	ALOGW("feedDecoderInputData start fake flush %s",audio ? "audio" : "video");
 
                     if (audio) {
                         mFlushingAudio = FLUSHED;
@@ -859,8 +980,10 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
         }
 
         dropAccessUnit = false;
+
+        
         if (!audio
-                && mVideoLateByUs > 100000ll
+                && mVideoLateByUs > 2000000ll
                 && mVideoIsAVC
                 && !IsAVCReferenceFrame(accessUnit)) {
             dropAccessUnit = true;
@@ -949,6 +1072,8 @@ void NuPlayer::flushDecoder(bool audio, bool needShutdown) {
         ALOGI("flushDecoder %s without decoder present",
              audio ? "audio" : "video");
     }
+	ALOGW("flushDecoder %s decoder mFlushingVideo%d mFlushingAudio%d", audio ? "audio" : "video"
+		,mFlushingVideo,mFlushingAudio);
 
     // Make sure we don't continue to scan sources until we finish flushing.
     ++mScanSourcesGeneration;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 31efb2e..5a8453b 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -136,6 +136,17 @@ private:
     int64_t mNumFramesTotal, mNumFramesDropped;
 
     int32_t mVideoScalingMode;
+	int64_t mMaxSegDuration;
+	int64_t mLastSegPosition;
+	int64_t mCurrentPosition;
+	int64_t mLastPositionUs;
+	int64_t mDuration;
+	int64_t mSeekingTime;
+	bool mSeekFlag;
+	bool mSeekIFrmFlag;
+	bool mSeekPostionFlag;
+	
+	bool mChangingVideoSurfaceTexture;
 
     status_t instantiateDecoder(bool audio, sp<Decoder> *decoder);
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 22f699e..5f56580 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -54,7 +54,8 @@ void NuPlayer::Decoder::configure(const sp<AMessage> &format) {
             break;
         }
 
-        mCSD.push(csd);
+        if(strncasecmp(mime.c_str(), "video/avc", 9))
+            mCSD.push(csd);
     }
 
     if (mNativeWindow != NULL) {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index d03601f..3a0a04f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -36,7 +36,9 @@ NuPlayerDriver::NuPlayerDriver()
       mLooper(new ALooper),
       mState(UNINITIALIZED),
       mAtEOS(false),
-      mStartupSeekTimeUs(-1) {
+      mStartupSeekTimeUs(-1),
+      mLastPositionUpdateUs(0), 
+      mBufferingFlag(false){
     mLooper->setName("NuPlayerDriver Looper");
 
     mLooper->start(
@@ -216,7 +218,12 @@ status_t NuPlayerDriver::getCurrentPosition(int *msec) {
     } else {
         *msec = (mPositionUs + 500ll) / 1000;
     }
-
+    int64_t nowUs = ALooper::GetNowUs();
+    if (mPositionUs > 0 && mState == PLAYING && nowUs - mLastPositionUpdateUs > 5000 * 1000 && !mBufferingFlag){
+     mBufferingFlag = true;
+	 notifyListener(MEDIA_INFO, MEDIA_INFO_BUFFERING_START);
+	 ALOGW("send MEDIA_INFO_BUFFERING_START");
+    }
     return OK;
 }
 
@@ -315,7 +322,14 @@ void NuPlayerDriver::notifyDuration(int64_t durationUs) {
 
 void NuPlayerDriver::notifyPosition(int64_t positionUs) {
     Mutex::Autolock autoLock(mLock);
-    mPositionUs = positionUs;
+    mPositionUs = positionUs;		
+    int64_t nowUs = ALooper::GetNowUs();
+	if (nowUs - mLastPositionUpdateUs > 5000 * 1000 && mBufferingFlag) {
+	 notifyListener(MEDIA_INFO, MEDIA_INFO_BUFFERING_END);	 
+     mBufferingFlag = false;
+	 ALOGW("send MEDIA_INFO_BUFFERING_END");
+	}	
+    mLastPositionUpdateUs = ALooper::GetNowUs();
 }
 
 void NuPlayerDriver::notifySeekComplete() {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.h b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.h
index 4a0026c..b576e5f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.h
@@ -98,6 +98,8 @@ private:
     bool mAtEOS;
 
     int64_t mStartupSeekTimeUs;
+	int64_t mLastPositionUpdateUs;
+	bool mBufferingFlag;
 
     DISALLOW_EVIL_CONSTRUCTORS(NuPlayerDriver);
 };
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 8a75f83..d245379 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -47,9 +47,17 @@ NuPlayer::Renderer::Renderer(
       mHasVideo(false),
       mSyncQueues(false),
       mPaused(false),
+      mDropFrmNum(0),
       mVideoRenderingStarted(false),
       mLastPositionUpdateUs(-1ll),
-      mVideoLateByUs(0ll) {
+      mVideoLateByUs(0ll),
+      m_discardFrame_audio(0),
+	  m_discardFrame_video(0),
+      m_discardForward_audio(0),
+      m_discardForward_video(0),
+      last_mediaTimeUs_audio(0xfffff0000),
+      last_mediaTimeUs_video(0xfffff0000),
+      mSeeking(false){
 }
 
 NuPlayer::Renderer::~Renderer() {
@@ -219,6 +227,7 @@ void NuPlayer::Renderer::signalAudioSinkChanged() {
 }
 
 bool NuPlayer::Renderer::onDrainAudioQueue() {
+    int skip = 0;
     uint32_t numFramesPlayed;
     if (mAudioSink->getPosition(&numFramesPlayed) != OK) {
         return false;
@@ -251,6 +260,11 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
             entry = NULL;
             return false;
         }
+		
+		if(shouldSkip(true/*audio*/,entry) == true){
+           memset(entry->mBuffer->data(),0,entry->mBuffer->size());
+		   skip = 1;
+		}
 
         if (entry->mOffset == 0) {
             int64_t mediaTimeUs;
@@ -281,7 +295,8 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
         if (copy > numBytesAvailableToWrite) {
             copy = numBytesAvailableToWrite;
         }
-
+		
+		if(!skip)
         CHECK_EQ(mAudioSink->write(
                     entry->mBuffer->data() + entry->mOffset, copy),
                  (ssize_t)copy);
@@ -296,9 +311,11 @@ bool NuPlayer::Renderer::onDrainAudioQueue() {
 
         numBytesAvailableToWrite -= copy;
         size_t copiedFrames = copy / mAudioSink->frameSize();
+		if(!skip)
         mNumFramesWritten += copiedFrames;
     }
 
+   if(!skip)
     notifyPosition();
 
     return !mAudioQueue.empty();
@@ -339,6 +356,14 @@ void NuPlayer::Renderer::postDrainVideoQueue() {
                 (mediaTimeUs - mAnchorTimeMediaUs) + mAnchorTimeRealUs;
 
             delayUs = realTimeUs - ALooper::GetNowUs();
+				if ((delayUs > 8000000ll)){ //||(delayUs < 40000ll)) {
+				    //ALOGW("positionUs changed so video lately too much before some audio frame? %lld %lld",mediaTimeUs,mAnchorTimeMediaUs);
+					delayUs = 100000ll;
+				}else if (delayUs > 10000ll) {	
+					delayUs -= 10000ll;
+				}else if (delayUs < 0ll) {
+					delayUs = 0ll;
+				}
         }
     }
 
@@ -348,6 +373,7 @@ void NuPlayer::Renderer::postDrainVideoQueue() {
 }
 
 void NuPlayer::Renderer::onDrainVideoQueue() {
+	int skip = 0;
     if (mVideoQueue.empty()) {
         return;
     }
@@ -371,19 +397,31 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
     int64_t mediaTimeUs;
     CHECK(entry->mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
 
+	if(shouldSkip(false/*video*/,entry) == true){
+	   skip = 1;
+	} 
+
     int64_t realTimeUs = mediaTimeUs - mAnchorTimeMediaUs + mAnchorTimeRealUs;
     mVideoLateByUs = ALooper::GetNowUs() - realTimeUs;
 
     bool tooLate = (mVideoLateByUs > 40000);
-
-    if (tooLate) {
-        ALOGV("video late by %lld us (%.2f secs)",
-             mVideoLateByUs, mVideoLateByUs / 1E6);
-    } else {
-        ALOGV("rendering video at media time %.2f secs", mediaTimeUs / 1E6);
-    }
-
-    entry->mNotifyConsumed->setInt32("render", !tooLate);
+	int32_t drop_frame_flag = 0;
+
+	if ((tooLate&&(mDropFrmNum < MAX_DROP_FRAME_NUM))) {
+		drop_frame_flag = 1;
+	}
+	
+	if (drop_frame_flag == 0) {
+		if (mDropFrmNum == MAX_DROP_FRAME_NUM) {
+			mDropFrmNum = 0;
+		}
+	}else if (drop_frame_flag == 1){
+		mDropFrmNum ++;
+	}
+
+	//NUR_LOGI("onDrainVideoQueue: setInt32(render, render: %d) >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", !drop_frame_flag);
+	mVideoFrmNum ++;
+	entry->mNotifyConsumed->setInt32("render", !drop_frame_flag && !skip);
     entry->mNotifyConsumed->post();
     mVideoQueue.erase(mVideoQueue.begin());
     entry = NULL;
@@ -392,7 +430,7 @@ void NuPlayer::Renderer::onDrainVideoQueue() {
         mVideoRenderingStarted = true;
         notifyVideoRenderingStart();
     }
-
+	if(!skip)
     notifyPosition();
 }
 
@@ -670,5 +708,70 @@ void NuPlayer::Renderer::onResume() {
     }
 }
 
+#undef LOGW
+#define LOGW(x, ...) 			//ALOGW(x, ##__VA_ARGS__)
+
+void NuPlayer::Renderer::Seek(bool Seeking) {
+	LOGW("seekbar seek");
+	mSeeking = Seeking;
+}
+
+void NuPlayer::Renderer::DiscardForward(int64_t time) {
+	LOGW("seekbar seek");
+	if (time > 30*1000*1000)
+		return;
+	m_discardForward_video = time - 2000 * 1000;
+	m_discardForward_audio = time - 2000 * 1000;
+}
+
+bool NuPlayer::Renderer::shouldSkipNotify() 
+{
+  LOGW("seekbar shouldSkipNotify %lld %lld",m_discardFrame_audio,m_discardFrame_video);
+  return (m_discardFrame_video > 0) && (m_discardFrame_audio > 0);
+}
+
+bool NuPlayer::Renderer::shouldSkip(bool audio,QueueEntry *entry) 
+{
+	int64_t mediaTimeUs;
+    CHECK(entry->mBuffer->meta()->findInt64("timeUs", &mediaTimeUs));
+	if(audio){
+		if(mSeeking){
+		last_mediaTimeUs_audio = mediaTimeUs;		
+		LOGW("seekbar skip audio %lld",mediaTimeUs);	
+		return true; 	
+		}
+        if (m_discardForward_audio > 0){ 
+             if (mediaTimeUs - last_mediaTimeUs_audio > 0 && 
+             mediaTimeUs - last_mediaTimeUs_audio < 1000*1000)
+                 m_discardForward_audio -= (mediaTimeUs - last_mediaTimeUs_audio);
+             last_mediaTimeUs_audio = mediaTimeUs;
+	         LOGW("seekbar forward audio %lld now:%lld last:%lld",m_discardForward_audio,mediaTimeUs,last_mediaTimeUs_audio);		
+             return true;
+        }
+		last_mediaTimeUs_audio = mediaTimeUs;
+		LOGW("seekbar render audio %lld",mediaTimeUs);
+	} else {
+		if(mSeeking){
+		last_mediaTimeUs_video = mediaTimeUs;		
+		LOGW("seekbar skip video %lld %lld",mediaTimeUs);	
+		return true; 	
+		}
+		
+        if (m_discardForward_video > 0){ 
+             if (mediaTimeUs - last_mediaTimeUs_video > 0 && 
+             mediaTimeUs - last_mediaTimeUs_video < 1000*1000)
+                 m_discardForward_video -= (mediaTimeUs - last_mediaTimeUs_video);
+             last_mediaTimeUs_video = mediaTimeUs;
+	         LOGW("seekbar forward video %lld now:%lld last:%lld",m_discardForward_video,mediaTimeUs,last_mediaTimeUs_video);		
+             return true;
+             
+        }
+		last_mediaTimeUs_video = mediaTimeUs;
+		LOGW("seekbar render video %lld",mediaTimeUs);
+	}
+	
+	return false;
+}
+
 }  // namespace android
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
index e4368c7..0ff9d37 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
@@ -18,6 +18,7 @@
 
 #define NUPLAYER_RENDERER_H_
 
+#define MAX_DROP_FRAME_NUM		6
 #include "NuPlayer.h"
 
 namespace android {
@@ -43,6 +44,10 @@ struct NuPlayer::Renderer : public AHandler {
 
     void pause();
     void resume();
+	void Seek(bool Seeking);
+	bool shouldSkipNotify();
+	void DiscardForward(int64_t time);
+	bool shouldDiscardForward();
 
     enum {
         kWhatEOS                 = 'eos ',
@@ -92,6 +97,8 @@ private:
     int64_t mAnchorTimeRealUs;
 
     Mutex mFlushLock;  // protects the following 2 member vars.
+	int32_t mVideoFrmNum;
+	uint32_t mDropFrmNum;
     bool mFlushingAudio;
     bool mFlushingVideo;
 
@@ -101,10 +108,17 @@ private:
 
     bool mPaused;
     bool mVideoRenderingStarted;
+	bool mSeeking;
 
     int64_t mLastPositionUpdateUs;
     int64_t mVideoLateByUs;
 
+	int64_t m_discardFrame_video;
+	int64_t m_discardFrame_audio;
+	int64_t m_discardForward_video;
+	int64_t m_discardForward_audio;
+	int64_t last_mediaTimeUs_audio;
+    int64_t last_mediaTimeUs_video;
     bool onDrainAudioQueue();
     void postDrainAudioQueue(int64_t delayUs = 0);
 
@@ -122,6 +136,7 @@ private:
     void notifyFlushComplete(bool audio);
     void notifyPosition();
     void notifyVideoLateBy(int64_t lateByUs);
+	bool shouldSkip(bool audio,QueueEntry *entry) ;
     void notifyVideoRenderingStart();
 
     void flushQueue(List<QueueEntry> *queue);
diff --git a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
index cf455bd..f2d5571 100644
--- a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
@@ -459,6 +459,10 @@ void NuPlayer::RTSPSource::onConnected() {
 }
 
 void NuPlayer::RTSPSource::onDisconnected(const sp<AMessage> &msg) {
+    if (mState == DISCONNECTED) {
+        return;
+    }
+
     status_t err;
     CHECK(msg->findInt32("result", &err));
     CHECK_NE(err, (status_t)OK);
diff --git a/media/libstagefright/AACWriter.cpp b/media/libstagefright/AACWriter.cpp
index a6f7cfb..aab404a 100644
--- a/media/libstagefright/AACWriter.cpp
+++ b/media/libstagefright/AACWriter.cpp
@@ -106,6 +106,12 @@ status_t AACWriter::addSource(const sp<MediaSource> &source) {
     if (meta->findInt32(kKeyAACProfile, &mAACProfile)) {
         ALOGI("AAC profile is changed to %d", mAACProfile);
     }
+    else
+    {
+        // cz_20130607 bugfix aac profile
+        ALOGW("AAC profile not find");
+        mAACProfile = OMX_AUDIO_AACObjectLC;
+    }
 
     mSource = source;
     return OK;
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index a9e344d..77c5d1e 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -55,6 +55,15 @@
 
 #include "include/avc_utils.h"
 
+#include <actal_posix_dev.h>
+#include<ALdec_plugin.h>
+#include "gralloc_priv.h"
+#include "ACT_OMX_Index.h"
+
+#define ACTIONS_PREFIX                 "OMX.Action"
+#define ACTIONS_VIDEO_DECODER  ACTIONS_PREFIX".Video.Decoder"
+#define ACTIONS_AUDIO_DECODER  ACTIONS_PREFIX".Audio.Decoder"
+
 namespace android {
 
 template<class T>
@@ -492,15 +501,21 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                         ? OMXCodec::kRequiresAllocateBufferOnInputPorts
                         : OMXCodec::kRequiresAllocateBufferOnOutputPorts;
 
-                if (portIndex == kPortIndexInput && (mFlags & kFlagIsSecure)) {
-                    mem.clear();
+                //if (portIndex == kPortIndexInput && (mFlags & kFlagIsSecure)) {
+                if (portIndex == kPortIndexInput && !mIsEncoder) {
+                    if(mOMX->livesLocally(mNode, getpid())) {
+                        mem.clear();
 
-                    void *ptr;
-                    err = mOMX->allocateBuffer(
-                            mNode, portIndex, def.nBufferSize, &info.mBufferID,
-                            &ptr);
+                        void *ptr;
+                        err = mOMX->allocateBuffer(
+                                mNode, portIndex, def.nBufferSize, &info.mBufferID,
+                                &ptr);
 
-                    info.mData = new ABuffer(ptr, def.nBufferSize);
+                        info.mData = new ABuffer(ptr, def.nBufferSize);
+                    } else {
+                        err = mOMX->allocateBufferWithBackup(
+                                mNode, portIndex, mem, &info.mBufferID);
+                    }
                 } else if (mQuirks & requiresAllocateBufferBit) {
                     err = mOMX->allocateBufferWithBackup(
                             mNode, portIndex, mem, &info.mBufferID);
@@ -542,6 +557,8 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
 status_t ACodec::allocateOutputBuffersFromNativeWindow() {
     OMX_PARAM_PORTDEFINITIONTYPE def;
+    int grallocColorFormat;
+    int result;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
@@ -552,6 +569,41 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+        err = mNativeWindow->query(mNativeWindow.get(),NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,&result);
+        if(err){
+          ALOGE("  mAnw->query  NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER = %d !",result);
+        }else{
+                ALOGE(" NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER  = %d !",result);
+        }
+        
+        /*ヨ window瀹浣绫诲淇℃锛姝ゅ杩搴璇ユsurfaceTextureClinent */
+        err =mNativeWindow->query(mNativeWindow.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
+        if(err){
+                ALOGE(" mAnw->query  NATIVE_WINDOW_CONCRETE_TYPE = %d !",result);
+        }else{
+                ALOGE(" NATIVE_WINDOW_CONCRETE_TYPE  = %d !",result);
+        }
+
+    err = native_window_set_scaling_mode(mNativeWindow.get(),
+            NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
+    if (err != OK) {
+        return err;
+    }
+    switch(def.format.video.eColorFormat)
+    {
+        case OMX_COLOR_FormatYUV420Planar:
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+                        case OMX_COLOR_FormatYUV422Planar:
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+                        default:
+                                ALOGE("Format: %d not support! Use HAL_PIXEL_FORMAT_YV12",def.format.video.eColorFormat);
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+    }
+        def.format.video.eColorFormat=(OMX_COLOR_FORMATTYPE)grallocColorFormat;
+
 #ifdef USE_SAMSUNG_COLORFORMAT
     OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
     setNativeWindowColorFormat(eNativeColorFormat);
@@ -564,8 +616,8 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
 #else
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
-            def.format.video.nFrameWidth,
-            def.format.video.nFrameHeight,
+            def.format.video.nStride,
+            (def.format.video.nFrameHeight+15)&(~15),
             def.format.video.eColorFormat);
 #endif
 
@@ -609,7 +661,7 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
 
     err = native_window_set_usage(
             mNativeWindow.get(),
-            usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
+            usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP |GRALLOC_USAGE_HW_VIDEO);
 
     if (err != 0) {
         ALOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
@@ -746,14 +798,31 @@ status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
 }
 
 ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
+    size_t i;
+    size_t owned;
+    size_t totalBuffers;
     ANativeWindowBuffer *buf;
     int fenceFd = -1;
+
+    totalBuffers = mBuffers[kPortIndexOutput].size();
+    owned = 0;
+    for (i = 0; i < totalBuffers; i++) {
+        BufferInfo *info = &mBuffers[kPortIndexOutput].editItemAt(i);
+        if (info->mStatus < BufferInfo::OWNED_BY_NATIVE_WINDOW) {
+            owned += 1;
+        }
+    }
+
+    if (owned >= 18) {
+        // stop request more video buffers if we already have enough
+        return NULL;
+    }
     if (native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf) != 0) {
         ALOGE("dequeueBuffer failed.");
         return NULL;
     }
 
-    for (size_t i = mBuffers[kPortIndexOutput].size(); i-- > 0;) {
+    for (i = totalBuffers; i-- > 0;) {
         BufferInfo *info =
             &mBuffers[kPortIndexOutput].editItemAt(i);
 
@@ -882,6 +951,8 @@ status_t ACodec::setComponentRole(
             "audio_decoder.raw", "audio_encoder.raw" },
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
+        { MEDIA_MIMETYPE_AUDIO_ACT_AAC,
+            "audio_decoder.aac", ""},
     };
 
     static const size_t kNumMimeToRole =
@@ -1092,6 +1163,8 @@ status_t ACodec::configureCodec(
                     || !msg->findInt32("height", &height)) {
                 err = INVALID_OPERATION;
             } else {
+                video_display_w = width;
+                video_display_h = height;
                 err = setupVideoDecoder(mime, width, height);
             }
         }
@@ -1184,6 +1257,32 @@ status_t ACodec::configureCodec(
     } else if (!strcmp("OMX.Nvidia.aac.decoder", mComponentName.c_str())) {
         err = setMinBufferSize(kPortIndexInput, 8192);  // XXX
     }
+    if(!strcmp(mComponentName.c_str(), ACTIONS_AUDIO_DECODER) )  
+    {
+      OMX_AUDIO_PARAM_PCMMODETYPE pcmParams;
+      InitOMXParams(&pcmParams);
+      pcmParams.nPortIndex = kPortIndexInput;
+      err = mOMX->getParameter(
+            mNode, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+      if (err != OK) {
+        return err;
+      }
+      int32_t numChannels, sampleRate;
+      msg->findInt32("channel-count", &numChannels);
+      msg->findInt32("sample-rate", &sampleRate);
+      ALOGE("*****************************%s  numChannels=%d sampleRate=%d", __FUNCTION__,pcmParams.nChannels, pcmParams.nSamplingRate);
+      ALOGE("numChannels=%d sampleRate=%d",numChannels,sampleRate);
+      if(numChannels>2) //澶т2澹伴蹇椤诲己琛逛负2澹伴
+      {
+                    ALOGE("numChannels must small than 2 \n");
+                    numChannels=2;                  
+       }
+       pcmParams.nSamplingRate=sampleRate;
+       pcmParams.nChannels=numChannels;
+       err = mOMX->setParameter(
+                        mNode, OMX_IndexParamAudioPcm, &pcmParams, sizeof(pcmParams));
+       ALOGE("*****************************\n");  
+    }
 
     return err;
 }
@@ -2335,26 +2434,45 @@ void ACodec::sendFormatChange() {
                 rect.nHeight = videoDef->nFrameHeight;
             }
 
-            CHECK_GE(rect.nLeft, 0);
-            CHECK_GE(rect.nTop, 0);
-            CHECK_GE(rect.nWidth, 0u);
-            CHECK_GE(rect.nHeight, 0u);
-            CHECK_LE(rect.nLeft + rect.nWidth - 1, videoDef->nFrameWidth);
-            CHECK_LE(rect.nTop + rect.nHeight - 1, videoDef->nFrameHeight);
-
-            notify->setRect(
-                    "crop",
-                    rect.nLeft,
-                    rect.nTop,
-                    rect.nLeft + rect.nWidth - 1,
-                    rect.nTop + rect.nHeight - 1);
+            if(!strcmp(mComponentName.c_str(), ACTIONS_VIDEO_DECODER)){                 
+                        notify->setRect(
+                            "crop",
+                            0, 0,
+                            video_display_w - 1,
+                            video_display_h - 1);
+                }
+                else
+                {
+
+                            CHECK_GE(rect.nLeft, 0);
+                            CHECK_GE(rect.nTop, 0);
+                            CHECK_GE(rect.nWidth, 0u);
+                            CHECK_GE(rect.nHeight, 0u);
+                            CHECK_LE(rect.nLeft + rect.nWidth - 1, videoDef->nFrameWidth);
+                            CHECK_LE(rect.nTop + rect.nHeight - 1, videoDef->nFrameHeight);
+                
+                            notify->setRect(
+                                    "crop",
+                                    rect.nLeft,
+                                    rect.nTop,
+                                    rect.nLeft + rect.nWidth - 1,
+                                    rect.nTop + rect.nHeight - 1);
+                }
 
             if (mNativeWindow != NULL) {
+                int32_t left, top, right, bottom;  //merge zh
+                notify->findRect(
+                        "crop",
+                        &left, &top, &right, &bottom);
+                        
                 android_native_rect_t crop;
-                crop.left = rect.nLeft;
-                crop.top = rect.nTop;
-                crop.right = rect.nLeft + rect.nWidth;
-                crop.bottom = rect.nTop + rect.nHeight;
+                crop.left = left;
+                                crop.top = top;
+                                crop.right = right + 1;
+                                crop.bottom = bottom + 1;
+                                ALOGD("decoder w %d h %d",videoDef->nFrameWidth,videoDef->nFrameHeight);
+                                ALOGD("display left %d, top %d, right %d, bottom %d",crop.left,crop.top,crop.right,crop.bottom);
+
 
                 CHECK_EQ(0, native_window_set_crop(
                             mNativeWindow.get(), &crop));
@@ -2857,6 +2975,7 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                 if (eos) {
                     flags |= OMX_BUFFERFLAG_EOS;
                 }
+                int32_t video_buffer_size = 0;
 
                 if (buffer != info->mData) {
                     ALOGV("[%s] Needs to copy input data for buffer %p. (%p != %p)",
@@ -2865,7 +2984,70 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                          buffer.get(), info->mData.get());
 
                     CHECK_LE(buffer->size(), info->mData->capacity());
-                    memcpy(info->mData->data(), buffer->data(), buffer->size());
+                    if (!strncasecmp("OMX.google",mCodec->mComponentName.c_str(), 10)
+                    ||!strcmp(ACTIONS_AUDIO_DECODER,mCodec->mComponentName.c_str())
+                    ||mCodec->mpeg4_special_data_flag == 1)
+                    {
+                        if(mCodec->mpeg4_special_data_flag == 1)
+                            {
+                                ALOGD("this is mpeg4 special pkt");
+                                mCodec->mpeg4_special_data_flag = 0;
+                                unsigned char *Vir_addr=(unsigned char *)(info->mData->data());
+                                memcpy(Vir_addr, buffer->data(), buffer->size());
+                        
+                                *(unsigned int *)(Vir_addr + 0) = 0;
+                                *(unsigned int *)(Vir_addr + 4) = 0;
+                                *(unsigned int *)(Vir_addr + 8) = mCodec->video_display_w;
+                                *(unsigned int *)(Vir_addr + 12) = mCodec->video_display_h;
+                                *(unsigned int *)(Vir_addr + 16) = 0;
+                                buffer->setRange(0,20);
+                                ALOGD("Vir_addr %x ====width %d height %d",Vir_addr,*(unsigned int *)(Vir_addr + 8),*(unsigned int *)(Vir_addr + 12));
+                                video_buffer_size = 20;
+                            }
+                            else
+                            {
+                                memcpy(info->mData->data(), buffer->data(), buffer->size());
+                            }
+                        
+                        ALOGV("ACodec buffer->data() %x, buffer->size() %d",buffer->data(), buffer->size());
+                    }
+                    else
+                    {
+
+                                                unsigned char *Vir_addr=(unsigned char *)(info->mData->data());
+                                                packet_header_t *packet_header = (packet_header_t *)Vir_addr;
+                                                packet_header->header_type = VIDEO_PACKET;
+                                                
+                                                packet_header->packet_ts = (int)(timeUs/1000);
+                                                packet_header->stream_end_flag = 0;
+                                                if(mCodec->mIsCodecNeedFlush==true){
+                                                        packet_header->seek_reset_flag = 1;
+                                                        mCodec->mIsCodecNeedFlush=false;
+                                                ALOGV("decoder need flush \n");
+                                                }else{
+                                                        packet_header->seek_reset_flag = 0;
+                                                }
+                                                
+                                                if(mCodec->special_data_cpy_flag == 1)
+                                                {
+                                                        packet_header->block_len = buffer->size() + mCodec->special_data->size();
+                                                        ALOGD("special_data %x special_data_len %d",mCodec->special_data->data(),mCodec->special_data->size());
+                                                        memcpy((Vir_addr + sizeof(packet_header_t)), mCodec->special_data->data(),mCodec->special_data->size());
+                                                        memcpy((Vir_addr + sizeof(packet_header_t) + mCodec->special_data->size()),buffer->data(), buffer->size());
+                                                        
+                                                        mCodec->special_data_cpy_flag = 0;
+                                                        video_buffer_size = buffer->size() + sizeof(packet_header_t)+ mCodec->special_data->size();
+                                                }
+                                                else
+                                                {
+                                                        packet_header->block_len = buffer->size();
+                                    memcpy((Vir_addr + sizeof(packet_header_t)), buffer->data(), buffer->size());
+                                    video_buffer_size = buffer->size() + sizeof(packet_header_t);
+                                }                           
+                        }
+
+                }else if(!strcmp(ACTIONS_VIDEO_DECODER,mCodec->mComponentName.c_str())){
+                                                                video_buffer_size=buffer->size();
                 }
 
                 if (flags & OMX_BUFFERFLAG_CODECCONFIG) {
@@ -2891,14 +3073,29 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                 mCodec->mBufferStats.add(timeUs, stats);
 #endif
 
-                CHECK_EQ(mCodec->mOMX->emptyBuffer(
-                            mCodec->mNode,
-                            bufferID,
-                            0,
-                            buffer->size(),
-                            flags,
-                            timeUs),
-                         (status_t)OK);
+                if (!strncasecmp("OMX.google",mCodec->mComponentName.c_str(), 10)
+                ||!strcmp(ACTIONS_AUDIO_DECODER,mCodec->mComponentName.c_str()))
+                {
+                        CHECK_EQ(mCodec->mOMX->emptyBuffer(
+                                    mCodec->mNode,
+                                    bufferID,
+                                    0,
+                                    buffer->size(),
+                                    flags,
+                                    timeUs),
+                                 (status_t)OK);
+                }
+                else
+                {
+                        CHECK_EQ(mCodec->mOMX->emptyBuffer(
+                                    mCodec->mNode,
+                                    bufferID,
+                                    0,
+                                    video_buffer_size,
+                                    flags,
+                                    timeUs),
+                                 (status_t)OK);
+               }
 
                 info->mStatus = BufferInfo::OWNED_BY_COMPONENT;
 
@@ -3006,7 +3203,7 @@ bool ACodec::BaseState::onOMXFillBufferDone(
     BufferInfo *info =
         mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
 
-    CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_COMPONENT);
+    //CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_COMPONENT);
 
     info->mStatus = BufferInfo::OWNED_BY_US;
 
@@ -3112,7 +3309,7 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
                     info->mGraphicBuffer.get(), -1)) == OK) {
             info->mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;
         } else {
-            mCodec->signalError(OMX_ErrorUndefined, err);
+            //mCodec->signalError(OMX_ErrorUndefined, err);
             info->mStatus = BufferInfo::OWNED_BY_US;
         }
     } else {
@@ -3362,6 +3559,40 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
     }
 
     mCodec->changeState(mCodec->mLoadedState);
+        mCodec->special_data_cpy_flag = 0;
+    if(!strcmp("video/avc",mime.c_str()))
+    {
+        mCodec->special_data = new ABuffer(2048);
+        
+        mCodec->special_data->setRange(0,0);
+        mCodec->special_data_cpy_flag = 0;        
+            
+            for (size_t i = 0;; ++i) 
+            {
+                sp<ABuffer> csd;
+                if (!msg->findBuffer(StringPrintf("csd-%d", i).c_str(), &csd)) {
+                    break;
+                }
+                ALOGD("----memcpy special_data addr:%x size:%d",csd->data(),csd->size());
+                
+                memcpy(mCodec->special_data->data() + mCodec->special_data->size(), csd->data(), csd->size());
+            mCodec->special_data->setRange(0, mCodec->special_data->size() + csd->size());
+            ALOGD("special_data->data() %x special_data->size() %d",mCodec->special_data->data(),mCodec->special_data->size());
+                mCodec->special_data_cpy_flag = 1;
+                
+                csd->meta()->setInt32("csd", false);
+                //csd.clear();
+        
+            }
+           
+    }
+    mCodec->mIsCodecNeedFlush = false;
+    mCodec->mpeg4_special_data_flag = 0;
+    if(!strcmp("video/mp4v-es",mime.c_str()))
+    {
+        ALOGD("in video/mp4v-es");
+        mCodec->mpeg4_special_data_flag = 1;
+    }
 
     return true;
 }
@@ -3600,7 +3831,78 @@ void ACodec::LoadedToIdleState::stateEntered() {
              "(error 0x%08x)",
              err);
 
-        mCodec->signalError(OMX_ErrorUndefined, err);
+        
+                         OMX_PARAM_PORTDEFINITIONTYPE def;
+        
+                InitOMXParams(&def);
+        
+                def.nPortIndex = kPortIndexOutput;
+        
+                          status_t err = mCodec->mOMX->getParameter(
+        
+                                mCodec->mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        
+        // Dequeue buffers and send them to OMX
+        
+                for (OMX_U32 i = 0; i < def.nBufferCountActual; i++) {
+        
+                        ANativeWindowBuffer *buf;
+        
+        //                err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf);
+        
+        //                if (err != 0) {
+        
+        //                        ALOGE("dequeueBuffer failed: %s (%d)", strerror(-err), -err);
+        
+        //                        break;
+        
+        //                }
+        
+         
+        
+                        sp<GraphicBuffer> graphicBuffer(new GraphicBuffer());
+        
+                        BufferInfo info;
+        
+                        info.mStatus = BufferInfo::OWNED_BY_US;
+        
+                        info.mData = new ABuffer(0);
+        
+                        info.mGraphicBuffer = graphicBuffer;
+        
+        //                mBuffers[kPortIndexOutput].push(info);
+        
+         
+        
+                        IOMX::buffer_id bufferId;
+        
+                        err = mCodec->mOMX->useGraphicBuffer(mCodec->mNode, kPortIndexOutput, graphicBuffer,
+        
+                                        &bufferId);
+        
+                        if (err != 0) {
+        
+                                ALOGE("registering GraphicBuffer %lu with OMX IL component failed: "
+        
+                                         "%d", i, err);
+        
+                                break;
+        
+                        }
+        
+         
+        
+        //                mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;
+        
+        //                ALOGD("[%s] Registered graphic buffer with ID %p (pointer = %p)",
+        
+        //                         mComponentName.c_str(),
+        
+        //                         bufferId, graphicBuffer.get());
+        
+                }
+        
+        mCodec->signalError(OMX_ErrorallocateBuffersFailed, OMX_ErrorallocateBuffersFailed);
 
         mCodec->changeState(mCodec->mLoadedState);
     }
@@ -3623,6 +3925,13 @@ bool ACodec::LoadedToIdleState::onMessageReceived(const sp<AMessage> &msg) {
             mCodec->deferMessage(msg);
             return true;
         }
+        case ACodec::kWhatFlush:
+        {
+            sp<AMessage> notify = mCodec->mNotify->dup();
+            notify->setInt32("what", ACodec::kWhatFlushCompleted);
+            notify->post();
+            return true;
+        }
 
         default:
             return BaseState::onMessageReceived(msg);
@@ -3668,6 +3977,13 @@ bool ACodec::IdleToExecutingState::onMessageReceived(const sp<AMessage> &msg) {
             mCodec->deferMessage(msg);
             return true;
         }
+        case kWhatFlush:
+        {
+            sp<AMessage> notify = mCodec->mNotify->dup();
+            notify->setInt32("what", ACodec::kWhatFlushCompleted);
+            notify->post();
+            return true;
+        }
 
         default:
             return BaseState::onMessageReceived(msg);
@@ -3799,6 +4115,9 @@ bool ACodec::ExecutingState::onMessageReceived(const sp<AMessage> &msg) {
             mCodec->changeState(mCodec->mFlushingState);
 
             handled = true;
+            if(!strcmp(mCodec->mComponentName.c_str(), ACTIONS_VIDEO_DECODER)){
+               mCodec->mIsCodecNeedFlush = true;
+            }
             break;
         }
 
@@ -3849,6 +4168,10 @@ bool ACodec::ExecutingState::onOMXEvent(
                             mCodec->mNode,
                             OMX_CommandPortDisable, kPortIndexOutput),
                         (status_t)OK);
+                
+                if(!strcmp(mCodec->mComponentName.c_str(), ACTIONS_VIDEO_DECODER)){
+                   usleep(20000);
+                }
 
                 mCodec->freeOutputBuffersNotOwnedByComponent();
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
diff --git a/media/libstagefright/ActAudioDecoder.cpp b/media/libstagefright/ActAudioDecoder.cpp
new file mode 100755
index 0000000..f675d37
--- /dev/null
+++ b/media/libstagefright/ActAudioDecoder.cpp
@@ -0,0 +1,553 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ActAudioDecoder"
+#include <utils/Log.h>
+
+#include "include/ActAudioDecoder.h"
+#include "include/ActAudioExtractor.h"
+
+#include<dlfcn.h>
+
+#include <media/stagefright/MediaBufferGroup.h>
+//#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+#define LIBPREFIX           "ad"
+#define LIBPOSTFIX          ".so"
+
+//#define DEBUG
+
+#define PP_MAXVALUE       0X7FFF
+#define DEFAULT_SAMPLES   8192
+#define DEFAULT_CHANNELS  2
+#define DEFAULT_FADETIME  600
+#define DEFAULT_MUTETIME  200
+#define MIN_FADETIME      50
+namespace android {
+
+ActAudioDecoder::ActAudioDecoder(const sp<MediaSource> &source) :
+	mSource(source), mLib_handle(NULL), mPlugin_handle(NULL), mDownMix(NULL),
+			mStarted(false), mBufferGroup(NULL),
+			mConfig(new tActAudioDecoderExternal), mAnchorTimeUs(0),
+			mNumFramesOutput(0), mNumOffsetOutput(0), mInputBuffer(NULL) {
+	init();
+}
+
+typedef int(*FuncPtr)(void);
+
+void ActAudioDecoder::init() {
+	sp < MetaData > srcFormat = mSource->getFormat();
+	const char *mime;
+	int32_t tmp = 0;
+	char libname[64] = LIBPREFIX;
+	FuncPtr func_handle;
+	memset(mConfig, 0, sizeof(tActAudioDecoderExternal));
+	CHECK(srcFormat->findInt32(kKeyChannelCount, &tmp));
+	CHECK(srcFormat->findInt32(kKeySampleRate, &mConfig->samplingRate));
+	CHECK(srcFormat->findCString(kKeyMIMEType, &mime));
+	if (srcFormat->findInt64(kKeyDriftTime, &mNumOffsetOutput)) {
+		mAnchorTimeUs = ((uint64_t) mNumOffsetOutput >> 32) * 1000;
+		mNumOffsetOutput = (uint64_t) mNumOffsetOutput & (uint64_t) 0xffffffff;
+		if (mNumOffsetOutput > 0) {
+			mNumOffsetOutput = mNumOffsetOutput
+					* (mConfig->samplingRate / 1000);
+		}
+	}
+
+	if (tmp > 2) {
+		ALOGE("mNumChannels %d", tmp);
+		tmp = 2;
+	}
+	mConfig->num_channels = (int16) tmp;
+	mMeta = new MetaData;
+	mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+	mMeta->setInt32(kKeyChannelCount, tmp);
+	mMeta->setInt32(kKeySampleRate, mConfig->samplingRate);
+
+	int64_t durationUs;
+	if (srcFormat->findInt64(kKeyDuration, &durationUs)) {
+		mMeta->setInt64(kKeyDuration, durationUs);
+		mConfig->total_time = durationUs / 1000000;
+	}
+	srcFormat->findInt64(kKeyDuration, &durationUs);
+	mMeta->setCString(kKeyDecoderComponent, "ActAudioDecoder");
+
+	strcat(libname, mime + sizeof("audio"));
+	strcat(libname, LIBPOSTFIX);
+
+	mLib_handle = dlopen(libname, RTLD_NOW);
+	ALOGD("ActAudioDecoder::init-mime:%s-libname: %s; handle:%x\n", mime,
+			libname, (int) mLib_handle);
+	if (mLib_handle == NULL) {
+		ALOGE("ActAudioDecoder::init-mime:%s-libname: %s; handle:%x\n", mime,
+				libname, (int) mLib_handle);
+		return;
+	}
+
+	func_handle = (FuncPtr) dlsym(mLib_handle, "get_plugin_info");
+	if (func_handle == NULL) {
+		ALOGE(" dlsym get_mPlugin_info Err;\n");
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+		return;
+	}
+	tmp = func_handle();
+	mPlugin_info = reinterpret_cast<audiodec_plugin_t *> (tmp);
+	if (mPlugin_info == NULL) {
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+		return;
+	}
+	mDownMix = downmix_open();
+	if (mDownMix == NULL) {
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+		return;
+	}
+}
+
+ActAudioDecoder::~ActAudioDecoder() {
+	if (mStarted) {
+		stop();
+	}
+	if (mDownMix != NULL) {
+		downmix_close( mDownMix);
+		mDownMix = NULL;
+	}
+
+	if (mPlugin_handle) {
+		mPlugin_info->close(mPlugin_handle);
+		mPlugin_handle = NULL;
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+	}
+
+	delete mConfig;
+	mConfig = NULL;
+	ALOGD("~ActAudioDecoder");
+}
+#ifdef DEBUG
+FILE *dec_fp = NULL;
+#endif
+
+status_t ActAudioDecoder::start(MetaData *params) {
+	CHECK(!mStarted);
+	if (mLib_handle == NULL) {
+		ALOGD("Err: Audio mLib_handle is NULL\n");
+		return ERROR_UNSUPPORTED;
+	}
+	ALOGV("ActAudioDecoder::start");
+	if (mConfig->samplingRate >= 96000) {
+		return ERROR_UNSUPPORTED;
+	}
+	sp < MetaData > srcFormat = mSource->getFormat();
+	void *init_buf = NULL;
+	srcFormat->findPointer(kKeyESDS, &init_buf);
+	mPlugin_handle = mPlugin_info->open(init_buf);
+	//void *info;
+	//srcFormat->findPointer(kKeyESDS, &info);
+	//mPlugin_handle = mPlugin_info->open(((music_info_t *)info)->buf);
+	
+	if (mPlugin_handle == NULL) {
+		ALOGD("Err: Audio mPlugin_handle is NULL\n");
+		return ERROR_UNSUPPORTED;
+	}
+
+#ifdef DEBUG
+	if (dec_fp != NULL) {
+		fclose( dec_fp);
+		dec_fp = NULL;
+	}
+	dec_fp = fopen("/data/tmp.pcm", "wb");
+	if (dec_fp == NULL) {
+		ALOGE("creat tmp file failed!");
+	}
+#endif
+	if (mConfig->total_time > 10) {
+		mConfig->fadeFlag = 1;
+		mConfig->fadeCur = 0;
+		mConfig->fadeNum = mConfig->samplingRate / 1000 * DEFAULT_FADETIME;
+		mConfig->muteNum = mConfig->samplingRate / 1000 * DEFAULT_MUTETIME;
+		mConfig->fadeStep = PP_MAXVALUE / mConfig->fadeNum;
+		if (mConfig->fadeStep < 1) {
+			mConfig->fadeStep = 1;
+			mConfig->fadeNum = mConfig->samplingRate;
+		}
+	}
+	mSource->start();
+
+	//mAnchorTimeUs = 0;
+	mNumFramesOutput = 0;
+	mStarted = true;
+
+	return OK;
+}
+
+status_t ActAudioDecoder::stop() {
+    ALOGE("==cz== ActAudioDecoder::stop");
+	CHECK( mStarted);
+
+	ALOGV("ActAudioDecoder::stop");
+	if (mInputBuffer) {
+		mInputBuffer->release();
+		mInputBuffer = NULL;
+	}
+#ifdef DEBUG
+	if (dec_fp != NULL) {
+		fclose( dec_fp);
+		dec_fp = NULL;
+	}
+#endif
+	//free(mPlugin_handle);
+	delete mBufferGroup;
+	mBufferGroup = NULL;
+
+	mSource->stop();
+
+	mStarted = false;
+
+	return OK;
+}
+
+sp<MetaData> ActAudioDecoder::getFormat() {
+	return mMeta;
+}
+static int post_sat(int acc, int post_max, int post_min) {
+	if (acc > post_max) {
+		acc = post_max;
+	} else if (acc < post_min) {
+		acc = post_min;
+	}
+	return acc;
+}
+
+static int mix_data(audiout_pcm_t *out, int16 *output,
+		downmix_state *dommix_str) {
+	int i = 0;
+	int16 *tmp_buf = output;
+	int16 fadecoef, fade_step = 0;
+	int *pl = (int *) out->pcm[0];
+	int *pr = (int *) out->pcm[1];
+	int sat_min = (int) (~0) << 15;
+	int sat_max = ~sat_min;
+
+	if (out->channels > 2) {
+		downmix_set(dommix_str, (downmix_int32 *) (out->pcm[0]),
+				(downmix_int32 *) (out->pcm[1]));
+		for (i = 0; i < out->channels; i++) {
+			downmix_run(dommix_str, (downmix_int32 *) (out->pcm[i]),
+					out->samples, i);
+		}
+	}
+
+	if (out->channels == 1) {
+		for (i = 0; i < out->samples; i++) {
+			*output++ = (short) post_sat((*pl++ >> out->frac_bits), sat_max,
+					sat_min);
+			//         *output++ =  (short)(*pl++ >> out->frac_bits);
+		}
+	} else {
+		for (i = 0; i < out->samples; i++) {
+			*output++ = (short) (post_sat((*pl++ >> out->frac_bits), sat_max,
+					sat_min));
+			*output++ = (short) (post_sat((*pr++ >> out->frac_bits), sat_max,
+					sat_min));
+		}
+	}
+	return 0;
+}
+
+inline int16 mult16(int16 a, int16 b) {
+	int i = a, j = b, k = 0;
+	short m;
+	k = i * j;
+	m = (short) (k >> 16);
+	return m;
+}
+
+static void fadeproc(tActAudioDecoderExternal *cfg, int32_t len) {
+	int16 *tmp_buf, *output;
+	tmp_buf = output = cfg->pOutputBuffer;
+	int i, fadecoef;
+	if (cfg->fadeFlag == 1) {
+		fadecoef = cfg->fadeCur * cfg->fadeStep;
+	} else {
+		fadecoef = PP_MAXVALUE + cfg->fadeCur * cfg->fadeStep;
+	}
+	ALOGV("fade %d %d %d %d %d", cfg->fadeFlag, cfg->fadeStep, cfg->fadeNum,
+			cfg->fadeCur, fadecoef);
+	if (cfg->num_channels == 1) {
+		for (i = 0; i < len; i++) {
+			if (cfg->muteNum > 0) {
+				*tmp_buf++ = 0;
+				cfg->muteNum--;
+			} else {
+				*tmp_buf++ = mult16(*output++, fadecoef);
+				fadecoef += cfg->fadeStep;
+				cfg->fadeCur++;
+				if (cfg->fadeCur >= cfg->fadeNum) {
+					if (cfg->fadeFlag == 1) {
+						cfg->fadeFlag = 0;
+						return;
+					} else {
+						*tmp_buf++ = 0;
+					}
+				}
+			}
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			if (cfg->muteNum > 0) {
+				*tmp_buf++ = 0;
+				*tmp_buf++ = 0;
+				cfg->muteNum--;
+			} else {
+				*tmp_buf++ = mult16(*output++, fadecoef);
+				*tmp_buf++ = mult16(*output++, fadecoef);
+				fadecoef += cfg->fadeStep;
+				cfg->fadeCur++;
+				if (cfg->fadeCur >= cfg->fadeNum) {
+					if (cfg->fadeFlag == 1) {
+						cfg->fadeFlag = 0;
+						return;
+					} else {
+						*tmp_buf++ = 0;
+						*tmp_buf++ = 0;
+					}
+				}
+			}
+		}
+	}
+}
+
+status_t ActAudioDecoder::read(MediaBuffer **out, const ReadOptions *options) {
+	status_t err;
+	int64_t seekTimeUs, timestamp;
+	ReadOptions::SeekMode mode;
+	MediaBuffer *buffer;
+	audiout_pcm_t pcmout;
+	int bytes_used = 0;
+	int ret = 0;
+	*out = NULL;
+
+	if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+		CHECK(seekTimeUs >= 0);
+		mNumFramesOutput = 0;
+		
+		ALOGE("============cz=====seekTimeUs=%lld",seekTimeUs);
+		
+		if ((mConfig->total_time > 5) && (mConfig->videoflag == 2)) {
+			mConfig->fadeFlag = 1; //set fadein
+			mConfig->fadeCur = 0;
+			mConfig->fadeNum = mConfig->samplingRate / 1000 * MIN_FADETIME;
+			mConfig->muteNum = mConfig->samplingRate / 1000 * DEFAULT_MUTETIME;
+			mConfig->fadeStep = PP_MAXVALUE / mConfig->fadeNum;
+		}
+		if (mInputBuffer) {
+			//            ALOGD("s %x",mInputBuffer);
+			mInputBuffer->release();
+			mInputBuffer = NULL;
+		}
+		// Make sure that the next buffer output does not still
+		// depend on fragments from the last one decoded.
+		mPlugin_info->ex_ops(mPlugin_handle, EX_OPS_CHUNK_RESET, 0);
+		mNumOffsetOutput = 0;
+	} else {
+		seekTimeUs = -1;
+	}
+
+	if (mInputBuffer == NULL) {
+		err = mSource->read(&mInputBuffer, options);
+		//        ALOGD("mSource->read %x",mInputBuffer);
+		if (err != OK) {
+			if (err == INFO_DISCONTINUITY) {
+				ALOGD("-----------audio received INFO_DISCONTINUITY");
+				if (mBufferGroup == NULL) {
+					mBufferGroup = new MediaBufferGroup;
+					mBufferGroup->add_buffer(
+							new MediaBuffer(
+									DEFAULT_CHANNELS * DEFAULT_SAMPLES
+											* sizeof(int16_t)));
+				}
+
+				CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+
+				buffer->set_range(0, 0);
+
+				mAnchorTimeUs = 0;
+				mNumFramesOutput = 0;
+				mPlugin_info->ex_ops(mPlugin_handle, EX_OPS_CHUNK_RESET, 0);
+				mNumOffsetOutput = 0;
+				buffer->meta_data()->setInt64(kKeyTime, 0);
+
+				*out = buffer;
+
+				return OK;
+			}
+			ALOGE("mSource->read(&mInputBuffer, options) err!!!");
+			return err;
+		} else {
+			mInputBuffer->meta_data()->findInt32(kKeyIsCodecConfig, &mConfig->videoflag);
+			if (mConfig->videoflag > 0) {
+				ALOGV("seek kKeyIsCodecConfig %d", mConfig->videoflag);;
+				mPlugin_info->ex_ops(mPlugin_handle, EX_OPS_CHUNK_RESET, 0);
+				if (mConfig->total_time > 5) {
+					mConfig->fadeFlag = 1; //set fadein
+					mConfig->fadeCur = 0;
+					mConfig->fadeNum = mConfig->samplingRate / 1000
+							* MIN_FADETIME;
+					mConfig->fadeStep = PP_MAXVALUE / mConfig->fadeNum;
+					mNumOffsetOutput = 0;
+				}
+			}
+		}
+
+		if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+			int64_t timeUs;
+			if (mInputBuffer->meta_data()->findInt64(kKeyTime, &timeUs)) {
+				if (((seekTimeUs - timeUs) > 2000000) || ((seekTimeUs - timeUs)
+						< -2000000)) {
+					ALOGW("audiodec-seek time: %lld %lld", timeUs, seekTimeUs);
+					timeUs = seekTimeUs;
+				}
+				mAnchorTimeUs = timeUs;
+				mNumFramesOutput = 0;
+			} else {
+				// We must have a new timestamp after seeking.
+				CHECK(seekTimeUs < 0);
+			}
+		}
+	}
+	mConfig->pInputBuffer = (uint8_t *) mInputBuffer->data()
+			+ mInputBuffer->range_offset();
+	mConfig->inputBufferCurrentLength = mInputBuffer->range_length();
+
+	mConfig->inputBufferUsedLength = 0;
+	mConfig->outputFrameSize = 0;
+	if (mConfig->inputBufferCurrentLength <= 0) {
+		ALOGW("AD input is null");
+		return OK;
+	}
+	/* TODO fixme */
+	ret = mPlugin_info->frame_decode(mPlugin_handle,
+			(char *) mConfig->pInputBuffer, mConfig->inputBufferCurrentLength,
+			&pcmout, &bytes_used);
+	//ALOGD("dec %d ",bytes_used);
+	if (ret < 0) {
+		ALOGE("decoder returned error %d", ret);
+		// This is recoverable, just ignore the current frame and
+		// play silence instead.
+		//        if( mBufferGroup != NULL)
+		//        {
+		//            CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+		//            mConfig->pOutputBuffer = static_cast<int16_t *>(buffer->data());
+		//            memset(buffer->data(), 0, buffer->size());
+		//            mConfig->inputBufferUsedLength = mInputBuffer->range_length();
+		//        }
+		return UNKNOWN_ERROR;
+
+	}
+
+	if (mBufferGroup == NULL) {
+		mBufferGroup = new MediaBufferGroup;
+		mBufferGroup->add_buffer(
+				new MediaBuffer(
+						DEFAULT_CHANNELS * DEFAULT_SAMPLES * sizeof(int16_t)));
+	}
+
+	CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+	int tmp1 = buffer->size();
+	int tmp2 = DEFAULT_CHANNELS * pcmout.samples * sizeof(int16_t);
+	if (tmp1 < tmp2) {
+		ALOGW("buf size is change o:%x n:%d %d", tmp1, tmp2, pcmout.channels);
+		buffer->release();
+		delete mBufferGroup;
+		mBufferGroup = new MediaBufferGroup;
+		mBufferGroup->add_buffer(new MediaBuffer(tmp2));
+		CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+	}
+	mConfig->pOutputBuffer = static_cast<int16_t *> (buffer->data());
+
+	mNumOffsetOutput -= pcmout.samples;
+	if ((mNumOffsetOutput > 0) || (pcmout.channels < 1) || (pcmout.samples < 1)) {
+		ALOGV("mix (ch:%d,samples:%d)", pcmout.channels, pcmout.samples);
+		pcmout.channels = 0;
+		pcmout.samples = 0;
+		goto out;
+	}
+
+	if ((pcmout.channels > mConfig->num_channels)
+			&& (mConfig->num_channels < 2)) {
+		pcmout.channels = mConfig->num_channels;
+	}
+
+	ret = mix_data(&pcmout, mConfig->pOutputBuffer, mDownMix);
+
+	if (mConfig->fadeFlag != 0) {
+		fadeproc(mConfig, pcmout.samples);
+	}
+
+	out: mConfig->outputFrameSize = pcmout.samples * mConfig->num_channels; //默认2声道; 16bit
+
+	if (bytes_used > mConfig->inputBufferCurrentLength) {
+		ALOGW("decoder maybe overflow u%d  i%d", bytes_used,
+				mConfig->inputBufferCurrentLength);
+		bytes_used = mConfig->inputBufferCurrentLength;
+	}
+	mConfig->inputBufferUsedLength = bytes_used;
+	mConfig->totalNumberOfBitsUsed += bytes_used << 3; //bit为单位
+	buffer->set_range(0, mConfig->outputFrameSize * sizeof(int16_t));
+	mInputBuffer->set_range(
+			mInputBuffer->range_offset() + mConfig->inputBufferUsedLength,
+			mInputBuffer->range_length() - mConfig->inputBufferUsedLength);
+
+	if (mInputBuffer->range_length() == 0) {
+		// ALOGD("d %x",mInputBuffer);
+		mInputBuffer->release();
+		mInputBuffer = NULL;
+	}
+	timestamp = mAnchorTimeUs + (mNumFramesOutput * 1000000)
+			/ mConfig->samplingRate;
+	int32_t tmptime = (int32_t)((timestamp + 1500000) / 1000000);
+//	if ((tmptime > 10) && (tmptime > mConfig->total_time) &&(mConfig->fadeFlag == 0)) {
+//		mConfig->fadeFlag = 2;
+//		mConfig->fadeCur = 0;
+//		mConfig->fadeNum = mConfig->samplingRate / 1000 * DEFAULT_FADETIME;
+//		mConfig->fadeStep = -PP_MAXVALUE / mConfig->fadeNum;
+//		if (mConfig->fadeStep == 0) {
+//			mConfig->fadeStep = -1;
+//			mConfig->fadeNum = mConfig->samplingRate;
+//		}
+//	}
+
+	buffer->meta_data()->setInt64(kKeyTime, timestamp);
+
+	mNumFramesOutput += mConfig->outputFrameSize / mConfig->num_channels;
+#ifdef DEBUG
+	if (dec_fp != NULL)
+	fwrite(mConfig->pOutputBuffer, 2, mConfig->outputFrameSize, dec_fp);
+#endif
+	*out = buffer;
+
+	return OK;
+}
+
+} // namespace android
diff --git a/media/libstagefright/ActAudioDownMix.cpp b/media/libstagefright/ActAudioDownMix.cpp
new file mode 100755
index 0000000..5d57eeb
--- /dev/null
+++ b/media/libstagefright/ActAudioDownMix.cpp
@@ -0,0 +1,466 @@
+/*	File: downmix_cz.c		$Revision:   1.0  $	*/
+
+/****************************************************************************
+ ;	File:	downmix_cz.c
+ ;	by chenzhan
+ ;
+ ;	History:
+ ;		2009/03/20		Created
+ ;***************************************************************************/
+#include "include/ActAudioDownMix.h"
+
+#ifdef DOWNMIX_BIT16
+
+downmix_int32 downmix_cmixtab[4]=
+{
+	23170, 19484, 16384, 19484
+};
+downmix_int32 downmix_surmixtab[4]=
+{
+	23170, 16384, 0, 16384
+};
+
+#endif
+
+#ifdef DOWNMIX_BIT24
+
+typedef __int64 downmix_int64;
+
+downmix_int32 downmix_cmixtab[4]=
+{
+	5931642, 4987896, 4194304, 4987896
+};
+
+downmix_int32 downmix_surmixtab[4]=
+{
+	5931642, 4194304, 0, 4194304
+};
+
+#endif
+
+#ifdef DOWNMIX_BIT32
+
+downmix_int32 downmix_cmixtab[4]=
+{
+	1518500352,1276901376,1073741824,1276901376
+};
+downmix_int32 downmix_surmixtab[4]=
+{
+	1518500352,1073741824,0,1073741824
+};
+
+#endif
+
+downmix_int16 downmix_active;//dowmmix系数是否溢出标识,溢出需要所有系数都减少
+
+downmix_int16 downmix_bufinu[DOWNMIX_NCHANS];//输出声道是否第一次downmix
+
+//downmix_int32 downmix_buf[DOWNMIX_NCHANS][DOWNMIX_N]; //运行domix后存放的数据buf,所有声道完后需要搬走
+
+downmix_int32 downmix_tab[DOWNMIX_NPCMCHANS][DOWNMIX_NPCMCHANS]; //domnmix各个声道系数表格
+
+#ifdef DOWNMIX_GNRNG
+downmix_int16 downmix_appgainrng[DOWNMIX_NCHANS];
+#endif
+
+downmix_int16 downmix_chantab[DOWNMIX_NACMOD][DOWNMIX_NPCMCHANS] = { {
+		DOWNMIX_LEFT, DOWNMIX_RGHT, DOWNMIX_LFE, DOWNMIX_NONE, DOWNMIX_NONE,
+		DOWNMIX_NONE }, /* 1+1 */
+{ DOWNMIX_CNTR, DOWNMIX_LFE, DOWNMIX_NONE, DOWNMIX_NONE, DOWNMIX_NONE,
+		DOWNMIX_NONE }, /* 1/0 */
+{ DOWNMIX_LEFT, DOWNMIX_RGHT, DOWNMIX_LFE, DOWNMIX_NONE, DOWNMIX_NONE,
+		DOWNMIX_NONE }, /* 2/0 */
+{ DOWNMIX_LEFT, DOWNMIX_CNTR, DOWNMIX_RGHT, DOWNMIX_LFE, DOWNMIX_NONE,
+		DOWNMIX_NONE }, /* 3/0 */
+{ DOWNMIX_LEFT, DOWNMIX_RGHT, DOWNMIX_MSUR, DOWNMIX_LFE, DOWNMIX_NONE,
+		DOWNMIX_NONE }, /* 2/1 */
+{ DOWNMIX_LEFT, DOWNMIX_CNTR, DOWNMIX_RGHT, DOWNMIX_MSUR, DOWNMIX_LFE,
+		DOWNMIX_NONE }, /* 3/1 */
+{ DOWNMIX_LEFT, DOWNMIX_RGHT, DOWNMIX_LSUR, DOWNMIX_RSUR, DOWNMIX_LFE,
+		DOWNMIX_NONE }, /* 2/2 */
+{ DOWNMIX_LEFT, DOWNMIX_CNTR, DOWNMIX_RGHT, DOWNMIX_LSUR, DOWNMIX_RSUR,
+		DOWNMIX_LFE }, /* AC3 5.1 3/2 */
+{ DOWNMIX_LEFT, DOWNMIX_RGHT, DOWNMIX_LFE, DOWNMIX_CNTR, DOWNMIX_LSUR,
+		DOWNMIX_RSUR } /* ACTIONS 5.1 3/2 */
+//	{DOWNMIX_CNTR,	DOWNMIX_LEFT,	DOWNMIX_RGHT,	DOWNMIX_LSUR,	DOWNMIX_RSUR,	DOWNMIX_LFE }	    /* AAC 5.1 3/2 */
+		};
+
+downmix_int16 downmix_nfront[DOWNMIX_NACMOD] = { 2, 1, 2, 3, 2, 3, 2, 3, 3 };
+
+downmix_int16 downmix_nrear[DOWNMIX_NACMOD] = { 0, 0, 0, 0, 1, 1, 2, 2, 2 };
+
+downmix_uint16 downmix_chane[DOWNMIX_NACMOD] = { 0xa000, 0x4000, 0xa000,
+		0xe000, 0xb000, 0xf000, 0xb800, 0xf800, 0xf800 };
+
+downmix_int16 downmix_chanary[DOWNMIX_NACMOD] = { 2, 1, 2, 3, 3, 4, 4, 5, 5 };
+
+downmix_state * downmix_open(void) {
+	downmix_state *downmix_ac3_str = NULL;
+
+	downmix_ac3_str
+			= (downmix_state *) downmix_malloc(sizeof(*downmix_ac3_str));
+
+	if (downmix_ac3_str == NULL) {
+		printf("downmix malloc fail \n");
+		return NULL;
+	}
+
+	downmix_memset(downmix_ac3_str, 0, sizeof(downmix_state));
+
+	return downmix_ac3_str;
+}
+
+downmix_int32 downmix_set(downmix_state *downmix_ac3_str,
+		downmix_int32 *downmix_buf_left, downmix_int32 *downmix_buf_right) {
+	/*by clp*/
+	downmix_int64 temp;
+	downmix_int32 temp_s;
+	downmix_int16 chan;
+	downmix_int32 inchan2_L2g, outchan2_L2g;
+
+	/*clp*/
+	downmix_int32 unity_L2g, m3db_L2g, m6db_L2g;
+	downmix_int64 rowsum_L2g;
+
+	/*downmix_int32 rowsum_L2g;*/
+	downmix_int32 cmixval_L2g, surmixval_L2g;
+
+	/*	downmix_int32 *exttabptr_L2g;*/
+	downmix_int16 infront_L2g, inrear_L2g, outfront_L2g, outrear_L2g;
+	downmix_uint16 inchane_L2g, outchane_L2g;
+
+	downmix_int16 acmod;
+	downmix_int16 outmod;
+
+	downmix_int16 cmixlev;
+	downmix_int16 surmixlev;
+	downmix_int16 lfeon;
+	downmix_int16 outlfe;
+	downmix_int16 dualmod;
+
+	downmix_int16 outDOWNMIX_NCHANS;
+	downmix_int16 downmix_active;
+
+#if 1
+
+	downmix_ac3_str->acmod = DOWNMIX_MODE32ACT; //输入编码模式0-8
+	downmix_ac3_str->outmod = DOWNMIX_MODE20; //输出PCM模式0-8
+	downmix_ac3_str->cmixlev = 1; //certer声道系数level
+	downmix_ac3_str->surmixlev = 1; //环绕声道系数level
+	downmix_ac3_str->lfeon = 1; //输入是否有低音声道
+	downmix_ac3_str->outlfe = 0; //输出是否有低音声道
+	downmix_ac3_str->dualmod = 0; //双声道输出模式 	dual mono downmix mode  4种模式
+
+	downmix_ac3_str->downmix_buf[0] = downmix_buf_left;
+	downmix_ac3_str->downmix_buf[1] = downmix_buf_right;
+#endif
+
+	acmod = downmix_ac3_str->acmod;
+	outmod = downmix_ac3_str->outmod;
+
+	cmixlev = downmix_ac3_str->cmixlev;
+	surmixlev = downmix_ac3_str->surmixlev;
+	lfeon = downmix_ac3_str->lfeon;
+	outlfe = downmix_ac3_str->outlfe;
+	dualmod = downmix_ac3_str->dualmod;
+
+	outDOWNMIX_NCHANS = (downmix_int16)(downmix_chanary[outmod] + outlfe); //确定输出声道数;
+
+	for (chan = 0; chan < DOWNMIX_NCHANS; chan++) {
+		downmix_bufinu[chan] = 0;
+	}
+
+	/*clp*/
+	unity_L2g = DOWNMIX_UNITY;
+	m3db_L2g = DOWNMIX_M3DB;
+	m6db_L2g = DOWNMIX_M6DB;
+
+	/*Clear downmix table */
+	for (outchan2_L2g = 0; outchan2_L2g < DOWNMIX_NPCMCHANS; outchan2_L2g++) {
+		for (inchan2_L2g = 0; inchan2_L2g < DOWNMIX_NPCMCHANS; inchan2_L2g++) {
+			downmix_tab[outchan2_L2g][inchan2_L2g] = 0;
+		}
+	}
+
+	/*Set up downmix parameters */
+
+	infront_L2g = downmix_nfront[acmod];
+	inrear_L2g = downmix_nrear[acmod];
+	inchane_L2g = downmix_chane[acmod];
+	outfront_L2g = downmix_nfront[outmod];
+	outrear_L2g = downmix_nrear[outmod];
+	outchane_L2g = downmix_chane[outmod];
+	cmixval_L2g = downmix_cmixtab[cmixlev];
+	surmixval_L2g = downmix_surmixtab[surmixlev];
+
+	/*If (acmod == 0), mix according to dualmod */
+
+	if (acmod == DOWNMIX_MODE11) {
+		if (outfront_L2g == 1) {
+			if (dualmod == DOWNMIX_DUAL_LEFTMONO) {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LEFT] = unity_L2g;
+			} else if (dualmod == DOWNMIX_DUAL_RGHTMONO) {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RGHT] = unity_L2g;
+			} else {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LEFT] = m6db_L2g;
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RGHT] = m6db_L2g;
+			}
+		} else if (outfront_L2g == 2) {
+			if (dualmod == DOWNMIX_DUAL_STEREO) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_LEFT] = unity_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_RGHT] = unity_L2g;
+			} else if (dualmod == DOWNMIX_DUAL_LEFTMONO) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_LEFT] = m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_LEFT] = m3db_L2g;
+			} else if (dualmod == DOWNMIX_DUAL_RGHTMONO) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_RGHT] = m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_RGHT] = m3db_L2g;
+			} else {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_LEFT] = m6db_L2g;
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_RGHT] = m6db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_LEFT] = m6db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_RGHT] = m6db_L2g;
+			}
+		} else {
+			if (dualmod == DOWNMIX_DUAL_STEREO) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_LEFT] = unity_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_RGHT] = unity_L2g;
+			} else if (dualmod == DOWNMIX_DUAL_LEFTMONO) {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LEFT] = unity_L2g;
+			} else if (dualmod == DOWNMIX_DUAL_RGHTMONO) {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RGHT] = unity_L2g;
+			} else {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LEFT] = m6db_L2g;
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RGHT] = m6db_L2g;
+			}
+		}
+	}
+	//非acmod=mode11模式
+	else {
+
+		/*	If input and output full bw chans exist, set diagonal term to unity_L2g */
+		for (chan = 0; chan < (DOWNMIX_NPCMCHANS - 1); chan++) {
+			if (inchane_L2g & outchane_L2g & 0x8000) {
+				downmix_tab[chan][chan] = unity_L2g;
+			}
+			inchane_L2g <<= 1;
+			outchane_L2g <<= 1;
+		}
+
+		/*	If (outmod == 0), mix for Dolby Surround compatibility */
+		if (outmod == 0) {
+			if (infront_L2g != 2) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_CNTR] = m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_CNTR] = m3db_L2g;
+			}
+			if (inrear_L2g == 1) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_MSUR] = -m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_MSUR] = m3db_L2g;
+			} else if (inrear_L2g == 2) {
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_LSUR] = -m3db_L2g;
+				downmix_tab[DOWNMIX_LEFT][DOWNMIX_RSUR] = -m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_LSUR] = m3db_L2g;
+				downmix_tab[DOWNMIX_RGHT][DOWNMIX_RSUR] = m3db_L2g;
+			}
+		} else if (outmod == DOWNMIX_MODE10) {
+
+			/*	If (outmod == 1), mix for mono compatibility */
+			if (infront_L2g != 1) {
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LEFT] = m3db_L2g;
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RGHT] = m3db_L2g;
+			}
+			if (infront_L2g == 3) {
+				temp = (downmix_int64) cmixval_L2g * (downmix_int64) m3db_L2g;
+
+				temp_s = (downmix_int32)(temp >> (DOWNMIX_BitNum_word - 1));
+				temp_s = DOWNMIX_MYLIMIT(temp_s, temp_s);
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_CNTR] = temp_s;
+			}
+			if (inrear_L2g == 1) {
+				/*clp*/
+				temp = (downmix_int64) surmixval_L2g * (downmix_int64) m3db_L2g;
+
+				temp_s = (downmix_int32)(temp >> (DOWNMIX_BitNum_word - 1));
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_MSUR] = temp_s;
+			} else if (inrear_L2g == 2) {
+				/*clp*/
+				temp = (downmix_int64) surmixval_L2g * (downmix_int64) m3db_L2g;
+
+				temp_s = (downmix_int32)(temp >> (DOWNMIX_BitNum_word - 1));
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_LSUR] = temp_s;
+				downmix_tab[DOWNMIX_CNTR][DOWNMIX_RSUR] = temp_s;
+			}
+		} else {
+
+			/*	If (outfront_L2g == 2) and (infront_L2g == 1), mix C => L/R with -3 dB gain */
+			/*	If (outfront_L2g == 2) and (infront_L2g == 3), mix C => L/R using cmixlev */
+			if (outfront_L2g == 2) {
+				if (infront_L2g == 1) {
+					downmix_tab[DOWNMIX_LEFT][DOWNMIX_CNTR] = m3db_L2g;
+					downmix_tab[DOWNMIX_RGHT][DOWNMIX_CNTR] = m3db_L2g;
+				} else if (infront_L2g == 3) {
+					downmix_tab[DOWNMIX_LEFT][DOWNMIX_CNTR] = cmixval_L2g;
+					downmix_tab[DOWNMIX_RGHT][DOWNMIX_CNTR] = cmixval_L2g;
+				}
+			}
+
+			/*	If (inrear_L2g == 1) and (outrear_L2g == 0), mix S => L/R using surmixlev - 3 dB */
+			/*	If (inrear_L2g == 1) and (outrear_L2g == 2), mix S => Ls/Rs with -3 dB gain */
+
+			if (inrear_L2g == 1) {
+				if (outrear_L2g == 0) {
+					/*clp*/
+					temp = (downmix_int64) surmixval_L2g
+							* (downmix_int64) m3db_L2g;
+
+					temp_s = (downmix_int32)(temp >> (DOWNMIX_BitNum_word - 1));
+					downmix_tab[DOWNMIX_LEFT][DOWNMIX_MSUR] = temp_s;
+					downmix_tab[DOWNMIX_RGHT][DOWNMIX_MSUR] = temp_s;
+				} else if (outrear_L2g == 2) {
+					downmix_tab[DOWNMIX_LSUR][DOWNMIX_MSUR] = m3db_L2g;
+					downmix_tab[DOWNMIX_RSUR][DOWNMIX_MSUR] = m3db_L2g;
+				}
+			}
+
+			/*	If (inrear_L2g == 2) and (outrear_L2g == 0), mix Ls => L and Rs => R using
+			 surmixlev */
+			/*	If (inrear_L2g == 2) and (outrear_L2g == 1), mix Ls/Rs => S with -3 dB gain */
+
+			else if (inrear_L2g == 2) {
+				if (outrear_L2g == 0) {
+					downmix_tab[DOWNMIX_LEFT][DOWNMIX_LSUR] = surmixval_L2g;
+					downmix_tab[DOWNMIX_RGHT][DOWNMIX_RSUR] = surmixval_L2g;
+				} else if (outrear_L2g == 1) {
+					downmix_tab[DOWNMIX_MSUR][DOWNMIX_LSUR] = m3db_L2g;
+					downmix_tab[DOWNMIX_MSUR][DOWNMIX_RSUR] = m3db_L2g;
+				}
+			}
+		}
+	}
+
+	if (lfeon && outlfe) {
+		downmix_tab[DOWNMIX_LFE][DOWNMIX_LFE] = unity_L2g;
+	}
+
+	/*	Determine if downmixing is active */
+	downmix_active = 0;
+	/*clp*/
+	for (outchan2_L2g = 0; outchan2_L2g < DOWNMIX_NPCMCHANS; outchan2_L2g++) {
+		rowsum_L2g = 0;
+		for (inchan2_L2g = 0; inchan2_L2g < DOWNMIX_NPCMCHANS; inchan2_L2g++) {
+			rowsum_L2g += downmix_abs(downmix_tab[outchan2_L2g][inchan2_L2g]);
+			if ((rowsum_L2g - 1) > DOWNMIX_UNITY) {
+				downmix_active = 1;
+			}
+		}
+	}
+
+	if (downmix_active == 1) //是否有溢出，溢出需要减少次数
+	{
+		//以后再补充
+
+	}
+
+	return 0;
+
+}
+
+downmix_int32 downmix_run(downmix_state *dommix_str, downmix_int32 *tcbuf,
+		downmix_int32 frame_len, downmix_int32 channum) //channum 输入声道标号
+{
+	downmix_int16 chan, count;
+	downmix_int64 temp;
+	downmix_int32 *tcptr_L2g, *dnmixptr_L2g, dnmixfac_L2g;
+	downmix_int16 inchan2_L2g, outchan2_L2g;
+
+	downmix_int16 acmod = dommix_str->acmod;
+	downmix_int16 outmod = dommix_str->outmod;
+	downmix_int16 outDOWNMIX_NCHANS = (downmix_int16)(
+			downmix_chanary[dommix_str->outmod] + (dommix_str->outlfe)); //确定输出声道数;
+
+	/*	Do downmixing */
+	inchan2_L2g = downmix_chantab[acmod][channum];
+
+	for (chan = 0; chan < outDOWNMIX_NCHANS; chan++) {
+		outchan2_L2g = downmix_chantab[outmod][chan];
+		/*by wang*/
+#ifdef DOWNMIX_GNRNG
+		dnmixfac_L2g = downmix_tab[outchan2_L2g][inchan2_L2g] >> downmix_appgainrng[channum];
+#else
+		dnmixfac_L2g = downmix_tab[outchan2_L2g][inchan2_L2g];
+#endif
+
+		/*by wang*/
+		if (dnmixfac_L2g != 0) {
+			dnmixptr_L2g = dommix_str->downmix_buf[chan];
+			tcptr_L2g = tcbuf;
+			if (dnmixfac_L2g == DOWNMIX_UNITY) {
+				if (downmix_bufinu[chan] == 0) {
+					for (count = 0; count < frame_len; count++) {
+						*dnmixptr_L2g++ = *tcptr_L2g++;
+					}
+				} else {
+					for (count = 0; count < frame_len; count++) {
+#ifdef XIELIMIT
+						*dnmixptr_L2g=DOWNMIX_MYLIMIT((*tcptr_L2g),+(*dnmixptr_L2g));
+#else
+						*dnmixptr_L2g = (*tcptr_L2g) + (*dnmixptr_L2g);
+#endif
+						tcptr_L2g++;
+						dnmixptr_L2g++;
+					}
+				}
+			} else {
+				if (downmix_bufinu[chan] == 0) {
+					for (count = 0; count < frame_len; count++) {
+#if 1
+						/*by wang*/
+						temp = (downmix_int64)(*tcptr_L2g++)
+								* (downmix_int64) dnmixfac_L2g;
+
+						*dnmixptr_L2g++ = (downmix_int32)(
+								temp >> (DOWNMIX_BitNum_word - 1));
+#else
+						__asm__ __volatile("mult %1,%0" : :"d" (*tcptr_L2g), "d" (dnmixfac_L2g):"memory");
+						__asm__ __volatile("mfhi %0":"=r" (temp)::"memory");
+						*dnmixptr_L2g=temp<<1;
+						tcptr_L2g++;
+						dnmixptr_L2g++;
+#endif
+					}
+				} else {
+					for (count = 0; count < frame_len; count++) {
+						/*by wang*/
+#if 1
+						temp = (downmix_int64)(*tcptr_L2g++)
+								* (downmix_int64) dnmixfac_L2g;
+
+#ifdef XIELIMIT
+						temp=(temp>>(DOWNMIX_BitNum_word-1));
+						*dnmixptr_L2g=DOWNMIX_MYLIMIT(temp,(*dnmixptr_L2g));
+#else
+						*dnmixptr_L2g = (downmix_int32)(
+								temp >> (DOWNMIX_BitNum_word - 1))
+								+ (*dnmixptr_L2g);
+#endif
+#else
+						__asm__ __volatile("mult %1,%0" : :"d" (*tcptr_L2g), "d" (dnmixfac_L2g):"memory");
+						__asm__ __volatile("mfhi %0":"=r" (temp)::"memory");
+						*dnmixptr_L2g=(temp<<1)+*dnmixptr_L2g;
+						tcptr_L2g++;
+#endif
+						dnmixptr_L2g++;
+					}
+				}
+			}
+			downmix_bufinu[chan] = 1;
+		}
+	}
+
+	return 0;
+}
+
+downmix_int32 downmix_close(downmix_state *dommix_str) {
+	downmix_free(dommix_str);
+	return 0;
+}
diff --git a/media/libstagefright/ActAudioEncoder.cpp b/media/libstagefright/ActAudioEncoder.cpp
new file mode 100755
index 0000000..b4249a5
--- /dev/null
+++ b/media/libstagefright/ActAudioEncoder.cpp
@@ -0,0 +1,430 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ActAudioEncoder"
+#include <utils/Log.h>
+
+
+#define FRAG_NUM 6
+#include "include/ActAudioEncoder.h"
+
+#include<dlfcn.h>
+
+#include <media/stagefright/MediaBufferGroup.h>
+//#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+
+//#define WRITE_ENCODED_DATA
+//#define WRITE_INPUT_PCM
+
+#ifdef WRITE_ENCODED_DATA
+FILE * fpOut = NULL;
+#endif
+
+#ifdef WRITE_INPUT_PCM
+FILE * fpInPut = NULL;
+#endif
+
+
+#define LIBPREFIX           "ae"
+#define LIBPOSTFIX          ".so"
+namespace android {
+
+ActAudioEncoder::ActAudioEncoder(const sp<MediaSource> &source,
+		const sp<MetaData> &meta) :
+	mSource(source), mMeta(meta), mStarted(false), mBufferGroup(NULL),
+			mInputBuffer(NULL), mLib_handle(NULL), mPlugin_info(NULL) {
+}
+typedef int(*FuncPtr)(void);
+status_t ActAudioEncoder::initCheck() {
+	char* headerbuf;
+	int header_len;
+	const char *mime;
+	char libname[64] = LIBPREFIX;
+	int tmp = 0;
+	FuncPtr func_handle;
+	enc_audio_t enc_audio;
+	audioenc_attribute_t attribute;
+	CHECK(mMeta->findInt32(kKeySampleRate, &mSampleRate));
+	CHECK(mMeta->findInt32(kKeyChannelCount, &mChannels));
+	CHECK(mMeta->findInt32(kKeyBitRate, &mBitRate));
+	mBitRate = mBitRate / 1000;
+	CHECK(mMeta->findCString(kKeyMIMEType, &mime));
+
+	if (strcmp(mime, "ADPCM") == 0) {
+		strcat(libname, "WAV");
+		enc_audio.audio_format = 1;
+	} else {
+		strcat(libname, mime);
+		enc_audio.audio_format = 0;
+	}
+	ALOGV("AE %s s:%d ch:%d% %d;", mime, mSampleRate, mChannels, mBitRate);
+	strcat(libname, LIBPOSTFIX);
+
+	mLib_handle = dlopen(libname, RTLD_NOW);
+	ALOGV("ActAudioEncoder::init-mime:%s-libname: %s; handle:%x\n", mime,libname, (int) mLib_handle);
+	if (mLib_handle == NULL) {
+		ALOGE("ActAudioEncoder dlopen Err: libname: %s;\n", libname);
+		return UNKNOWN_ERROR;
+	}
+	func_handle = (FuncPtr) dlsym(mLib_handle, "get_plugin_info");
+	if (func_handle == NULL) {
+		ALOGE("ActAudioEncoder dlsym get_mPlugin_info Err;\n");
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		return UNKNOWN_ERROR;
+	}
+	tmp = func_handle();
+	mPlugin_info = reinterpret_cast<audioenc_plugin_t *> (tmp);
+	if (mPlugin_info == NULL) {
+		ALOGE("ActAudioEncoder get_mPlugin_info Err;\n");
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		return UNKNOWN_ERROR;
+	}
+	// Configure Actions encoder$
+	enc_audio.sample_rate = mSampleRate;
+	enc_audio.bitrate = mBitRate;
+	enc_audio.channels = mChannels;
+	enc_audio.chunk_time = 150;
+	mPlugin_handle = mPlugin_info->open(&enc_audio);
+	if (mPlugin_handle == NULL) {
+		ALOGE("%s: open encoder fail\n", __FILE__);
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		mPlugin_info = NULL;
+		return UNKNOWN_ERROR;
+	}
+
+	tmp = mPlugin_info->get_attribute(mPlugin_handle, &attribute);
+	if (tmp < 0) {
+		ALOGE("%s: get_attribute fail\n", __FILE__);
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		mPlugin_info = NULL;
+		return UNKNOWN_ERROR;
+	}
+	ALOGV("AE_init, chunk_size = %#X, samples_per_frame = %#X\n",attribute.chunk_size, attribute.samples_per_frame);
+	mNumSamplesPerFrame = attribute.samples_per_frame;
+	mInput.pcm[0] = (int) malloc(sizeof(int16_t) * mNumSamplesPerFrame);
+	mInput.pcm[1] = (int) malloc(sizeof(int16_t) * mNumSamplesPerFrame);
+	mInput.samples = 0;
+	mInput.channels = mChannels;
+
+	memset((void *) mInput.pcm[0], 0, mNumSamplesPerFrame * 2);
+	memset((void *) mInput.pcm[1], 0, mNumSamplesPerFrame * 2);
+
+	mBufferGroup = new MediaBufferGroup;
+	if (attribute.chunk_size > 0) {
+		mBufferGroup->add_buffer(new MediaBuffer(attribute.chunk_size));
+	} else {
+		mBufferGroup->add_buffer(new MediaBuffer(20480));
+	}
+
+	mPlugin_info->update_header(mPlugin_handle, &headerbuf, &header_len);
+	mMeta->setData(kKeyIsCodecConfig, 0, (const void *) headerbuf, header_len);
+	mMeta->findInt32(kKeyIsUnreadable, &header_len);
+
+#ifdef WRITE_ENCODED_DATA
+	if (fpOut == NULL)
+	{
+		fpOut = fopen("/data/cz/out.mp3","wb");	
+		if (fpOut == NULL)
+		{
+			ALOGE("open output file failed");
+		}
+	}
+#endif
+
+#ifdef WRITE_INPUT_PCM
+	if (fpInPut == NULL)
+	{
+		fpInPut = fopen("/data/cz/input.pcm","wb");	
+		if (fpInPut == NULL)
+		{
+			ALOGE("open input file failed");
+		}
+	}
+#endif
+
+
+	return OK;
+}
+
+ActAudioEncoder::~ActAudioEncoder() {
+	if (mStarted) {
+		ALOGV("ActAudioEncoder::~ActAudioEncoder %d  ", __LINE__);
+		stop();
+	}
+	
+#ifdef WRITE_ENCODED_DATA
+	if (fpOut )
+	{
+		fclose(fpOut);
+		fpOut = NULL;
+	}
+#endif
+
+#ifdef WRITE_INPUT_PCM
+	if (fpInPut)
+	{
+		fclose(fpInPut);
+		fpInPut = NULL;
+	}
+#endif
+
+	
+}
+
+status_t ActAudioEncoder::start(MetaData *params) {
+	if (mStarted) {
+		ALOGD("Call start() when encoder already started");
+		return OK;
+	}
+	CHECK_EQ((status_t)OK, initCheck());
+
+	ALOGD("start() mNumInputSamples is zero");
+	mNumInputSamples = 0;
+	mAnchorTimeUs = 0;
+	mFrameCount = 0;
+	mSource->start(params);
+	mStarted = true;
+	return OK;
+}
+
+status_t ActAudioEncoder::stop() {
+	if (!mStarted) {
+		ALOGW("Call stop() when encoder has not started");
+		return OK;
+	}
+	ALOGD("ActAudioEncoder stop()");
+
+	if (mInputBuffer) {
+		mInputBuffer->release();
+		mInputBuffer = NULL;
+	}
+
+	delete mBufferGroup;
+	mBufferGroup = NULL;
+	free((void *) mInput.pcm[0]);
+	free((void *) mInput.pcm[1]);
+
+	mSource->stop();
+	if (mPlugin_handle) {
+		mPlugin_info->close(mPlugin_handle);
+		mPlugin_handle = NULL;
+	}
+	if (mLib_handle) {
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+	}
+	mStarted = false;
+
+	return OK;
+}
+
+sp<MetaData> ActAudioEncoder::getFormat() {
+	sp < MetaData > srcFormat = mSource->getFormat();
+
+	int64_t durationUs;
+	if (srcFormat->findInt64(kKeyDuration, &durationUs)) {
+		mMeta->setInt64(kKeyDuration, durationUs);
+	}
+
+	mMeta->setCString(kKeyDecoderComponent, "ActAudioEncoder");
+
+	return mMeta;
+}
+
+status_t ActAudioEncoder::read(MediaBuffer **out, const ReadOptions *options) {
+	status_t err;
+	int32_t isCodecConfig = 0, i = 0, copy_num = 0;
+	size_t copy = 0;
+	uint16_t *inl = (uint16_t *) mInput.pcm[0];
+	uint16_t *inr = (uint16_t *) mInput.pcm[1];
+	*out = NULL;
+	mMeta->findInt32(kKeyIsUnreadable, &isCodecConfig);
+	if (isCodecConfig == 1) {
+		char* headerbuf;
+		int header_len;
+		mPlugin_info->update_header(mPlugin_handle, &headerbuf, &header_len);
+		mMeta->setData(kKeyIsCodecConfig, 0, (const void *) headerbuf,
+				header_len);
+		mMeta->setInt32(kKeyIsUnreadable, 2);
+		ALOGE("ActAudioEncoder: header updata OK");
+		return OK;
+	}
+	int64_t seekTimeUs;
+	int bytes_used;
+	ReadOptions::SeekMode mode;
+	CHECK(options == NULL || !options->getSeekTo(&seekTimeUs, &mode));
+
+	MediaBuffer *buffer;
+	CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+	uint8_t *outPtr = (uint8_t *) buffer->data();
+	bool readFromSource = false;
+	int64_t wallClockTimeUs = -1;
+
+	bytes_used = 0;
+	//while(bytes_used == 0)
+	{
+		while (mNumInputSamples < mNumSamplesPerFrame) {
+			//ALOGV("audio encoder read: mNumInputSamples = %d, mNunSamplesPerFrame = %d",mNumInputSamples,mNumSamplesPerFrame);
+
+			if (mInputBuffer == NULL) {
+				if (mSource->read(&mInputBuffer, options) != OK) {
+					ALOGE("read err");
+					if (mNumInputSamples == 0) {
+						buffer->release();
+						return ERROR_END_OF_STREAM;
+					}
+					memset(
+							&inl[mNumInputSamples],
+							0,
+							sizeof(int16_t) * (mNumSamplesPerFrame
+									- mNumInputSamples));
+					memset(
+							&inr[mNumInputSamples],
+							0,
+							sizeof(int16_t) * (mNumSamplesPerFrame
+									- mNumInputSamples));
+					mNumInputSamples = 0;
+					break;
+				}
+
+				ALOGV("audio encoder read successfully");
+
+				size_t align = mInputBuffer->range_length() % sizeof(int16_t);
+				CHECK_EQ(align, 0);
+
+				int64_t timeUs;
+				if (mInputBuffer->meta_data()->findInt64(kKeyDriftTime, &timeUs)) {
+					wallClockTimeUs = timeUs;
+				}
+				if (mInputBuffer->meta_data()->findInt64(kKeyAnchorTime, &timeUs)) {
+					mAnchorTimeUs = timeUs;
+				}
+				readFromSource = true;
+			} else {
+				readFromSource = false;
+			}
+			copy = (mNumSamplesPerFrame - mNumInputSamples) * sizeof(int16_t)
+					* mChannels;
+
+			if (copy > mInputBuffer->range_length()) {
+				copy = mInputBuffer->range_length();
+			}
+
+			//ALOGV("audio encoder read: copy = %d",copy);
+
+			copy_num = copy / (sizeof(int16_t) * mChannels);
+			if (mChannels == 1) {
+				//memcpy((void*) mInput.pcm[mNumInputSamples], mInputBuffer->data(),
+				//		copy);
+				
+				 uint16_t *tmp = (uint16_t *) (mInputBuffer->data()+mInputBuffer->range_offset());
+				for (i = 0; i < copy_num; i++)
+				{
+					    inl[i + mNumInputSamples] = tmp[i] ;
+				}		
+			} else {
+				uint16_t *tmp = (uint16_t *) (mInputBuffer->data()
+						+ mInputBuffer->range_offset());
+				for (i = 0; i < copy_num; i++) {
+					inl[i + mNumInputSamples] = tmp[2 * i] ;
+					inr[i + mNumInputSamples] = tmp[2 * i + 1];
+				}
+			}
+
+			mInput.samples += copy_num;
+
+			ALOGV("audio encoder read, range_offset = %d, range_offset + copy = %d, range_length = %d, range_length - copy = %d",
+				mInputBuffer->range_offset(),mInputBuffer->range_offset() + copy,mInputBuffer->range_length() ,mInputBuffer->range_length() - copy);
+			mInputBuffer->set_range(mInputBuffer->range_offset() + copy,
+					mInputBuffer->range_length() - copy);
+
+			if (mInputBuffer->range_length() == 0) {
+				ALOGV("release mIput buffer");
+				mInputBuffer->release();
+				mInputBuffer = NULL;
+			}
+			mNumInputSamples += copy_num;
+			if (mNumInputSamples >= mNumSamplesPerFrame) {
+				mNumInputSamples %= mNumSamplesPerFrame;
+				break;
+			}
+		}
+
+
+#ifdef WRITE_INPUT_PCM
+		if (fpInPut)
+		{
+			
+			for (i = 0; i < mInput.samples ; i++) {				
+				fwrite(&inl[i],1,2,fpInPut);
+				fwrite(&inr[i],1,2,fpInPut);
+			}	
+		}
+#endif
+		mPlugin_info->frame_encode(mPlugin_handle, &mInput, (char *) outPtr,
+				&bytes_used);
+		ALOGV("audio encoder read: samples = %d, bytes_used = %d, FrameCount = %d",mInput.samples, bytes_used,mFrameCount);
+		//ALOGE("========sampels=%d",mFrameCount*mNumSamplesPerFrame);
+		mInput.samples = 0;
+		buffer->set_range(0, bytes_used);
+		++mFrameCount;
+	}
+
+#ifdef WRITE_ENCODED_DATA
+	if (fpOut)
+	{
+		fwrite(outPtr,1,bytes_used,fpOut);
+	}
+#endif
+
+	int64_t mediaTimeUs = ((mFrameCount - 1) * 1000000LL * mNumSamplesPerFrame)
+			/ mSampleRate;
+	if (mFrameCount % 500 == 0) {
+	    /*
+		ALOGD("ENC time stamp: %lld  %lld  %lld", mediaTimeUs, mAnchorTimeUs,
+				mAnchorTimeUs + mediaTimeUs);
+        ALOGD("====cz====mediaTimeUs= %f  mAnchorTimeUs=%f  mAnchorTimeUs + mediaTimeUs=%f", mediaTimeUs/1000000.0, mAnchorTimeUs/1000000.0,
+				(mAnchorTimeUs + mediaTimeUs)/1000000.0);
+		*/		
+	}
+	buffer->meta_data()->setInt64(kKeyTime, mAnchorTimeUs + mediaTimeUs);
+	if (readFromSource && wallClockTimeUs != -1) {
+		buffer->meta_data()->setInt64(kKeyDriftTime,
+				mediaTimeUs - wallClockTimeUs);
+	}
+
+	*out = buffer;
+	return OK;
+}
+
+} // namespace android
diff --git a/media/libstagefright/ActAudioExtractor.cpp b/media/libstagefright/ActAudioExtractor.cpp
new file mode 100755
index 0000000..3f187c0
--- /dev/null
+++ b/media/libstagefright/ActAudioExtractor.cpp
@@ -0,0 +1,515 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "ActAudioExtractor"
+
+#include <utils/Log.h>
+#include<dlfcn.h>
+#include "include/ActAudioExtractor.h"
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaBufferGroup.h>
+//#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <utils/String8.h>
+
+#include <ActDataSource.h>
+
+#define LIBPREFIX           "ap"
+#define LIBPOSTFIX          ".so"
+#define DEFAULT_MAX_CHUNK_SIZE		(50*1024)
+
+namespace android {
+
+class ActAudioSource : public MediaSource {
+public:
+    ActAudioSource(const sp<MetaData> &meta, const sp<ActAudioExtractor> &extractor);
+
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options = NULL);
+
+protected:
+    virtual ~ActAudioSource();
+
+private:
+
+    sp<ActAudioExtractor> mExtractor;
+    sp<MetaData> mMeta;
+    size_t mFrameSize;
+
+    off_t mOffset;
+    int64_t mCurrentTimeUs;
+    bool mStarted;
+    MediaBufferGroup *mGroup;
+
+    ActAudioSource(const ActAudioSource &);
+    ActAudioSource &operator=(const ActAudioSource &);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+
+typedef int(*FuncPtr)(void);
+ActAudioExtractor::ActAudioExtractor(const sp<DataSource>& source, const char *mime)
+    : mDataSource(source),
+      mInitCheck(NO_INIT) {
+    char libname[64] = LIBPREFIX;
+    int tmp = 0;
+    FuncPtr func_handle;    
+    mPlugin_handle = NULL;
+    
+    mInput = create_storage_io();
+    if(mInput == NULL) {
+        ALOGE("ActAudioExtractor create_storage_io Err;\n");
+        return;
+    }
+    init_storage_io(mInput, mDataSource);
+
+    strcat(libname, mime);
+    strcat(libname, LIBPOSTFIX);
+
+    mLib_handle = dlopen(libname, RTLD_NOW);
+    if (mLib_handle == NULL){
+        ALOGE("ActAudioExtractor dlopen Err: libname: %s;\n", libname);
+        return;
+    }
+    func_handle = (FuncPtr) dlsym(mLib_handle, "get_plugin_info");
+    if (func_handle == NULL){
+        ALOGE("ActAudioExtractor dlsym get_plugin_info Err;\n");
+       if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+        return;
+    }
+    tmp = func_handle();
+    mPlugin_info = reinterpret_cast<music_parser_plugin_t *>(tmp);
+    if (mPlugin_info == NULL){
+        ALOGE("ActAudioExtractor get_plugin_info Err;\n");
+        if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+        return;
+    }
+
+    mPlugin_handle = mPlugin_info->open(mInput);
+    if (mPlugin_handle == NULL) {
+        ALOGE("ActAudioExtractor: open parser fail\n");
+        if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+        return;
+    }
+    music_info_t info;
+    tmp = mPlugin_info->parser_header(mPlugin_handle, &info);
+    if (tmp){// has some error
+    	ALOGE("ActAudioExtractor: parser_header failed, ret = %d",tmp);
+		mPlugin_info->close(mPlugin_handle);
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		mPlugin_handle = NULL;
+		return;
+    }
+
+    mMeta = new MetaData;
+    char mime_type[32] = "audio/";
+    strcat(mime_type, info.extension);
+    mMeta->setCString(kKeyMIMEType, mime_type);
+    
+    int64_t total_time = (int64_t)info.total_time*1000000;
+    if(memcmp(info.extension, PARSER_EXT_MP3, 3) == 0) {
+        int resi_time = 0;
+        mPlugin_info->ex_ops(mPlugin_handle, EX_OPS_GET_RESTIME, (int)&resi_time);
+        total_time += (int64_t)resi_time*1000;
+    }
+    if(total_time<0) //cz_20121024 OGG一些按键音总时间为零，需要规避过去
+    {
+     ALOGE("ActAudioExtractor: total_time erro total_time = %lld",total_time);
+	 mPlugin_info->close(mPlugin_handle);
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		mPlugin_handle = NULL;
+		return;          
+    }
+    
+    if(total_time==0)
+    {
+      ALOGE("ActAudioExtractor: total_time zero = %lld",total_time);//cz_20121106 为了第三方APK许多零时间WAV文件，需要强行多加0.5s
+      total_time=500000;  
+    }
+    mMeta->setInt32(kKeyChannelCount, info.channels);
+    mMeta->setInt32(kKeySampleRate, info.sample_rate);
+    mMeta->setInt32(kKeyBitRate, (info.avg_bitrate)*1000);//cz_20120905为了与原生一致，需要乘1000输出
+
+    info.max_chunksize = (info.max_chunksize > DEFAULT_MAX_CHUNK_SIZE) ? info.max_chunksize : DEFAULT_MAX_CHUNK_SIZE;
+    mMeta->setInt32(kKeyMaxInputSize, info.max_chunksize);
+    mMeta->setInt64(kKeyDuration, total_time);
+    mMeta->setPointer(kKeyESDS, info.buf);
+    memcpy(&m_ai, &info, sizeof(music_info_t));
+    strcpy(m_ai.extension, mime);
+    ALOGE("ActAudioExtractor::inbuf: %x  mime %s  %s max_chunksize: %d channels: %d sample_rate %d total_time=%lld\n",(int) info.buf,mime_type, info.extension, info.max_chunksize,info.channels,info.sample_rate,total_time/1000000);
+    mInitCheck = OK;
+}
+
+ActAudioExtractor::~ActAudioExtractor() {
+    ALOGV("~ActAudioExtractor");
+    if (mPlugin_handle != NULL) {
+        mPlugin_info->close(mPlugin_handle);
+        mPlugin_handle = NULL;
+    }
+
+    if (mLib_handle) {
+		dlclose( mLib_handle);
+		mLib_handle = NULL;
+	}
+		
+    if (mInput){
+        dispose_storage_io(mInput);
+        mInput = NULL;
+    }    
+}
+
+static void removeUnsynchronization(uint8_t *mData, int64_t mSize){  // Alicia add 12.02.20
+    ALOGV("removeUnsynchronization");
+    for(size_t i = 0; i + 1 < mSize; ++i){
+        if(mData[i] == 0xff && mData[i + 1] == 0x00){
+            memmove(&mData[i +1], &mData[i + 2], mSize - i - 2);
+            --mSize;
+        }
+    }
+}
+
+typedef struct
+{
+    char extension[8];
+    char MIME[56];
+} extension_type_t;
+sp<MetaData> ActAudioExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (mInitCheck != OK) {
+        return meta;
+    }
+    int i = 0;
+    extension_type_t format2MIME[20] = {
+        {PARSER_EXT_MP3,"audio/MP3"},
+        {PARSER_EXT_AAC,"audio/AAC"},
+        {PARSER_EXT_WMA,"audio/WMASTD"},
+        {PARSER_EXT_RMA,"audio/COOK"},
+        {PARSER_EXT_WAV,"audio/PCM"},
+        {PARSER_EXT_OGG,"audio/OGG"},
+        {PARSER_EXT_AMR,"audio/AMR"},
+        {PARSER_EXT_ALAC,"audio/ALAC"},
+        {PARSER_EXT_APE,"audio/APE"},
+        {PARSER_EXT_FLAC,"audio/FLAC"},
+        {PARSER_EXT_DTS,"audio/DTS"},
+        {PARSER_EXT_AC3,"audio/AC3"},
+        {PARSER_EXT_MPC,"audio/MPC"},
+        {PARSER_EXT_AIFF,"audio/AIFF"},
+        {PARSER_EXT_AA,"audio/AA"},
+        {PARSER_EXT_AAX,"audio/AAX"},
+        {PARSER_EXT_WMALSL,"audio/WMALSL"},
+        {PARSER_EXT_WMAPRO,"audio/WMAPRO"},
+    };
+    {
+        id3_info_total id3_info;
+        int32_t type = MetaData::TYPE_NONE;
+        const char *mime_type;
+        void *data;
+        off64_t size = 0; 
+
+        ID3file_t fp;
+        fp.mSource = mDataSource;
+        fp.mOffset = 0;
+        mDataSource->getSize(&size);
+        fp.mFileSize = size;
+        
+        mMeta->findCString(kKeyMIMEType, &mime_type);
+//        strcpy(ext, mime_type+6);
+        while(strcmp(format2MIME[i].extension, m_ai.extension) != 0)
+        {
+            i++;
+            if((i > 20) || (format2MIME[i].extension == NULL))
+                return meta;
+        }
+        memset(&id3_info, 0, sizeof(id3_info_total));
+        meta->setCString(kKeyMIMEType, format2MIME[i].MIME);       
+        //ALOGD(" getMetaData  %s mime_type:%s", m_ai.extension, mime_type);
+        get_audio_id3_info(&fp, m_ai.extension, &id3_info);   
+        //ALOGD(" get_audio_id3_info OK img len:%dk",id3_info.tag.imageInfo.length/1024);
+        if(id3_info.tag.author.content != NULL)
+        {
+            meta->setCString(kKeyArtist, (const char *)id3_info.tag.author.content);        
+            meta->setCString(kKeyAuthor, (const char *)id3_info.tag.author.content);
+            //ALOGE(" =============id3_info.tag.author.content:%s",(const char *) id3_info.tag.author.content);
+        }
+        if(id3_info.tag.composer.content != NULL)
+        {
+            meta->setCString(kKeyComposer,(const char *)id3_info.tag.composer.content);
+        }
+        if(id3_info.tag.album.content != NULL)
+        {
+            meta->setCString(kKeyAlbum, (const char *)id3_info.tag.album.content);
+        }
+        if(id3_info.tag.genre.content != NULL)
+        {
+            meta->setCString(kKeyGenre, (const char *)id3_info.tag.genre.content);
+        }
+        if(id3_info.tag.track.content != NULL)
+        {
+            meta->setCString(kKeyCDTrackNumber,(const char *)id3_info.tag.track.content);
+        }
+        if(id3_info.tag.year.content != NULL)
+        {
+            meta->setCString(kKeyYear, (const char *)id3_info.tag.year.content);
+        }
+        if(id3_info.tag.title.content != NULL)
+        {
+            meta->setCString(kKeyTitle,(const char *)id3_info.tag.title.content);
+            ALOGV("%s ",id3_info.tag.title.content);
+        }
+        if(id3_info.tag.comment.content != NULL)
+        {
+            meta->setCString(kKeyCompilation,(const char *)id3_info.tag.comment.content);
+        }
+        if(id3_info.tag.autoLoop.content != NULL) {
+        	const char* charData;
+        	charData = (const char *)id3_info.tag.autoLoop.content;
+        	ALOGV("auto loop %s", charData);
+        	if (memcmp(charData, "true", 4) == 0) {
+        		meta->setInt32(kKeyAutoLoop, true);
+        	} else {
+        		meta->setInt32(kKeyAutoLoop, false);
+        	}
+        }
+        
+        if(id3_info.tag.imageInfo.length > 0)
+        {            
+            char ext[32];
+            strcpy(ext,"image/");
+            strcat(ext,id3_info.tag.imageInfo.imageType);
+            ALOGV(" imageType %s len:%d offset:%d",ext,id3_info.tag.imageInfo.length,id3_info.tag.imageInfo.offset);
+            data = malloc(id3_info.tag.imageInfo.length + 8096); // Alicia modify 12.02.20
+            if(data != NULL)
+            {
+                size_t n = mDataSource->readAt((int64_t)id3_info.tag.imageInfo.offset, data, (size_t)id3_info.tag.imageInfo.length + 8096);  
+                if (n > 0) {
+                    if(strcmp(m_ai.extension, PARSER_EXT_MP3) == 0){
+                        uint8_t *header = (uint8_t *)malloc(10);
+                        if(header){
+                            mDataSource->readAt((int64_t)0, (void*)header , 10);
+                            if((memcmp((char*)header,"ID3",3) == 0) && (header[3] == 2 || header[3] == 3)){
+                                if(header[5]&0x80){
+                                    removeUnsynchronization((uint8_t*)data,id3_info.tag.imageInfo.length + 8096);
+                                }
+                            }
+                        }
+                    }
+                    meta->setData(kKeyAlbumArt, 0, (const void *)data, n);
+                    int *buf = (int *)data;
+                    ALOGV(" imageheader %x %x %x %x",buf[0],buf[1],buf[2],buf[3]);
+                }
+            
+                free(data);
+            }
+            meta->setCString(kKeyAlbumArtMIME, (const char *)ext);
+        }
+        freeallmemory(&id3_info);
+    }
+    
+    meta->setPointer(kKeyActMusicInfo, (void*)(&m_ai));
+    return meta;
+}
+
+size_t ActAudioExtractor::countTracks() {
+    return mInitCheck == OK ? 1 : 0;
+}
+
+sp<MediaSource> ActAudioExtractor::getTrack(size_t index) {
+    if (mInitCheck != OK || index != 0) {
+        return NULL;
+    }
+    return new ActAudioSource(mMeta, this);
+}
+
+sp<MetaData> ActAudioExtractor::getTrackMetaData(size_t index, uint32_t flags) {
+    if (mInitCheck != OK || index != 0) {
+        return NULL;
+    }
+
+    return mMeta;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+ActAudioSource::ActAudioSource(
+        const sp<MetaData> &meta, const sp<ActAudioExtractor> &extractor)
+    : mExtractor(extractor),
+      mMeta(meta),
+      mCurrentTimeUs(0),
+      mStarted(false),
+      mGroup(NULL) {
+}
+
+ActAudioSource::~ActAudioSource() {
+    if (mStarted == (bool)true) {
+        stop();
+    }
+}
+
+status_t ActAudioSource::start(MetaData *params) {
+	CHECK_EQ(mStarted, false);
+
+    int max_chunksize;
+    mMeta->findInt32(kKeyMaxInputSize, &max_chunksize);
+    mCurrentTimeUs = 0;
+    mGroup = new MediaBufferGroup;
+    mGroup->add_buffer(new MediaBuffer(max_chunksize));
+    mStarted = true;
+
+    return OK;
+}
+
+status_t ActAudioSource::stop() {
+    CHECK_EQ(mStarted, true);
+
+    delete mGroup;
+    mGroup = NULL;
+
+    mStarted = false;
+    return OK;
+}
+
+sp<MetaData> ActAudioSource::getFormat() {
+    return mMeta;
+}
+
+status_t ActAudioSource::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    *out = NULL;
+
+    int32_t n=0, time_offset=0;
+    int64_t seekTimeUs=0ll;    
+    int32_t CurTimeUs=0ll;
+    ReadOptions::SeekMode mode;
+    int32_t ret = 0;
+    
+    //ALOGE("********cz==02_1 read");
+    MediaBuffer *buffer;
+    status_t err = mGroup->acquire_buffer(&buffer);
+    if (err != OK) {
+        ALOGE("acquire_buffer ERR %x",err);
+        return UNKNOWN_ERROR;
+    }
+
+    //ALOGE("********cz==02_2 read");
+    if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+
+        time_offset = (int32_t)(seekTimeUs/1000);    //time_offset单位为毫秒
+        
+        //ALOGE("********cz==02_2_1 read time_offset=%d",time_offset);
+         
+        mExtractor->mPlugin_info->seek_time(mExtractor->mPlugin_handle, time_offset, SEEK_SET, &CurTimeUs);
+        
+        //ALOGE("********cz==02_2_2 read CurTimeUs=%d",CurTimeUs);
+         
+        mCurrentTimeUs = (int64_t)CurTimeUs*1000;
+        //ALOGV("ActAudioSource-seek time: %d",CurTimeUs);
+        buffer->meta_data()->setInt64(kKeyTime, mCurrentTimeUs);
+        
+        
+    }
+    else {
+        buffer->meta_data()->setInt32(kKeyIsCodecConfig, 0);
+        buffer->meta_data()->setInt64(kKeyTime, 0);
+    }
+    
+    //ALOGE("********cz==02_3 read");
+    ret = mExtractor->mPlugin_info->get_chunk(mExtractor->mPlugin_handle, (char *)buffer->data(), &n);    
+    if (((ret != MP_RET_OK)&&(ret!=MP_RET_ENDFILE))||(n <= 0)) {
+        buffer->release();
+        buffer = NULL;
+        ALOGW("read:  meet %s(return ERROR_END_OF_STREAM)  len: %d", (ret==MP_RET_OK||ret==MP_RET_ENDFILE) ? "ok" : "error", n);
+        return ERROR_END_OF_STREAM;
+    }
+    
+    //ALOGE("********cz==02_2_4 read");
+    buffer->set_range(0, n); 
+    mOffset += n;
+	//mCurrentTimeUs += 20000;  // Each frame is 20ms
+
+    *out = buffer;
+      
+    if(ret==MP_RET_ENDFILE)
+    {
+        *out=NULL;
+        buffer->release();
+        buffer = NULL;
+        ALOGW("ActAudioSource read:  MP_RET_ENDFILE");
+        return ERROR_END_OF_STREAM;    
+    }
+    else
+    {    
+       //ALOGE("********cz==02_2_5 read");    
+        return OK;   
+    }        
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+//bool SniffActAudio(
+//        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+//        sp<AMessage> *) {
+//    char header[9];
+//
+////    if (source->readAt(0, header, sizeof(header)) != sizeof(header)) {
+////        return false;
+////    }
+//
+////    if (!memcmp(header, "#!AMR\n", 6)) {
+////        *mimeType = MEDIA_MIMETYPE_AUDIO_AMR_NB;
+////        *confidence = 0.5;
+////
+////        return true;
+////    } else if (!memcmp(header, "#!AMR-WB\n", 9)) {
+////        *mimeType = MEDIA_MIMETYPE_AUDIO_AMR_WB;
+////        *confidence = 0.5;
+////
+////        return true;
+////    }
+////
+////    return false;
+//      *mimeType = MEDIA_MIMETYPE_AUDIO_EXTRACTOR;
+//      *confidence = 0.5;
+//      return true;
+//}
+
+}  // namespace android
diff --git a/media/libstagefright/ActAudioWriter.cpp b/media/libstagefright/ActAudioWriter.cpp
new file mode 100755
index 0000000..3d74804
--- /dev/null
+++ b/media/libstagefright/ActAudioWriter.cpp
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <media/stagefright/ActAudioWriter.h>
+#include <media/stagefright/MediaBuffer.h>
+//#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/mediarecorder.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ActAudioWriter"
+#include <utils/Log.h>
+namespace android {
+
+ActAudioWriter::ActAudioWriter(const char *filename) :
+	mFile(fopen(filename, "wb")), mInitCheck(mFile != NULL ? OK : NO_INIT),
+			mStarted(false), mPaused(false), mResumed(false) {
+}
+
+ActAudioWriter::ActAudioWriter(int fd) :
+	mFile(fdopen(fd, "wb")), mInitCheck(mFile != NULL ? OK : NO_INIT),
+			mStarted(false), mPaused(false), mResumed(false) {
+}
+
+ActAudioWriter::~ActAudioWriter() {
+	if (mStarted) {
+		ALOGD("ActAudioWriter::~stop %d  ", __LINE__);
+		stop();
+	}
+
+	if (mFile != NULL) {
+		fclose( mFile);
+		mFile = NULL;
+	}
+}
+
+status_t ActAudioWriter::initCheck() const {
+	return mInitCheck;
+}
+
+status_t ActAudioWriter::addSource(const sp<MediaSource> &source) {
+	if (mInitCheck != OK) {
+		return mInitCheck;
+	}
+
+	if (mSource != NULL) {
+		// files only support a single track of audio.
+		return UNKNOWN_ERROR;
+	}
+
+	mSource = source;
+	return OK;
+}
+
+status_t ActAudioWriter::start(MetaData *params) {
+	if (mInitCheck != OK) {
+		return mInitCheck;
+	}
+
+	if (mSource == NULL) {
+		return UNKNOWN_ERROR;
+	}
+
+	if (mStarted && mPaused) {
+		mPaused = false;
+		mResumed = true;
+		return OK;
+	} else if (mStarted) {
+		// Already started, does nothing
+		return OK;
+	}
+
+	status_t err = mSource->start();
+	if (err != OK) {
+		return err;
+	}
+	MediaBuffer *buffer;
+	mMeta = mSource->getFormat();
+	{
+		const void *data;
+		uint32_t type;
+		size_t n;
+		mMeta->findData(kKeyIsCodecConfig, &type, &data, &n);
+		if (fwrite((const uint8_t *) data, 1, n, mFile) != n) {
+			ALOGE("ActAudioWriter fwrite Header err ");
+			return ERROR_IO;
+		}
+		mMeta->setInt32(kKeyIsUnreadable, 0);
+	}
+
+	pthread_attr_t attr;
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	mReachedEOS = false;
+	mDone = false;
+
+	pthread_create(&mThread, &attr, ThreadWrapper, this);
+	pthread_attr_destroy(&attr);
+
+	mStarted = true;
+
+	return OK;
+}
+
+status_t ActAudioWriter::pause() {
+	if (!mStarted) {
+		return OK;
+	}
+	ALOGV("mPauseddd  %d", mPaused);
+	mPaused = true;
+	return OK;
+}
+
+status_t ActAudioWriter::stop() {
+	if (!mStarted) {
+		return OK;
+	}
+	int32_t isHready = 1, cnt = 0;
+	mMeta->setInt32(kKeyIsUnreadable, 1);
+    ALOGE("stop: isHready 1");        
+	while ((isHready != 0) && (cnt < 10)) {
+		//cnt++;
+		usleep(20000);	
+		mMeta->findInt32(kKeyIsUnreadable, &isHready);
+		ALOGE("stop: isHready %x", isHready);
+	}
+
+	mDone = true;
+	void *dummy;
+	pthread_join(mThread, &dummy);
+
+	status_t err = (status_t) dummy;
+	{
+		status_t status = mSource->stop();
+		if (err == OK && (status != OK && status != ERROR_END_OF_STREAM)) {
+			err = status;
+		}
+		mSource.clear();
+	}
+
+	mStarted = false;
+	return err;
+}
+
+bool ActAudioWriter::exceedsFileSizeLimit() {
+	if (mMaxFileSizeLimitBytes == 0) {
+		return false;
+	}
+	return mEstimatedSizeBytes >= mMaxFileSizeLimitBytes;
+}
+
+bool ActAudioWriter::exceedsFileDurationLimit() {
+	if (mMaxFileDurationLimitUs == 0) {
+		return false;
+	}
+	ALOGV("time:%ll", mEstimatedDurationUs);
+	return mEstimatedDurationUs >= mMaxFileDurationLimitUs;
+}
+
+// static
+void *ActAudioWriter::ThreadWrapper(void *me) {
+	return (void *) static_cast<ActAudioWriter *> (me)->threadFunc();
+}
+int cnt = 0;
+status_t ActAudioWriter::threadFunc() {
+	mEstimatedDurationUs = 0;
+	mEstimatedSizeBytes = 0;
+	bool stoppedPrematurely = true;
+	int64_t previousPausedDurationUs = 0;
+	int64_t maxTimestampUs = 0;
+	status_t err = OK;
+	int32_t isHready;
+	prctl(PR_SET_NAME, (unsigned long) "ActAudioWriter", 0, 0, 0);
+	while (!mDone) {
+		MediaBuffer *buffer;
+		err = mSource->read(&buffer);
+		if (err != OK) {
+			break;
+		}
+
+		if (mPaused) {
+			ALOGV("mPaused...");
+			buffer->release();
+			buffer = NULL;
+			usleep(50000);
+			continue;
+		}
+
+		mMeta->findInt32(kKeyIsUnreadable, &isHready);
+		if (isHready == 2) {
+			const void *data;
+			uint32_t type;
+			size_t n;
+			fflush( mFile);
+			mMeta->findData(kKeyIsCodecConfig, &type, &data, &n);
+			fseek(mFile, 0, SEEK_SET);
+			if (fwrite((const uint8_t *) data, 1, n, mFile) != n) {
+				ALOGE("ActAudioWriter STOP fwrite Header err ");
+				return ERROR_IO;
+			}
+			fflush(mFile);
+			ALOGD("stop: write header %x", n);
+			mMeta->setInt32(kKeyIsUnreadable, 0);
+			mMeta->setInt32(kKeyIsUnreadable, 0);
+			break;
+		}
+
+		mEstimatedSizeBytes += buffer->range_length();
+		if (exceedsFileSizeLimit()) {
+			buffer->release();
+			buffer = NULL;
+			notify(MEDIA_RECORDER_EVENT_INFO,
+					MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
+			break;
+		}
+
+		int64_t timestampUs;
+		CHECK(buffer->meta_data()->findInt64(kKeyTime, &timestampUs));
+		if (timestampUs > mEstimatedDurationUs) {
+			mEstimatedDurationUs = timestampUs;
+		}
+		if (mResumed) {
+			previousPausedDurationUs += (timestampUs - maxTimestampUs - 20000);
+			ALOGD("time stamp: %lld, maxTimestampUs: %lld", timestampUs,
+					maxTimestampUs);
+			mResumed = false;
+		}
+		//        timestampUs -= previousPausedDurationUs;
+		//        ALOGV("time stamp: %lld, previous paused duration: %lld",
+		//                timestampUs, previousPausedDurationUs);
+		if (timestampUs > maxTimestampUs) {
+			maxTimestampUs = timestampUs;
+		}
+
+		if (exceedsFileDurationLimit()) {
+			buffer->release();
+			buffer = NULL;
+			notify(MEDIA_RECORDER_EVENT_INFO,
+					MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
+			break;
+		}
+	/*	if (cnt % 10 == 0) */{
+			int timestampMs;
+			timestampMs = timestampUs / 1000;
+			notify(MEDIA_RECORDER_EVENT_INFO,
+					MEDIA_RECORDER_INFO_PROGRESS_TIME_STATUS, timestampMs);
+		}
+		cnt++;
+		ssize_t n = fwrite(
+				(const uint8_t *) buffer->data() + buffer->range_offset(), 1,
+				buffer->range_length(), mFile);
+		if (n < (ssize_t) buffer->range_length()) {
+			buffer->release();
+			buffer = NULL;
+
+			break;
+		}
+
+		// XXX: How to tell it is stopped prematurely?
+		if (stoppedPrematurely) {
+			stoppedPrematurely = false;
+		}
+
+		buffer->release();
+		buffer = NULL;
+	}
+
+	if (stoppedPrematurely) {
+		notify(MEDIA_RECORDER_EVENT_INFO,
+				MEDIA_RECORDER_INFO_COMPLETION_STATUS, UNKNOWN_ERROR);
+	}
+
+	fflush( mFile);
+	fclose(mFile);
+	mFile = NULL;
+	mReachedEOS = true;
+	if (err == ERROR_END_OF_STREAM) {
+		return OK;
+	}
+	return err;
+}
+
+bool ActAudioWriter::reachedEOS() {
+	return mReachedEOS;
+}
+
+} // namespace android
diff --git a/media/libstagefright/ActDataSource.cpp b/media/libstagefright/ActDataSource.cpp
new file mode 100755
index 0000000..f6cf3cc
--- /dev/null
+++ b/media/libstagefright/ActDataSource.cpp
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ActDataSource"
+#include <utils/Log.h>
+#include <media/stagefright/foundation/ADebug.h>
+
+#include "ActDataSource.h"
+namespace android {
+#define DATA_LOGV(x, ...)    //ALOGV(x, ##__VA_ARGS__) 
+
+typedef struct {
+    storage_io_t io;
+
+    off64_t mOffset;
+    off64_t mFileSize;
+
+    sp<DataSource> mSource;
+} storage_internal_t;
+
+typedef struct {
+    stream_input_t input;
+    storage_io_t *storage_io;
+
+} stream_manager_t;
+
+int storage_read(void *buf, int size, int count, storage_io_t *io) {
+	ALOGV("storage_read: size: %d count: %d io: %p", size, count, (void *)io);
+    storage_internal_t * const storage = (storage_internal_t *)io;
+	size_t need_size = (size_t)(size * count);
+	if (need_size == 0) {
+		return 0;
+	}
+	CHECK(need_size > 0);
+    ssize_t n = storage->mSource->readAt(storage->mOffset, (void*)buf, need_size);
+	
+	#if 1
+	if ((n == need_size)||((n>0) && (n < need_size))) {
+		storage->mOffset += n;
+	}else if (n == 0){
+		DATA_LOGV("storage_read() read upto the end of stream !!! storage->mOffset: %lld need_size: %d", storage->mOffset, need_size);
+	}else {
+		ALOGE("storage_read() read error !!! storage->mOffset: %lld need_size: %d", storage->mOffset, need_size);
+	}
+	#else
+    if (n > 0)
+    {
+        storage->mOffset += n;
+    }
+	#endif
+	
+	ALOGV("storage_read: end");
+    return n / size;
+}
+
+static int storage_seek(storage_io_t *io, off64_t offset, int whence) {
+    storage_internal_t * const storage = (storage_internal_t *)io;
+
+    if (whence == SEEK_CUR) {
+        storage->mOffset += offset;
+    } else if (whence == SEEK_SET) {
+        storage->mOffset = offset;
+    } else {
+        storage->mOffset = storage->mFileSize + offset;
+    }
+
+    return 0;
+}
+
+static off64_t storage_tell(storage_io_t *io) {
+    storage_internal_t * const storage = (storage_internal_t *)io;
+
+    return storage->mOffset;
+}
+
+static int stream_read(stream_input_t *input, unsigned char *buf, unsigned int len)
+{
+    int nread = 0;
+    stream_manager_t *stream_manager = (stream_manager_t *)input;
+
+    if((input == NULL) || (buf == NULL)) {
+        ALOGE("stream_read: error input: %p buf: %p\n", (void *)input, (void *)buf);
+        return 0;
+    }
+
+    nread = stream_manager->storage_io->read(buf, 1, len, stream_manager->storage_io);
+
+    return nread;
+}
+
+static int stream_seek(stream_input_t *input, off64_t offset, int original)
+{
+    stream_manager_t *stream_manager = (stream_manager_t *)input;
+	DATA_LOGV("stream_seek: input(0x%x) offset(%lld) original(%d) then call storage_seek", input, offset, original);
+    if(input == NULL){
+        ALOGE("stream_seek()->(input == NULL) error!!!\n");
+        return -1;
+    }
+    if (original == DSEEK_SET){
+        original = SEEK_SET;
+    }else if (original == DSEEK_CUR) {
+        original = SEEK_CUR;
+    } else if (original == DSEEK_END){
+        original = SEEK_END;
+    } else {
+        ALOGE("stream_seek(): offset(%lld)  original(%d) error!!! \n", offset, original);
+        return -1;
+    }
+
+    return stream_manager->storage_io->seek(stream_manager->storage_io, offset, original);
+}
+
+static off64_t stream_tell(stream_input_t *input)
+{
+    stream_manager_t *stream_manager = (stream_manager_t *)input;
+
+    if(input == NULL) {
+		ALOGE("create_storage_io()->(input==NULL) error!!!!");
+        return 0;
+    }
+
+    return stream_manager->storage_io->tell(stream_manager->storage_io);
+}
+//---------------------------------------------------------
+off64_t init_storage_io(storage_io_t *io, const sp<DataSource> &source)
+{
+    storage_internal_t * const storage = (storage_internal_t *)io;
+    off64_t  size = 0;
+
+    storage->mSource = source;
+    storage->mOffset = 0;
+    if (storage->mSource->getSize(&size) < 0) {
+        storage->mFileSize = 0;
+    } else { 
+        storage->mFileSize = size;
+    }
+
+    return storage->mFileSize;
+}
+
+void dispose_storage_io(storage_io_t *io)
+{
+    storage_internal_t *storage = (storage_internal_t *)io;
+
+    if (storage){
+        delete storage;
+        storage = NULL;
+    }
+}
+
+storage_io_t *create_storage_io(void)
+{
+    storage_internal_t *storage;
+    status_t status = 0;
+    storage = new storage_internal_t;
+    if (storage == NULL){
+    	ALOGE("create_storage_io()-> return NULL error!!!!");
+        return NULL;
+    }
+
+    storage->io.read = storage_read;
+    storage->io.write = NULL;
+    storage->io.seek = storage_seek;
+    storage->io.tell = storage_tell;
+
+    return &storage->io;
+}
+//---------------------------------------------------------
+off64_t stream_input_init(stream_input_t *input, const sp<DataSource> &source)
+{
+    stream_manager_t *stream_manager = (stream_manager_t *)input;
+    int ret = 0;
+
+    return init_storage_io(stream_manager->storage_io, source);
+}
+
+void stream_input_dispose(stream_input_t *input)
+{
+    stream_manager_t *stream_manager = (stream_manager_t *)input;
+
+    if (stream_manager){
+        dispose_storage_io(stream_manager->storage_io);
+        actal_free(stream_manager);
+        stream_manager = NULL;
+    }
+}
+
+stream_input_t *stream_input_open(void)
+{
+    stream_manager_t *stream_manager = NULL;
+
+    stream_manager = (stream_manager_t *)actal_malloc(sizeof(stream_manager_t));
+    if (stream_manager == NULL){
+        ALOGE("%s: disk manager open error\n", __FILE__);
+        return NULL;
+    }
+
+    actal_memset(stream_manager, 0, sizeof(stream_manager_t));
+
+    stream_manager->storage_io = create_storage_io();
+    if (stream_manager->storage_io == NULL){
+        goto exit0;
+    }
+
+    stream_manager->input.read = stream_read;
+    stream_manager->input.write = NULL;
+    stream_manager->input.seek = stream_seek;
+    stream_manager->input.tell = stream_tell;
+
+    return &stream_manager->input;
+
+exit0:
+    actal_free(stream_manager);
+    return NULL;
+}
+} // namespace android
diff --git a/media/libstagefright/ActVideoExtractor.cpp b/media/libstagefright/ActVideoExtractor.cpp
new file mode 100755
index 0000000..8a911dd
--- /dev/null
+++ b/media/libstagefright/ActVideoExtractor.cpp
@@ -0,0 +1,2216 @@
+/*
+ * Nothing here ...
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "ActVideoExtractor"
+#include <utils/Log.h>
+#include <dlfcn.h>
+
+#include <binder/MemoryDealer.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/hexdump.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+#include <utils/String8.h>
+
+/* for notify */
+#include "include/AwesomePlayer.h"
+
+#include "include/ActVideoExtractor.h"
+#include "ActDataSource.h"
+
+#define WORD_SIZE 0x04
+#define WORD_MASK 0xfffffffc
+
+
+#define ONLY_PLAY_VIDEO_FLAG   0//
+#define ONLY_PLAY_AUDIO_FLAG  0
+#define OUTPUT_PARSER_DATA_A 		0
+
+
+#define EXTRACT_LOGV(x, ...) 		//ALOGV(x, ##__VA_ARGS__)   // turn on function in && out trace flag
+#define EXTRACT_LOGD(x, ...) 		//ALOGD(x, ##__VA_ARGS__)   // turn on function content trace flag
+#define BUFFER_LOGD(x, ...)  		//ALOGD(x, ##__VA_ARGS__) 
+#define EXTRACT_LOGW(x, ...)	   //ALOGW(x, ##__VA_ARGS__) 
+#define EXTRACT_LOGT(x, ...)	   		//ALOGW(x, ##__VA_ARGS__) 
+#define SUB_LOGD(x, ...)	   	//ALOGD(x, ##__VA_ARGS__) 
+#define AUDIOTRACK_LOGD(x, ...)	   	//ALOGD(x, ##__VA_ARGS__) 
+
+namespace android {
+#define UNKNOWN_PACKET 				(SUBPIC_PACKET+1)
+#define SIZE_PHT 								(sizeof(packet_header_t))
+
+#define MINIMUM_LASTPK_TIMEDIFF					100000 //100MS
+#define DIFFTOEND   5000000
+#define MAX_GET_PACKETS_LOOP_TIMES			700
+
+#define USE_PHY_CONTINUAL_STREAM_BUF
+
+#ifdef USE_PHY_CONTINUAL_STREAM_BUF
+#include <common/al_libc.h>
+#endif
+
+static const ExtToMime_t kExtToMime[] = {
+	{""    ,           "video/unsupport",  CODEC_UNKNOWN},
+
+	/* coda */
+	{"h264", MEDIA_MIMETYPE_VIDEO_AVC,   CODEC_ACTIONS},
+	{"divx", MEDIA_MIMETYPE_VIDEO_MPEG4, CODEC_ACTIONS},
+	{"div3", MEDIA_MIMETYPE_VIDEO_DIV3,  CODEC_ACTIONS},
+	{"msm4", MEDIA_MIMETYPE_VIDEO_DIV3,  CODEC_ACTIONS},
+	{"xvid", MEDIA_MIMETYPE_VIDEO_MPEG4, CODEC_ACTIONS},
+	{"mpeg", MEDIA_MIMETYPE_VIDEO_MPEG2, CODEC_ACTIONS},
+	{"h263", MEDIA_MIMETYPE_VIDEO_H263,  CODEC_ACTIONS},
+	{"flv1", MEDIA_MIMETYPE_VIDEO_FLV1,  CODEC_ACTIONS},
+	{"wmv9", MEDIA_MIMETYPE_VIDEO_VC1,   CODEC_ACTIONS},
+	//{"wmv8", MEDIA_MIMETYPE_VIDEO_VC1,   CODEC_CODA},
+    {"vc1", MEDIA_MIMETYPE_VIDEO_VC1,    CODEC_ACTIONS},
+	{"rv34", MEDIA_MIMETYPE_VIDEO_RV,    CODEC_ACTIONS},
+	{"mjpg", MEDIA_MIMETYPE_VIDEO_MJPG,  CODEC_ACTIONS},
+	{"jpeg", MEDIA_MIMETYPE_VIDEO_MJPG,  CODEC_ACTIONS}, /* some demuxer named "mjpg" as "jpeg" */
+
+    {"wmv8" ,  MEDIA_MIMETYPE_VIDEO_WMV8/*"video/unsupport"*/, CODEC_ACTIONS},
+    {"rvg2",   MEDIA_MIMETYPE_VIDEO_WMV8/*"video/unsupport"*/, CODEC_ACTIONS},
+    {"vp8" ,  MEDIA_MIMETYPE_VIDEO_VP8, CODEC_ACTIONS},
+    {"vp6" ,  MEDIA_MIMETYPE_VIDEO_VP6, CODEC_ACTIONS},
+	  {"misc", MEDIA_MIMETYPE_VIDEO_WMV8/*"video/unsupport"*/,  CODEC_ACTIONS},
+	  {"vp3t", MEDIA_MIMETYPE_VIDEO_WMV8/*"video/unsupport"*/,  CODEC_ACTIONS},
+	{""    ,           "video/unsupport", CODEC_UNKNOWN}
+};
+
+static const aExtToMime_t kAExtToMime[] = {
+	{"" ,"unsupport", 9},
+
+	/* audio */
+	{"aac", "AAC",   3},
+	{"mp4a-latm", "AAC", 	 3},
+	{"aac-adts", "AAC", 	 3},
+	{"ac3", "AC3", 3},
+	{"acelp", "ACELP",  5},
+	{"aiff", "AIFF",  4},
+	{"amr", "AMR", 3},
+	{"ape", "APE", 3},
+	{"cook", "COOK",  4},
+	{"dts", "DTS",  3},
+	{"flac", "FLAC",   4},
+    {"mp3", "MP3",    3},
+	{"mpc", "MPC",    3},
+	{"ogg","OGG",  3}, 
+	{"pcm", "PCM", 3}, 
+	{"wmalsl", "WMALSL", 6},
+	{"wmapro", "WMAPRO",  6},
+	{"wmastd", "WMASTD",  6},
+	{"wav", "PCM",   3},
+
+	{"" ,   "unsupport", 9}
+};
+struct ActVideoSource : public MediaSource {
+	ActVideoSource(
+	    const sp<ActVideoExtractor> &extractor, size_t index);
+
+	virtual status_t start(MetaData *params);
+	virtual status_t stop();
+
+	virtual sp<MetaData> getFormat();
+
+	virtual status_t read(
+	    MediaBuffer **buffer, const ReadOptions *options);
+
+	protected:
+	virtual ~ActVideoSource();
+
+	private:
+	enum Type {
+	AVC,
+	AAC,
+	OTHER
+	};
+
+	sp<ActVideoExtractor> mExtractor;
+	mutable Mutex mLock;
+	Mutex mMiscStateLock;
+	
+	size_t mTrackIndex;
+	size_t mReadAgainCouter;
+	Type mType;
+	packet_header_t *m_pht;
+#if OUTPUT_PARSER_DATA_A
+	FILE * fp_audio_data;
+#endif
+	ActVideoSource(const ActVideoSource &);
+	ActVideoSource &operator=(const ActVideoSource &);
+};
+
+ActVideoSource::ActVideoSource(
+        const sp<ActVideoExtractor> &extractor, size_t index)
+    : mExtractor(extractor),
+      mTrackIndex(index),
+      mType(OTHER) {
+    //sp<MetaData> meta = mExtractor->mTracks.itemAt(index).mMeta;
+  mExtractor->mVideoAlreadySeek=0;
+  mReadAgainCouter=0;
+#ifdef MMM_ENABLE_SUBTITLE	
+	actal_memset(mExtractor->subtitle_data,0,MMM_SUBTITLE_DATA_LEN*MMM_SUBTITLE_NUM);
+	mExtractor->subtitle_buf_No_0 = 0;
+	mExtractor->subtitle_buf_No_1 = 0;
+	mExtractor->subtitle_get_flag = 0;
+	mExtractor->pkt_prv_ts = -1; 
+	mExtractor->packet_header_tmp = NULL;
+	mExtractor->packet_header_org = NULL;
+	mExtractor->addr_oft = 0;	
+	mExtractor->reserved_count = 0;
+	mExtractor->put_subtitle_packet_flag = 0;
+	mExtractor->need_subtitle = 0;
+#endif	   
+#if OUTPUT_PARSER_DATA_A
+	fp_audio_data = fopen("/data/juan/parser_out.data", "a+");
+	if (fp_audio_data == NULL) {
+		ALOGE("ActVideoSource:open /data/juan/parser_out.data error");
+	}
+#endif
+}
+
+ActVideoSource::~ActVideoSource() {
+#if OUTPUT_PARSER_DATA_A
+	if (fp_audio_data) {
+		fclose(fp_audio_data);
+	}
+#endif
+	EXTRACT_LOGV("~ActVideoSource");
+}
+
+status_t ActVideoSource::start(MetaData *params) {
+    return OK;
+}
+
+status_t ActVideoSource::stop() {
+    return OK;
+}
+
+sp<MetaData> ActVideoSource::getFormat() {
+    return mExtractor->mTracks.itemAt(mTrackIndex).mMeta;
+}
+
+status_t ActVideoSource::read(MediaBuffer **out, const ReadOptions *options) {
+	Mutex::Autolock autoLock(mLock);
+
+	EXTRACT_LOGV("Entry read: type is %s", mTrackIndex == 0 ? "video" : "audio");
+	packet_type_t t = mExtractor->matchPacketType(mTrackIndex);
+	if (t == (packet_type_t)UNKNOWN_PACKET) {
+		return ERROR_OUT_OF_RANGE;
+	}
+
+	int64_t seekTimeUs=0ll;
+	ReadOptions::SeekMode mode;
+	bool seeked = false;
+	status_t ret = OK;
+	bool isAudioFlag = (t == VIDEO_PACKET) ? false : true;
+	if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+		EXTRACT_LOGT("read: seek to %lld isAudioFlag: %s", seekTimeUs, isAudioFlag==true ? "true" : "false");
+		seeked = true;
+		if (true == mExtractor->seekable()) {
+			if(isAudioFlag == false||(mExtractor->mNotPlayVideo||mExtractor->mNotPlayAudio)){/* we seek only on video's demands */
+				EXTRACT_LOGD("read: isAudioFlag %d, mNotPlayVideo %d, mNotPlayAudio %d",isAudioFlag,mExtractor->mNotPlayVideo,mExtractor->mNotPlayAudio);
+				Mutex::Autolock autoLock(mMiscStateLock);  // add by cathy 2011-12-14 ---1
+				ret = mExtractor->seek(seekTimeUs);
+				if(ret != OK) {
+					ALOGE("read: mExtractor->seek() meet %s !!!!!", (ret==ERROR_END_OF_STREAM) ? "end of stream" : "error");
+					*out = NULL;
+					mExtractor->mSeekFailed = 1;
+					return ERROR_END_OF_STREAM;
+				}else {
+	    			    EXTRACT_LOGT("read: mExtractor->seek() ok");
+	    			    mExtractor->mVideoAlreadySeek = 1;				
+				}
+			}else{				
+				EXTRACT_LOGD("read: audio's seek demand ignored");
+			//	mExtractor->mVideoAlreadySeek = 0;		//for seek
+				if(mExtractor->mSeekFailed == 1){
+					ALOGE("read: video seek error, audio read no more response");						
+					return ERROR_END_OF_STREAM;
+				}
+			}
+		
+		}else {
+			EXTRACT_LOGD("mExtractor can not seek, continue playing...");
+			seeked = false;
+		}
+	}
+
+	{
+	Mutex::Autolock autoLock(mMiscStateLock);  // add by cathy 2011-12-14 ---2
+ReadAgain:
+	av_buf_t av_buf={0};
+	ret = mExtractor->getPacket(&av_buf, t);
+	if(ret==ERROR_BUFFER_TOO_SMALL && mReadAgainCouter<1000){
+		usleep(10000);
+		mReadAgainCouter++;
+		goto ReadAgain;
+	}
+	if(OK != ret) {
+		*out = NULL;
+		ALOGE("mReadAgainCouter is %d \n",mReadAgainCouter);
+		if(mReadAgainCouter==1000){
+			ret=ERROR_END_OF_STREAM;
+		}
+		if (ret!=INFO_NO_RAW_DATA_NOW) {
+			ALOGW("Exit read: get Packet meet %s(%d) type: %s", 
+					(ret == ERROR_END_OF_STREAM) ? "end of stream" : 
+					((ret==INFO_NO_RAW_DATA_NOW) ? "not find raw data" : "error"), ret,
+					(mTrackIndex == 0) ? "video" : "audio");
+		}
+		
+		return (ret == ERROR_END_OF_STREAM) ? ERROR_END_OF_STREAM : 
+					((ret==INFO_NO_RAW_DATA_NOW) ? INFO_NO_RAW_DATA_NOW : ret);
+	}
+  mReadAgainCouter=0;
+	
+	int offset = ((mExtractor->mEtm->ct == CODEC_CODA) ||(isAudioFlag== true)) ? SIZE_PHT : 0;
+
+
+	if ((av_buf.data == 0) || ((av_buf.data_len-offset) == 0)) {
+		*out = NULL;
+		ALOGE("Exit read => meet no av data error!!! ret(%d)", ret);
+		return !OK;
+	}
+	
+#if OUTPUT_PARSER_DATA_A
+	if ((isAudioFlag== false)&&(seeked == true)) {
+		fwrite(av_buf.data + offset, 1, av_buf.data_len - offset, fp_audio_data);
+	}
+#endif
+
+	packet_header_t *pht = (packet_header_t*)av_buf.data;	
+	/*---change viraddr to phyadd---*/
+#if 0 
+	if(t==VIDEO_PACKET && mExtractor->m_vp.start_phyaddr!=NULL){
+		actal_cache_flush(av_buf.data,av_buf.data_len);
+}
+#endif
+	MediaBuffer *buffer = new MediaBuffer(av_buf.data + offset, av_buf.data_len - offset);
+	
+	
+
+	
+	int64_t pkttime = (int64_t)pht->packet_ts*1000;
+	
+	if (isAudioFlag== true) {
+		if(mExtractor->mNotPlayAudio==false){		
+			if (seeked == true ) {
+				pkttime = (int64_t)mExtractor->getFirstAudioTime()*1000;
+				EXTRACT_LOGV("read: seeked is %s and Audio's first packet time to %lld %lld %lld", 
+				seeked == true ? "true": "false", pkttime, (int64_t)pht->packet_ts*1000, (int64_t)mExtractor->getFirstAudioTime()*1000);
+			}else {
+				EXTRACT_LOGV("read: seeked is %s and %s packet time to %lld", seeked == true ? "true": "false", (isAudioFlag==false) ? "video" : "audio",pkttime);
+				if(mExtractor->mIsSetTrack==false){
+				pkttime=0;
+				}else{
+					mExtractor->mIsSetTrack = false;
+				}
+			}
+		}
+		if (mExtractor->mVideoAlreadySeek == 1) {
+			buffer->meta_data()->setInt32(kKeyIsCodecConfig, 1);
+	        mExtractor->mVideoAlreadySeek = 0;
+	        EXTRACT_LOGD("read: set Audio pkt reset kKeyIsCodecConfig flag to 1 ");
+		}else {
+			 buffer->meta_data()->setInt32(kKeyIsCodecConfig, 0);
+		}
+	}
+
+	buffer->meta_data()->setInt64(kKeyTime, pkttime);
+	buffer->meta_data()->setInt32(kKeyIsSyncFrame, 0/*isSync*/);
+
+
+	*out = buffer;
+	EXTRACT_LOGV("exit read: %s pkttime: %lld", (isAudioFlag==false) ? "video" : "audio", pkttime);
+	}
+    return OK;
+}
+
+bool ActVideoExtractor::open_plugin(const char *ext)
+{
+#define LIBPOSTFIX              ".so"
+	typedef void *(* func_t)(void);
+	char libname[32] = {'a', 'v', 'd', '_', '\0'};
+	if(strlen(ext)< sizeof(m_ext)){
+		strcpy(m_ext,ext);
+	} else {
+		memcpy(m_ext, ext, sizeof(m_ext)-1);
+		m_ext[sizeof(m_ext)-1] = '\0';
+		ALOGE("ext(%s) too long, stripped to m_ext(%s)", ext, m_ext);
+	}
+
+	strcat(libname, ext);
+	strcat(libname, LIBPOSTFIX);
+	EXTRACT_LOGV("libname: %s", libname);
+	mLib_handle = dlopen(libname, RTLD_NOW);
+	if(mLib_handle == NULL) {
+		ALOGE("dlopen err, libname: %s", libname);
+		return false;
+	}
+
+	CHECK(mLib_handle!=NULL);
+	func_t f = (func_t)dlsym(mLib_handle, "get_plugin_info");
+	if(f == NULL) {
+		ALOGE("dlsym err");
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		return false;
+	}
+
+	m_dp = (demux_plugin_t*)f();
+	if(m_dp == NULL) {
+		ALOGE("get_plugin_info err");
+		if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		return false;
+	}
+	CHECK(m_dp!=NULL);
+	return true;
+#undef LIBPOSTFIX
+}
+
+void appendfile(const char* path, void* buf, size_t size)
+{
+	FILE* f;
+	f = fopen(path, "a+");
+	if(f == NULL){
+		ALOGE("appendfile: fopen %s error", path);
+		return;
+	}
+
+    EXTRACT_LOGD("Appending to file %s, size(%d)", path, size);
+	fwrite(buf, 1, size, f);
+	fclose(f);
+	return;
+}
+
+void output_mediabuffer(MediaBuffer *out, packet_type_t type)
+{
+	const char* path=NULL;
+	switch (type) {
+		case AUDIO_PACKET:
+			path = "/data/a.raw";
+			break;
+		case VIDEO_PACKET:
+			path = "/data/v.raw";
+			break;
+		case SUBPIC_PACKET:
+			path = "/data/s.raw";
+			break;
+		default:
+			path = "/data/bin.raw";
+			break;
+	}
+    appendfile(path, out->data(), out->size());
+    return;
+}
+
+void media_info_print(media_info_t *movi_info)
+{
+#define printf ALOGE
+    printf("media info ....\n");
+    printf("\tmedia_type:%d\n",movi_info->media_type);
+    printf("\ttotal_time:%d\n",movi_info->total_time);
+    printf("\taudio_num:%d\n",movi_info->audio_num);
+    printf("\tsub_num:%d\n",movi_info->sub_num);
+
+    printf("\twidth:%d\n",movi_info->parser_video.width);
+    printf("\theight:%d\n",movi_info->parser_video.height);
+    printf("\tframe_rate:%d\n",movi_info->parser_video.frame_rate);
+    printf("\tsample_rate:%d\n",movi_info->parser_audio[0].sample_rate);
+    printf("\tchannel:%d\n",movi_info->parser_audio[0].channels);
+    printf("\tfirst_audio_time:%d\n",movi_info->first_audio_time);
+    printf("\taudio:%s\n",movi_info->parser_audio[0].extension);
+    printf("\tvideo:%s\n",movi_info->parser_video.extension);
+    printf("\tindex_flag:%d\n",movi_info->index_flag);
+    printf("\taudio_bitrate:%d\n",movi_info->parser_audio[0].audio_bitrate);
+    printf("\tvideo_bitrate:%d\n",movi_info->parser_video.video_bitrate);
+#undef printf
+}
+
+static void linear_buf_reset(stream_buf_t* t) {
+    CHECK(t != NULL);
+    t->empty.a = t->start;
+    t->empty.b = t->start + t->size;
+}
+
+
+static bool linear_buf_allocate_phyCont(stream_buf_t* t, size_t size) {
+
+
+   int32_t phy_addr;
+    t->start = (uint8_t*)actal_malloc_wt(size, &phy_addr);
+    t->start_phyaddr=(uint8_t*)phy_addr;
+    ALOGE("linear_buf_allocate_phyCont: size:%d, viraddr:0x%x,phyaddr:0x%x \n",size, (unsigned int)t->start,(unsigned int)t->start_phyaddr);
+
+    if(t->start == NULL || t->start_phyaddr == NULL) {
+        ALOGE("linear_buf_allocate_phyCont malloc err");
+        return false;
+    }
+    if(size<=14*1024*1024){
+    	t->size = size;
+    }else{
+    	t->size = size-3*1024*1024;
+    }
+    t->real_size = size;
+    
+    linear_buf_reset(t);
+
+    ALOGE("linear_buf_allocate: start(%p), size(%d), empty.(a, b)(%p, %p)", t->start_phyaddr, t->size, t->empty.a, t->empty.b);
+
+    return true;
+}
+
+static bool linear_buf_free_phyCont(stream_buf_t* t) {
+	if (t->start) {
+
+	    actal_free_wt(t->start);
+	}
+
+    ALOGE("linear buff free :0x%x", (unsigned int)t->start);
+
+    t->start = NULL;
+    t->start_phyaddr = NULL;
+    t->size = 0;
+    t->real_size=0;
+    t->empty.a = NULL;
+    t->empty.b = NULL;
+    return true;
+}
+
+static bool linear_buf_allocate(stream_buf_t* t, size_t size) {
+	 t->start = (uint8_t*)actal_malloc(size);
+	 t->start_phyaddr=NULL;
+	
+	if(t->start == NULL) {
+	    ALOGE("linear_buf_allocate: malloc(%d)  error", size);
+	    return false;
+	}
+	t->size = size;
+	t->real_size = size;
+	linear_buf_reset(t);
+	BUFFER_LOGD("linear_buf_allocate: start(%x), size(%x), empty.a(%x), empty.b(%x)", (void*)t->start, t->size, (void*)t->empty.a, (void*)t->empty.b);
+	return true;
+}
+
+static bool linear_buf_free(stream_buf_t* t) {
+	if (t->start) {
+		actal_free(t->start);
+	}
+	t->start = NULL;
+	t->size = 0;
+	t->real_size=0;
+	t->empty.a = NULL;
+	t->empty.b = NULL;
+	return true;
+}
+
+
+bool ActVideoExtractor::stream_buf_init() {
+	EXTRACT_LOGD("stream_buf_init: width: %d", m_mi.parser_video.width);
+	uint32_t ss_a = 0;
+	uint32_t ss_v = 0;
+	uint32_t width=m_mi.parser_video.width;
+	m_pkt_maxs.a = 180*1024;
+	m_pkt_maxs.s = 20*1024;
+#ifdef USE_PHY_CONTINUAL_STREAM_BUF
+  if(m_cookie!=NULL){
+ 	 if(!strncmp("rm", m_ext, 2) || !strncmp("ts", m_ext, 2)){
+  	 if(m_mi.parser_video.video_bitrate<8*1024*1024){
+				ss_v = 14*1024*1024;
+		 }else if(m_mi.parser_video.video_bitrate>=8*1024*1024 && m_mi.parser_video.video_bitrate<=20*1024*1024){
+				ss_v = 20*1024*1024;
+		 }else{
+				ss_v = 30*1024*1024;
+	   }
+  	}else{
+  	 if(m_mi.parser_video.video_bitrate<20*1024*1024){
+				ss_v = 14*1024*1024;
+		 }else if(m_mi.parser_video.video_bitrate>=20*1024*1024 && m_mi.parser_video.video_bitrate<40*1024*1024){
+				ss_v = 20*1024*1024;
+		 }else{
+				ss_v = 30*1024*1024;
+	   }
+ 	  }
+ 	 	if(m_mi.parser_video.width>2048 && ss_v<25*1024*1024 ){
+ 	 		ss_v = 25*1024*1024;
+ 	 	}
+ 	 }else{
+ 	 	  if(width>1920){
+ 	 	  	ss_v = 12*1024*1024;
+ 	 	  }else{
+ 	 	  	ss_v = 6*1024*1024;
+ 	 	  }
+ 	 			
+ 	 }
+ 	 
+ 
+#else
+	ss_v = 70*1024*1024;
+#endif
+	ss_a = 12*1024*1024;
+  
+  if(width>1920){
+  	m_pkt_maxs.v = 3*1024*1024; 
+  }else if(width>1280) { 
+		m_pkt_maxs.v = 2*1024*1024;    
+	}  else if(width>=720)  { 
+		m_pkt_maxs.v = 800*1024;
+	}  else if(width>352) {
+		m_pkt_maxs.v = 230*1024;
+	}  else {   
+		m_pkt_maxs.v = 80*1024;       
+	} 
+
+    if(false == linear_buf_allocate(&m_ap, (size_t)ss_a)) {
+        return false;
+    }
+    m_ap.real_size = ss_a;
+    m_ap.size = ss_a -2*1024*1024;
+    
+
+    
+#ifdef USE_PHY_CONTINUAL_STREAM_BUF
+    mUsingPhyContBuffer = true;
+#else        
+    mUsingPhyContBuffer = false;
+#endif
+    
+    if(!strcmp(m_mi.parser_video.extension, "flv1") ||!strcmp(m_mi.parser_video.extension, "msm4")) {
+        mUsingPhyContBuffer = false; 
+    }    
+    
+    if(mUsingPhyContBuffer) {
+        if(false == linear_buf_allocate_phyCont(&m_vp, (size_t)ss_v)){
+            linear_buf_free(&m_ap);
+            return false;
+        }
+
+    } else {         
+        if(false == linear_buf_allocate(&m_vp, (size_t)ss_v)){
+            linear_buf_free(&m_ap);
+            return false;
+        }
+    }        
+        
+    return true;
+}
+
+bool ActVideoExtractor::stream_buf_destroy() {
+    linear_buf_free(&m_ap);
+    linear_buf_free(&m_ap_spare);
+    linear_buf_free(&m_vp_spare);
+
+    if(mUsingPhyContBuffer) {
+        linear_buf_free_phyCont(&m_vp);     
+    }else {
+        linear_buf_free(&m_vp);
+    }    
+    return true;
+}
+
+void ActVideoExtractor::stream_buf_reset() {
+	EXTRACT_LOGT("stream_buf_reset--SRT: m_ap(a: 0x%x b: 0x%x) m_vp(a: 0x%x b: 0x%x)", 
+		m_ap.empty.a, m_ap.empty.b, m_vp.empty.a, m_vp.empty.b);
+    linear_buf_reset(&m_ap);
+    linear_buf_reset(&m_vp);
+    linear_buf_reset(&m_ap_spare);
+    linear_buf_reset(&m_vp_spare);
+    
+    
+    mQueue.clear();
+    EXTRACT_LOGT("stream_buf_reset--END: m_ap(a: 0x%x b: 0x%x) m_vp(a: 0x%x b: 0x%x)", 
+		m_ap.empty.a, m_ap.empty.b, m_vp.empty.a, m_vp.empty.b);
+}
+
+/* shrink or enlarge empty area */
+bool ActVideoExtractor::stream_buf_empty_area_update(av_buf_t *p, bool enlarge)
+{
+
+	CHECK(p);
+	packet_header_t *pht = (packet_header_t*)p->data;
+	packet_type_t t = (packet_type_t)pht->header_type;
+	stream_buf_t *s;
+	if(t == AUDIO_PACKET){
+		if(mNotPlayAudio){
+			return true;
+		}	
+		if(mApUsingSpare== false){
+			s = &m_ap;
+		}else{
+			s = &m_ap_spare;
+		} 
+	} else if(t == VIDEO_PACKET){
+		if(mNotPlayVideo){
+			return true;
+		}
+		if(mVpUsingSpare== false){
+			s = &m_vp;
+		}else{
+			s = &m_vp_spare;
+
+		}
+	    
+	} else {
+		ALOGE("stream_buf_empty_area_update: meet unknown packet type, t(0x%x), enlarge(%d)", t, enlarge);
+		return false;
+	}
+	uint8_t** pp;
+	if(enlarge == true) {/* a point */
+		pp = &s->empty.b;
+	} else {
+	  pp = &s->empty.a;
+	}
+	
+	*pp = p->data + ((p->data_len + (WORD_SIZE -1))&WORD_MASK);
+
+	return true;
+}
+
+void ActVideoExtractor::stream_buf_status_dump(stream_buf_t* t)
+{
+	BUFFER_LOGD("********stream_buf_status_dump********");
+	BUFFER_LOGD("stream_buf_t: start(%p), size(%d)",   t->start, t->size);
+    BUFFER_LOGD("    original region: (%p, %p)", t->start,   t->start + t->size);
+    BUFFER_LOGD("    now       empty: (%p, %p)", t->empty.a, t->empty.b);
+    BUFFER_LOGD("mQueue.size() is %d", mQueue.size());
+
+    List<av_buf_t>::iterator it = mQueue.begin();
+    int i = 0;
+    uint32_t used = 0;
+    while (it != mQueue.end()) {
+    	packet_header_t *p = (packet_header_t*)(*it).data;
+    	BUFFER_LOGD("    %d-th: header_type(0x%x), area(%p, %p), av_buf(%p, %d)", \
+    			i++, (uint32_t)p->header_type, (*it).data, (*it).data + (*it).data_len, \
+    			(*it).data, (*it).data_len);
+    	used += (*it).data_len;
+    	it++;
+    }
+    BUFFER_LOGD("    Used buffer size is %d in sum",  used);
+    BUFFER_LOGD("  You might need to increase stream buffer size or  just decrease the max packet size");
+}
+
+// add by cathy for print queuelist info
+void ActVideoExtractor::stream_buf_quelst(packet_type_t type)
+{
+#if 0//TURN_ON_STREAM_BUFFER_MANAGE_FLAG 
+	List<av_buf_t>::iterator its = mQueue.begin();
+	while (its != mQueue.end()) {
+		CHECK((*its).data !=NULL);
+		packet_header_t *p = (packet_header_t*)(*its).data;
+		if(p->header_type == (uint32_t)type) {
+			ALOGW("stream_buf_quelst: %s  Queue list! data:0x%x data_len: 0x%06x ", 
+			(type==VIDEO_PACKET) ? "video packet" : "audio packet", (uint32_t)(*its).data, (*its).data_len);
+		}
+		its++;
+	}
+#endif
+}
+bool ActVideoExtractor::stream_buf_assign(packet_type_t type, av_buf_t* av_buf)
+{
+	EXTRACT_LOGV("entry stream_buf_assign");
+	stream_buf_t* t=NULL;
+	stream_buf_t* t_spare=NULL;
+  uint32_t demanded=0;
+	switch (type) {
+	    case AUDIO_PACKET:
+			t = &m_ap;
+			demanded = m_pkt_maxs.a;
+			break;
+	    case VIDEO_PACKET:
+			t = &m_vp;
+			demanded = m_pkt_maxs.v;
+			break;
+	    default:
+	        ALOGE("Bad packet type(0x%x)!", type);
+	        return false;
+    }
+
+    if(t->empty.b > t->empty.a) {/*++++a___________b+++++++++++++*/
+        size_t left = t->empty.b - t->empty.a;
+        if(demanded > left) {
+
+        if(type == VIDEO_PACKET){
+
+        	
+        	 if(m_vp_spare.start==NULL){
+        	 	if(false == linear_buf_allocate(&m_vp_spare, (m_vp.size)<<1)) {
+              return false;
+            }
+        	 }
+        	 t_spare=&m_vp_spare;
+        	 mVpUsingSpare =true;
+        }else{
+
+        	 
+        	 if(m_ap_spare.start==NULL){
+        	 	if(false == linear_buf_allocate(&m_ap_spare, m_ap.size)) {
+              return false;
+            }
+        	 }
+        	 t_spare=&m_ap_spare;
+        	 mApUsingSpare =true;
+        }
+        mUsingSpare = true;
+        
+       
+        if(t_spare->empty.b > t_spare->empty.a){
+        	size_t left = t_spare->empty.b - t_spare->empty.a;
+        	if(demanded>left){
+        		 EXTRACT_LOGV("stream_buf_assign: %s Fatal error, stream-buf full --0! demanded(0x%06x) left(0x%06x), start(0x%x), size(0x%06x), a(0x%x), b(0x%x)",\
+                (type==VIDEO_PACKET) ? "video packet" : "audio packet",demanded, left, (uint32_t)t->start, t->size, 
+                (uint32_t)t_spare->empty.a, (uint32_t)t_spare->empty.b);
+          	stream_buf_status_dump(t_spare);
+          	return false;
+        	}
+        }else if(t_spare->empty.b < t_spare->empty.a){
+        	size_t left = t_spare->start + t_spare->size - t_spare->empty.a;
+        	if(demanded > left) {
+        		t_spare->empty.a = t_spare->start;
+        		left = t_spare->empty.b - t_spare->empty.a;
+        		if(demanded > left) {
+        			EXTRACT_LOGV("stream_buf_assign: %s Fatal error, stream-buf full--1! demanded(0x%06x) left(0x%06x), start(0x%x), size(0x%06x), a(0x%x), b(0x%x)",\
+				    (type==VIDEO_PACKET) ? "video packet" : "audio packet",demanded, left, (uint32_t)t->start, t->size, 
+				    (uint32_t)t_spare->empty.a, (uint32_t)t_spare->empty.b);
+						stream_buf_status_dump(t_spare);
+						return false;
+        		}
+        	}
+        }
+        av_buf->data = t_spare->empty.a;
+
+	      av_buf->data_len = 0;
+	      return true;
+
+        }
+    } else if(t->empty.b < t->empty.a){/*_______b++++++++++++++a_______*/
+        size_t left = t->start + t->size - t->empty.a;
+        if(demanded > left) {
+					t->empty.a = t->start; /*turn around*/
+					left = t->empty.b - t->empty.a;
+					if(demanded > left) {
+
+          if(type == VIDEO_PACKET){
+            
+        	 if(m_vp_spare.start==NULL){
+        	 	if(false == linear_buf_allocate(&m_vp_spare, (m_vp.size)<<1)) {
+              return false;
+            }
+        	 }
+        	 t_spare=&m_vp_spare;
+        	 mVpUsingSpare =true;
+          }else{
+          	if(m_ap_spare.start==NULL){
+        	 	if(false == linear_buf_allocate(&m_ap_spare, m_ap.size)) {
+              return false;
+            }
+        	 }
+        	 t_spare=&m_ap_spare;
+        	 mApUsingSpare =true;
+          }
+          mUsingSpare=true;
+					if(t_spare->empty.b > t_spare->empty.a){
+        		size_t left = t_spare->empty.b - t_spare->empty.a;
+        		if(demanded>left){
+        		 EXTRACT_LOGV("stream_buf_assign: %s Fatal error, stream-buf full --0! demanded(0x%06x) left(0x%06x), start(0x%x), size(0x%06x), a(0x%x), b(0x%x)",\
+                (type==VIDEO_PACKET) ? "video packet" : "audio packet",demanded, left, (uint32_t)t->start, t->size, 
+                (uint32_t)t_spare->empty.a, (uint32_t)t_spare->empty.b);
+          			stream_buf_status_dump(t_spare);
+          		return false;
+        		}
+        	}else if(t_spare->empty.b < t_spare->empty.a){
+        	size_t left = t_spare->start + t_spare->size - t_spare->empty.a;
+        	if(demanded > left) {
+        		t_spare->empty.a = t_spare->start;
+        		left = t_spare->empty.b - t_spare->empty.a;
+        		if(demanded > left) {
+        			EXTRACT_LOGV("stream_buf_assign: %s Fatal error, stream-buf full--1! demanded(0x%06x) left(0x%06x), start(0x%x), size(0x%06x), a(0x%x), b(0x%x)",\
+				    (type==VIDEO_PACKET) ? "video packet" : "audio packet",demanded, left, (uint32_t)t->start, t->size, 
+				    (uint32_t)t_spare->empty.a, (uint32_t)t_spare->empty.b);
+						stream_buf_status_dump(t_spare);
+						return false;
+        		}
+        	}
+        	}
+        	av_buf->data = t_spare->empty.a;
+
+	        av_buf->data_len = 0;
+	        return true;
+
+					}
+			
+		}
+    }else if(t->empty.b == t->empty.a) {         /*???????????????ab???????????????*/
+    	int anum = 0;
+    	int vnum = 0;
+
+    	List<av_buf_t>::iterator it = mQueue.begin();
+    	while (it != mQueue.end()) {
+            packet_header_t *p = (packet_header_t*)(*it).data;
+            if(p->header_type == AUDIO_PACKET) {
+            	anum++;
+            }else if(p->header_type == VIDEO_PACKET) {
+            	vnum++;
+            }else {
+            	EXTRACT_LOGV("This frake!");
+                stream_buf_status_dump(t);
+                return false;
+            }
+            it++;
+        }
+
+    	if (((type == AUDIO_PACKET) && (anum != 0)) ||((type == VIDEO_PACKET) && (vnum != 0))) {/*+++++++++++++++ab++++++++++++++++*/
+            ALOGE("stream_buf_assign: Error, %d demanded while 0 left..", demanded);
+            stream_buf_status_dump(t);
+            return false;
+    	}
+    	
+#if 1		
+    	size_t left = t->start + t->size - t->empty.a;
+		size_t left1 = t->empty.a - t->start; 
+		
+		if (demanded > left) {
+			//ALOGD("cathylogs: the backwork part is not enough ! (demanded: 0x%x > left: 0x%x) : %s", demanded, left, (demanded > left) ? "yes" : "no");
+        	linear_buf_reset(t);
+        } else if (demanded > left1){
+        	//ALOGD("cathylogs: the forwaord part is not enough ! (demanded: 0x%x > left1: 0x%x) : %s", demanded, left1, (demanded > left1) ? "yes" : "no");
+        }else {
+        	//nothing to do
+        }				
+#endif
+    }
+
+  av_buf->data = t->empty.a;
+	av_buf->data_len = 0;
+	EXTRACT_LOGV("stream_buf_assign: %s start: 0x%x empty.a: 0x%x empty.b: 0x%x data: 0x%x demanded: 0x%06x end: 0x%x",
+                (type==VIDEO_PACKET) ? "video packet" : "audio packet",(uint32_t)t->start,  
+                (uint32_t)t->empty.a, (uint32_t)t->empty.b, (uint32_t)av_buf->data, demanded, 
+                (uint32_t)t->start + t->size);
+	EXTRACT_LOGV("exit stream_buf_assign");
+    return true;
+}
+
+bool ActVideoExtractor::stream_buf_check_overflow(av_buf_t *av_buf)
+{
+	CHECK(av_buf);
+	uint8_t* p = av_buf->data;
+	uint32_t len = av_buf->data_len;
+    stream_buf_t *s=NULL;
+    uint32_t pkt_maxs = 0;
+
+    packet_header_t *pht = (packet_header_t*)p;
+    packet_type_t t = (packet_type_t)pht->header_type;
+
+    if (t == AUDIO_PACKET) {
+        if(mApUsingSpare== false){
+					s = &m_ap;
+				}else{
+					s = &m_ap_spare;
+				} 
+        pkt_maxs = m_pkt_maxs.a;
+    } else if(t == VIDEO_PACKET) {
+    	  if(mVpUsingSpare== false){
+					s = &m_vp;
+				}else{
+					s = &m_vp_spare;
+				} 
+    		pkt_maxs = m_pkt_maxs.v;
+    } else {
+    	ALOGE("stream_buf_check_overflow: Check this, t(0x%x)", t);
+        return false;
+    }
+
+    if (len > pkt_maxs) {
+    	ALOGE("stream_buf_check_overflow: Check this, packet(%d) exceeds packet_maxs(%d).", len, pkt_maxs);
+    }
+    if ((p < s->empty.b) && ((p + len) > s->empty.b)) {   /*++++p___________b+++++++++++++*/
+		ALOGE("stream_buf_check_overflow: Fatal, stream-buf overlapped! %p+%d > %p", p, len, s->empty.b);
+		stream_buf_status_dump(s);
+		return false;
+    } else if ((p + len) > (s->start + s->size)) {      /*_______b++++++++++++++p_______*/
+		ALOGE("stream_buf_check_overflow: Fatal, stream-buf overflow! %p+%d >%p", p, len, s->start + s->size);
+		stream_buf_status_dump(s);
+		return false;
+    }
+
+    return true;
+}
+
+bool ActVideoExtractor::stream_buf_prepare(av_buf_t *ao_buf, av_buf_t *vo_buf)
+{
+
+	ao_buf->data_len = 0;
+	vo_buf->data_len = 0;
+	mUsingSpare = false;
+	mVpUsingSpare =false;
+	mApUsingSpare =false;
+	if(false == stream_buf_assign(AUDIO_PACKET, ao_buf)) {
+		stream_buf_quelst(AUDIO_PACKET);
+		EXTRACT_LOGV("stream_buf_prepare() => stream_buf_assign audio packet error ");
+	    return false;
+	}
+	if(false == stream_buf_assign(VIDEO_PACKET, vo_buf)) {
+		stream_buf_quelst(VIDEO_PACKET);
+		EXTRACT_LOGV("stream_buf_prepare() => stream_buf_assign video packet error ");
+	    return false;
+	}
+	EXTRACT_LOGV("exit stream_buf_prepare");
+	return true;
+}
+/* push a specific type of packet to the end of fifo */
+void ActVideoExtractor::avbufItemAdd(av_buf_t* av_buf) {
+	EXTRACT_LOGV("entry avbufItemAdd");
+	CHECK(av_buf);
+	av_buf_t tmp = *av_buf;
+	//ALOGE("===add:%x==\n",av_buf->data);
+  mQueue.push_back(tmp);
+	stream_buf_empty_area_update(av_buf, false);
+	EXTRACT_LOGV("exit avbufItemAdd");
+}
+
+/* stream buffer might be ruined */
+bool ActVideoExtractor::avbufItemCheck() {
+    List<av_buf_t>::iterator it = mQueue.begin();
+    bool notruined = true;
+    while (it != mQueue.end()) {
+        packet_header_t *p = (packet_header_t*)(*it).data;
+        if(p->header_type != AUDIO_PACKET && p->header_type != VIDEO_PACKET) {
+        	ALOGE("avbufItemCheck: find !video and !audio packet info, error!!!%p, %d, 0x%x", (*it).data, (*it).data_len, p->header_type);
+        	if(notruined == true) {
+        		stream_buf_status_dump(&m_ap);
+        		stream_buf_status_dump(&m_vp);
+        	}
+        	notruined = false;
+        	/* remove this packet from stream buffer */
+        	av_buf_t tmp;
+        	tmp.data = (*it).data;
+        	tmp.data_len = (*it).data_len;
+            mQueue.erase(it);
+            stream_buf_empty_area_update(&tmp, true);
+        }
+        it++;
+    }
+
+    return notruined; /* pkt not found but nothing would be wrong */
+}
+/* find and erase a specific type of packet from fifo */
+bool ActVideoExtractor::avbufItemPick(packet_type_t t, av_buf_t* av_buf) 
+{
+
+	CHECK(av_buf);
+	int32_t audio_pkt_num=0;
+	int32_t video_pkt_num=0;
+	List<av_buf_t>::iterator it = mQueue.begin();
+	mVpUsingSpare =false;
+	mApUsingSpare =false;
+
+	
+#if 1
+	mCounter++;
+if((mVDuration- mVLastPktTime) >= DIFFTOEND){
+	if(t==VIDEO_PACKET && PLUGIN_RETURN_NORMAL == m_pstatus && m_cookie!=NULL ){
+
+
+     while(it != mQueue.end()){
+      packet_header_t *p = (packet_header_t*)(*it).data;
+      if(p->header_type ==VIDEO_PACKET){
+      	video_pkt_num++;
+      }else if(p->header_type ==AUDIO_PACKET){
+      	audio_pkt_num++;
+      }
+      it++;
+     }
+     it = mQueue.begin();
+      if(m_vp.empty.b > m_vp.empty.a){
+      	if(((m_vp.empty.b-m_vp.empty.a)>m_vp.real_size/6 && video_pkt_num<m_mi.parser_video.frame_rate && mCounter<2 && m_vp_spare.start==NULL) || ( mCounter<2 && m_vp_spare.start==NULL && audio_pkt_num<1 && (m_vp.empty.b-m_vp.empty.a)>m_vp.real_size/6)){
+      		return false;
+      	}
+      }else if(m_vp.empty.b < m_vp.empty.a){
+      	if(((m_vp.empty.a-m_vp.empty.b)<5*m_vp.real_size/6 && video_pkt_num<m_mi.parser_video.frame_rate && mCounter<2 && m_vp_spare.start==NULL) || ( mCounter<2 && m_vp_spare.start==NULL && audio_pkt_num<1 && (m_vp.empty.a-m_vp.empty.b)<5*m_vp.real_size/6)){
+      		return false;
+      	}
+      }
+  		
+	}
+}
+#endif
+  
+	while (it != mQueue.end()) {
+		CHECK((*it).data !=NULL);
+		packet_header_t *p = (packet_header_t*)(*it).data;
+		if(p->header_type == (uint32_t)t) {
+			if(t == VIDEO_PACKET && (*it).data>=m_vp_spare.start && (*it).data<
+				m_vp_spare.start+m_vp_spare.size){
+      	size_t left; 
+      	mUsingSpare = true;
+      	mVpUsingSpare = true;
+      	if(mVpSpareData==NULL){
+      		if(m_vp.real_size>m_vp.size){
+      			mVpSpareData = m_vp.start + m_vp.size;
+      		}else{
+      			mVpSpareData = m_vp.start;
+      		}
+      	} 
+      	
+      	left = m_vp.start + m_vp.real_size - mVpSpareData;
+      	if(left<(((*it).data_len + (WORD_SIZE -1))&WORD_MASK)){
+      		EXTRACT_LOGV("real_size:%d,size:%d \n",m_vp.real_size,m_vp.size);
+      		if(m_vp.real_size>m_vp.size){
+      			mVpSpareData = m_vp.start + m_vp.size;
+      		}else{
+      			mVpSpareData = m_vp.start;
+      		}
+      	}
+      	
+      	av_buf->data = (*it).data;
+      	av_buf->data_len = (*it).data_len;
+      	mQueue.erase(it);
+      	stream_buf_empty_area_update(av_buf, true);	
+			  actal_memcpy(mVpSpareData,av_buf->data,av_buf->data_len);	 
+			  av_buf->data = mVpSpareData;	
+			  mVpSpareData += ((av_buf->data_len + (WORD_SIZE -1))&WORD_MASK);
+			  
+      }else if(t == AUDIO_PACKET && (*it).data>=m_ap_spare.start && (*it).data<m_ap_spare.start+m_ap_spare.size){
+      	 	size_t left; 
+      	mApUsingSpare = true;
+      	if(mApSpareData==NULL){
+      		if(m_ap.real_size>m_ap.size){
+      			mApSpareData = m_ap.start + m_ap.size;
+      		}else{
+      			mApSpareData = m_ap.start;
+      		}
+      	} 
+      	
+      	left = m_ap.start + m_ap.real_size - mApSpareData;
+      	if(left<(((*it).data_len + (WORD_SIZE -1))&WORD_MASK)){
+      		if(m_ap.real_size>m_ap.size){
+      			mApSpareData = m_ap.start + m_ap.size;
+      		}else{
+      			mApSpareData = m_ap.start;
+      		}
+      	}
+      	
+      	av_buf->data = (*it).data;
+      	av_buf->data_len = (*it).data_len;
+      	mQueue.erase(it);
+      	stream_buf_empty_area_update(av_buf, true);	
+			  actal_memcpy(mApSpareData,av_buf->data,av_buf->data_len);	 
+			  av_buf->data = mApSpareData;	
+
+			  mApSpareData += ((av_buf->data_len + (WORD_SIZE -1))&WORD_MASK);
+      }else{
+      	av_buf->data = (*it).data;			
+			  av_buf->data_len = (*it).data_len;
+			  mQueue.erase(it);
+
+			  stream_buf_empty_area_update(av_buf, true);
+      }
+			EXTRACT_LOGV("exit avbufItemPick");
+            return true;
+    }
+    it++;
+  }
+
+	EXTRACT_LOGV("exit avbufItemPick false");
+  return false; /* pkt not found but nothing would be wrong */
+}
+
+packet_type_t ActVideoExtractor::matchPacketType(size_t track_idx)
+{
+	Mutex::Autolock autoLock(mLock);  // add by cathy 2011-12-14 ---9
+	EXTRACT_LOGV("entry matchPacketType");
+	packet_type_t t=(packet_type_t)UNKNOWN_PACKET;
+	if (track_idx == m_ti_playing.v){
+	    t = VIDEO_PACKET;
+	}else if (track_idx == m_ti_playing.a){
+	    t = AUDIO_PACKET;
+	} else {
+	    t = (packet_type_t)UNKNOWN_PACKET;
+	    ALOGE("matchPacketType() => track_idx (%d) UNKNOWN_PACKET", track_idx);
+	}
+	EXTRACT_LOGV("exit matchPacketType");
+	return t;
+}
+
+/* FIXME */
+status_t ActVideoExtractor::notifyEvent(EVENT_T msg, int ext1, int ext2)
+{
+	switch (msg) {
+		case EXTRACTOR_SUBMIT_SUB_BUF: 
+			{
+				SUB_LOGD("EXTRACTOR_SUBMIT_SUB_BUF with m_cookie(%p)", m_cookie);
+				av_buf_t *ppkt = (av_buf_t*) ext1;
+
+				if (m_cookie) {
+					AwesomePlayer* p = reinterpret_cast<AwesomePlayer*> (m_cookie);
+					//appendfile("/data/sori.raw", ppkt->data, ppkt->data_len);
+					#ifdef SUB_ENABLE //disable now
+					p->notifyMe(MEDIA_SUB, (int) (ppkt->data), ext2/*ppkt->data_len*/); /* FIXME */
+					#endif
+				} else {
+					ALOGE("m_cookie = NULL!");
+				}
+				break;
+			}
+		default:
+			break;
+	}
+
+	return OK;
+}
+
+/*
+ * retval:
+ * true
+ *    m_out_buf fills the av_buf's packet!
+ * else
+ *    m_out_buf be invalid
+ */
+status_t ActVideoExtractor::getPacket(av_buf_t* av_buf, packet_type_t t) {
+	Mutex::Autolock autoLock(mLock);
+
+
+    av_buf->data = NULL;
+    av_buf->data_len = 0;
+ //   m_pstatus = PLUGIN_RETURN_NORMAL;
+	int32_t loop_times=0;
+  mCounter=0;
+    while (1) {
+		{
+		loop_times ++;
+		Mutex::Autolock autoLock(mMiscStateLock);   // add by cathy 2011-12-14 ---11
+        if(true == avbufItemPick(t, av_buf)) {
+            /* a priviously parsed data be found  most recently used stream data */
+			if (t == AUDIO_PACKET) {
+        		m_ao_buf = *av_buf;
+        	} else if(t == VIDEO_PACKET) {
+        		m_vo_buf = *av_buf;
+        		
+        	} else {
+            	ALOGE("getPacket: Check this, t(0x%x)", t);
+                return MEDIA_ERROR_BASE;
+        	}
+            return OK;
+        } else if (PLUGIN_RETURN_FILE_END == m_pstatus) {  /* file ended and fifo ended */
+            ALOGW("getPacket: fifo ended(To file ended)");
+            return ERROR_END_OF_STREAM;
+        } else {
+        	if (loop_times > MAX_GET_PACKETS_LOOP_TIMES) {
+        		//ALOGW("getPacket: %s packet meet INFO_NO_RAW_DATA_NOW after find %d packets TID: %d", 
+        		//	(t == VIDEO_PACKET) ? "vidieo" : "audio", loop_times, gettid());
+        		ALOGE("===loop exceed max times===\n");
+        		return ERROR_END_OF_STREAM;
+       // 		return INFO_NO_RAW_DATA_NOW;
+        	}
+        }
+ 		}
+        av_buf_t ao_buf;
+        av_buf_t vo_buf;
+				ao_buf.data = NULL;
+    		ao_buf.data_len = 0;
+				vo_buf.data = NULL;
+    		vo_buf.data_len = 0;
+		if(false == stream_buf_prepare(&ao_buf, &vo_buf)) {
+			EXTRACT_LOGV("getPacket: stream_buf_prepare() BUFFER_TOO_SMALL error!!!");
+            return ERROR_BUFFER_TOO_SMALL;
+        }
+		
+		{
+		    Mutex::Autolock autoLock(mMiscStateLock); // add by cathy 2011-12-14 ---12
+
+        m_pstatus = (plugin_err_no_t)m_dp->parse_stream(m_dh, &ao_buf, &vo_buf);
+
+		//add by bruce 2013-07-05 
+			if (vo_buf.data_len){
+				packet_header_t *pht = (packet_header_t*)vo_buf.data;
+				mVLastPktTime = (int64_t)pht->packet_ts * 1000;
+			} else if (ao_buf.data_len){
+				packet_header_t *pht = (packet_header_t*)ao_buf.data;
+				mALastPktTime = (int64_t)pht->packet_ts * 1000;				
+			}
+        }
+
+        if ((PLUGIN_RETURN_NORMAL != m_pstatus)&&(PLUGIN_RETURN_FILE_END != m_pstatus)) {
+        	if (((mVDuration- mVLastPktTime) <= MINIMUM_LASTPK_TIMEDIFF) || ((mADuration- mALastPktTime) <= MINIMUM_LASTPK_TIMEDIFF)){
+				ALOGW("getPacket: parse end of file m_pstatus: %d mVDuration: %lld mADuration: %lld mVLastPktTime: %lld mALastPktTime: %lld", 
+							m_pstatus, mVDuration, mADuration, mVLastPktTime, mALastPktTime);
+				return ERROR_END_OF_STREAM; 
+        	}else {
+				ALOGE("getPacket: parse_stream()  error !!!m_pstatus: %d mVDuration: %lld mADuration: %lld mVLastPktTime: %lld mALastPktTime: %lld", 
+							m_pstatus, mVDuration, mADuration, mVLastPktTime, mALastPktTime);
+            	return MEDIA_ERROR_BASE;  /* packet not found FIXME*/
+        	}
+        }
+
+        if ((ao_buf.data_len==0) && (vo_buf.data_len==0)) {
+        	if (PLUGIN_RETURN_FILE_END == m_pstatus) {
+				ALOGE("getPacket: parser return fifo ended(To file ended)");
+				return ERROR_END_OF_STREAM;
+        	}
+            continue;
+        }
+				
+		av_buf_t insert;
+		if (vo_buf.data_len) {
+
+
+			Mutex::Autolock autoLock(mMiscStateLock);
+			insert = vo_buf;
+			if (insert.data_len<=SIZE_PHT) {
+				if (PLUGIN_RETURN_FILE_END == m_pstatus) {
+					ALOGE("getPacket: parser return fifo ended(size: %d) && no av data!!!", insert.data_len);
+					return ERROR_END_OF_STREAM;
+				}
+				continue;
+			}
+		
+			CHECK(insert.data_len>SIZE_PHT);
+			packet_header_t *pht = (packet_header_t*)insert.data;
+#ifdef MMM_ENABLE_SUBTITLE   			
+			if(vo_buf.data_len != 0/* && need_subtitle == 1*/)	{	
+							
+				packet_header_t *packet_header =(packet_header_t *)vo_buf.data;
+				//SUB_LOGD("header_type %x",packet_header->header_type);
+				if(packet_header->header_type < SUBPIC_PACKET)	{		    
+				    	if(put_subtitle_packet_flag == 1){
+					        if(packet_header_org != NULL){
+				        		//SUB_LOGD("0 input %x\n",packet_header_org);
+				        		SUB_LOGD("0 str is %s\n",((char *)packet_header_org+28));
+							SUB_LOGD("0 reserved_count %d\n",reserved_count);					        		
+				        		packet_header_org->reserved2 = reserved_count;
+							SUB_LOGD("0 packet_header_org->reserved2 = %d",packet_header_org->reserved2);
+								
+				        		subtitle_buf_No_0++;
+				        		if(subtitle_buf_No_0 == MMM_SUBTITLE_NUM){
+						        	subtitle_buf_No_0 = 0;
+						       }
+							SUB_LOGD("0 memset, subtitle_buf_No_0 = %d",subtitle_buf_No_0);
+						       actal_memset(subtitle_data[subtitle_buf_No_0],0,MMM_SUBTITLE_DATA_LEN);
+				        	}
+				        	put_subtitle_packet_flag = 0;
+				        }
+				}else{				 
+				        if(vo_buf.data_len>MMM_SUBTITLE_DATA_LEN){
+				        	ALOGE("%s %d over!!\n",__FILE__,__LINE__);
+				        }
+				        SUB_LOGD("pkt_prv_ts %d, ts %d\n",pkt_prv_ts,packet_header->packet_ts);				       
+				        if((unsigned int)pkt_prv_ts != packet_header->packet_ts){
+			        	     if(put_subtitle_packet_flag == 1){
+					            if(packet_header_org != NULL){
+					            		//SUB_LOGD("1 input %x\n",packet_header_org);
+					            		SUB_LOGD("1 str is %s\n",((char *)packet_header_org+28));
+					            		packet_header_org->reserved2 = reserved_count;
+								SUB_LOGD("1 packet_header_org->reserved2 = %d",packet_header_org->reserved2);		
+					            		subtitle_buf_No_0++;
+					            		if(subtitle_buf_No_0 == MMM_SUBTITLE_NUM){
+							            	subtitle_buf_No_0 = 0;
+							       }
+								SUB_LOGD("1 memset, subtitle_buf_No_0 = %d",subtitle_buf_No_0);
+							       actal_memset(subtitle_data[subtitle_buf_No_0],0,MMM_SUBTITLE_DATA_LEN);
+					            	}
+				            		put_subtitle_packet_flag = 0;
+				            	}
+			             		put_subtitle_packet_flag = 1;
+				        	pkt_prv_ts = packet_header->packet_ts;
+				        	SUB_LOGD("pkt len %d, pkt_prv_ts %d\n",vo_buf.data_len,pkt_prv_ts);
+						SUB_LOGD("2 memecpy, subtitle_buf_No_0 = %d, len = %d",subtitle_buf_No_0,vo_buf.data_len);
+						actal_memcpy(subtitle_data[subtitle_buf_No_0],vo_buf.data,vo_buf.data_len);
+						SUB_LOGD("2 str is %*.*s\n",vo_buf.data_len-28,vo_buf.data_len-28,(vo_buf.data+28));
+						packet_header_tmp = (packet_header_t *)(subtitle_data[subtitle_buf_No_0]);
+						packet_header_org = packet_header_tmp;	
+						SUB_LOGD("2 packet_header_org->reserved2 = 0");
+						packet_header_org->reserved2 = 0;
+						addr_oft = 0;
+						SUB_LOGD("2 reserved_count = 1");
+						reserved_count = 1;
+					}else	{	
+						addr_oft += (packet_header_tmp->block_len + 28 +3)&(~3);						
+						reserved_count++;
+						SUB_LOGD("3 reserved_count = %d",reserved_count);
+						if(addr_oft + vo_buf.data_len>MMM_SUBTITLE_DATA_LEN)
+						{
+							actal_error("%s %d over!!\n",__FILE__,__LINE__);
+						}
+						//SUB_LOGD("addr_oft %d",addr_oft);
+						SUB_LOGD("3 str is %*.*s\n",vo_buf.data_len-28,vo_buf.data_len-28,(vo_buf.data+28));
+						SUB_LOGD("3 memecpy, subtitle_buf_No_0 = %d, len = %d",subtitle_buf_No_0,vo_buf.data_len);
+						actal_memcpy((subtitle_data[subtitle_buf_No_0] + addr_oft),vo_buf.data,vo_buf.data_len);
+						packet_header_tmp = (packet_header_t *)(subtitle_data[subtitle_buf_No_0] + addr_oft);
+						SUB_LOGD("now data len %d\n",(addr_oft+vo_buf.data_len));
+					}
+			   	 }
+			}
+#endif
+			//mVLastPktTime = (int64_t)pht->packet_ts * 1000;
+			if(pht->header_type == SUBPIC_PACKET) {
+				notifyEvent(EXTRACTOR_SUBMIT_SUB_BUF, (int)&insert, 0);			
+			} else {
+				/* nessasary */
+	            if(false == stream_buf_check_overflow(&insert)) {
+					ALOGE("getPacket: stream_buf_check_overflow() video buffer too small(size: %d)!!!", insert.data_len);
+					return ERROR_BUFFER_TOO_SMALL;
+				}
+				EXTRACT_LOGD("getPacket: add video packet");
+				avbufItemAdd(&insert);
+			}
+		}
+	
+		if (ao_buf.data_len){
+			Mutex::Autolock autoLock(mMiscStateLock);
+			insert = ao_buf;
+			if (insert.data_len<=SIZE_PHT) {
+				if (PLUGIN_RETURN_FILE_END == m_pstatus) {
+					ALOGE("getPacket: parser return fifo ended(size: %d) && no av data!!!", insert.data_len);
+					return ERROR_END_OF_STREAM;
+				}
+				continue;
+			}
+			CHECK(insert.data_len>SIZE_PHT);
+			packet_header_t *pht = (packet_header_t*)insert.data;
+			//mALastPktTime = (int64_t)pht->packet_ts * 1000;
+			if(pht->header_type == SUBPIC_PACKET) {				
+				//notifyEvent(EXTRACTOR_SUBMIT_SUB_BUF, (int)&insert, 0);			
+			} else {/* nessasary */
+	            if(false == stream_buf_check_overflow(&insert)) {
+					ALOGE("getPacket: stream_buf_check_overflow() audio buffer too small(size: %d)!!!", insert.data_len);
+					return ERROR_BUFFER_TOO_SMALL;
+				}
+				if (pht->header_type == AUDIO_PACKET) {
+					EXTRACT_LOGD("getPacket: add audio packet mAlwaysDropAudio: %d", mAlwaysDropAudio);
+            		if(mAlwaysDropAudio == 0) {
+						avbufItemAdd(&insert);
+					}
+				}
+			}
+		}
+    }
+	EXTRACT_LOGV("exit getPacket");
+    return OK;
+}
+
+bool ActVideoExtractor::test()
+{
+    sp<ActVideoSource>* p;
+    sp<ActVideoSource> v;
+    sp<ActVideoSource> a;
+    int64_t at = 0;
+    int64_t vt = 0;
+    MediaBuffer *out;
+    MediaSource::ReadOptions options;
+    bool rt = true;
+
+/* p->buf */
+#if 0
+    if(m_mi.parser_audio[0].buf) {
+    	out = new MediaBuffer(m_mi.parser_audio[0].buf + SIZE_PHT, 12);
+    	output_mediabuffer(out, AUDIO_PACKET);
+    }
+#endif
+    EXTRACT_LOGD("Now playing: v(%d), a(%d), s(%d)", m_ti_playing.v, m_ti_playing.a, m_ti_playing.s);
+    v = new ActVideoSource(this, m_ti_playing.v);
+    a = new ActVideoSource(this, m_ti_playing.a);
+
+    while (1) {
+        EXTRACT_LOGD("Audio/Video time(%d/%d)", (uint32_t)at, (uint32_t)vt);
+        if(at < vt) {
+            rt = a->read(&out, &options);
+            if(rt != OK) {
+                ALOGE("test: call audio read() return error: %d", rt);
+                break;
+            }
+            out->meta_data()->findInt64(kKeyTime, &at);
+            EXTRACT_LOGD("Audio time(%d)", (uint32_t)at);
+         	output_mediabuffer(out, AUDIO_PACKET);
+        } else {
+            rt = v->read(&out, &options);
+            if(rt != OK) {
+                ALOGE("test: call video read() return error: %d", rt);
+                break;
+            }
+            out->meta_data()->findInt64(kKeyTime, &vt);
+            EXTRACT_LOGD("Video time(%d)", (uint32_t)vt);
+            output_mediabuffer(out, VIDEO_PACKET);
+        }
+    }
+    m_input->seek(m_input, 0, DSEEK_SET);
+
+    return true;
+}
+
+ActVideoExtractor::ActVideoExtractor(const sp<DataSource> &source, const char* mime, void* cookie)
+	: m_dh(NULL),
+	  m_dp(NULL),
+	  m_input(NULL),
+	  m_cookie(cookie),
+	  m_pstatus(PLUGIN_RETURN_NORMAL),
+	  m_fstatus(true),
+	  mExtractorFlags(CAN_PAUSE),
+	  mLib_handle(NULL),
+	  mEtm(&kExtToMime[0]),
+	  mAEtm(&kAExtToMime[0]),
+	  mNotPlayVideo(false),
+	  mNotPlayAudio(false),
+	  mUsingSpare(false),
+	  mApUsingSpare(false),
+	  mVpUsingSpare(false),
+	  mIsSetTrack(false),
+	  mVpSpareData(NULL),
+	  mApSpareData(NULL),
+	  mUnsupportAudioTrackNum(0),
+	  mVLastPktTime(0),
+	  mADuration(0),
+	  m_exist_location(false),
+	  mALastPktTime(0),
+	  mVDuration(0){
+	/* 1 */
+	mQueue.clear();
+  ALOGE("===mime is %s====\n",mime);
+  actal_memset(&m_vp,0,sizeof(stream_buf_t));
+  actal_memset(&m_vp_spare,0,sizeof(stream_buf_t));
+  actal_memset(&m_ap,0,sizeof(stream_buf_t));
+  actal_memset(&m_ap_spare,0,sizeof(stream_buf_t));
+	m_input = stream_input_open();
+	if(!m_input){
+		ALOGE("ActVideoExtractor() => stream_input_open() error !!!");
+	    return;
+	}
+
+	CHECK(m_input!=NULL);
+	/* 2 */
+	if(false == stream_input_init(m_input, source)) {
+		ALOGE("ActVideoExtractor() => stream_input_init() error !!!");
+	 //   return;
+	}
+
+	/* 3 */
+	if(false == open_plugin(mime)) {
+		ALOGE("ActVideoExtractor() => open_plugin() error !!!");
+		 if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+	    return;
+	}
+
+	memset(&m_mi, 0, sizeof(media_info_t));
+	m_dh = m_dp->open((void*)m_input, &m_mi);
+	if (!m_dh) {
+		ALOGE("ActVideoExtractor() => demuxer open(%p)  error && maybe unsupport stream!!!", m_dh);
+		 if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+		return;
+	}
+	CHECK(m_dh!=NULL);
+
+	/* 4 */
+	if(false == stream_buf_init()) {
+		ALOGE("ActVideoExtractor() => stream_buf_init() error !!!");
+		m_dp->dispose(m_dh);
+		m_dp = NULL;
+		m_dh = NULL;
+	    if (mLib_handle) {
+			dlclose( mLib_handle);
+			mLib_handle = NULL;
+		}
+	    return;
+	}
+
+	/* 5 */
+	addTracks();
+	if(mNotPlayVideo==false && (m_mi.parser_video.width==0 || m_mi.parser_video.height==0)){
+		return;
+	}
+
+	/* test */
+	media_info_print(&m_mi);
+//	test();
+	mSeekFailed = 0;
+	mAlwaysDropAudio = 0; 
+
+	#if ONLY_PLAY_VIDEO_FLAG
+	mNotPlayAudio = true;
+	#endif
+
+	#if ONLY_PLAY_AUDIO_FLAG
+	mNotPlayVideo = true;
+	#endif
+	
+}
+
+ActVideoExtractor::~ActVideoExtractor() {
+	EXTRACT_LOGV("~ActVideoExtractor()");
+    if(m_dh) {
+        m_dp->dispose(m_dh);
+		m_dp = NULL;
+		m_dh = NULL;
+    }
+		
+	if (mLib_handle) {
+        dlclose(mLib_handle);
+        mLib_handle = NULL;
+	}
+    if(m_input){
+        stream_input_dispose(m_input);
+    }
+	//  actal_ion_close();
+    stream_buf_destroy();
+    mQueue.clear();
+}
+
+size_t ActVideoExtractor::countTracks() {
+    EXTRACT_LOGV("countTracks(%d)", mTracks.size());
+    return mTracks.size();
+}
+
+sp<MediaSource> ActVideoExtractor::getTrack(size_t index) {
+    if (index >= mTracks.size()) {
+		ALOGE("getTrack() error =>  (index >= mTracks.size())");
+        return NULL;
+    }
+    return new ActVideoSource(this, index);
+}
+
+sp<MetaData> ActVideoExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if (index >= mTracks.size()) {
+		ALOGE("getTrackMetaData() error => (index >= mTracks.size())");
+        return NULL;
+    }
+
+    return mTracks.itemAt(index).mMeta;
+}
+
+void log_track_param(track_param_t* tp)
+{
+    AUDIOTRACK_LOGD("log_track_param:");
+    AUDIOTRACK_LOGD("    a_pos: 0x%08x", tp->a_pos);
+    AUDIOTRACK_LOGD("    a_pts: %d",     tp->a_pts);
+    AUDIOTRACK_LOGD("    v_pos: 0x%08x", tp->v_pos);
+    AUDIOTRACK_LOGD("    v_pts: %d",     tp->v_pts);
+    AUDIOTRACK_LOGD("    cut_t: %d",     tp->cur_time);
+    AUDIOTRACK_LOGD("    index: %d",     tp->track_num);
+    AUDIOTRACK_LOGD("    out_basetime: %d",     tp->out_basetime);
+}
+uint32_t ActVideoExtractor::getFirstAudioTime()
+{
+	EXTRACT_LOGV("getFirstAudioTime: m_ts.found_audio_time: %d", m_ts.found_audio_time);
+	return m_ts.found_audio_time;
+}
+status_t ActVideoExtractor::seek(int64_t seekTimeUs)
+{
+	Mutex::Autolock autoLock(mLock);
+	EXTRACT_LOGT("seek: seekTimeUs(%lld)", seekTimeUs);
+    CHECK(m_dp != NULL);
+    CHECK(m_dh != NULL);
+
+#ifdef MMM_ENABLE_SUBTITLE 
+
+	{
+		actal_memset(subtitle_data,0,MMM_SUBTITLE_DATA_LEN*MMM_SUBTITLE_NUM);
+		subtitle_buf_No_0 = 0;
+		subtitle_buf_No_1 = 0;
+		subtitle_get_flag = 0;
+		pkt_prv_ts = -1; 
+		packet_header_tmp = NULL;
+		packet_header_org = NULL;
+		addr_oft = 0;	
+		reserved_count = 0;
+		put_subtitle_packet_flag = 0;
+	}
+
+#endif
+
+    m_ts.seek_time = (unsigned int)((seekTimeUs + 500)/1000);
+    m_ts.cur_time = 0;
+    m_ts.found_audio_time = m_ts.found_video_time = m_ts.seek_time;
+
+     m_pstatus = (plugin_err_no_t)m_dp->seek(m_dh, &m_ts);
+    if(m_pstatus == PLUGIN_RETURN_NORMAL) {
+    	EXTRACT_LOGT("seek: seekTimeUs: %lld m_ts.found_audio_time: %d m_ts.found_video_time: %d m_ts.seek_time: %d", 
+			seekTimeUs, m_ts.found_audio_time, m_ts.found_video_time, m_ts.seek_time);
+		stream_buf_reset();
+		mVpSpareData=NULL;
+		mApSpareData=NULL;
+		EXTRACT_LOGT("exit seek");
+    	return OK;
+    }else {
+    	ALOGW("seek: call m_dp->seek() meet %s", m_pstatus==PLUGIN_RETURN_FILE_END ? "end of stream" : "error");
+    	if (m_pstatus == PLUGIN_RETURN_FILE_END) {
+    		return ERROR_END_OF_STREAM;
+    	}
+    	return !OK;
+    }
+}
+
+status_t ActVideoExtractor::setAudioTrack(int index, int64_t cur_playing_time)
+{
+    Mutex::Autolock autoLock(mLock);
+
+    ALOGD("%s:  total %d audio track, from %d to %d, current time: %d us)", __FUNCTION__, \
+    	m_mi.audio_num, m_ti_playing.a, index, (int32_t)cur_playing_time);
+
+    if (index < 0 || (uint32_t)index > m_mi.audio_num ||
+        m_ti_playing.a == (size_t)-1) {
+    	ALOGE("parameter err. index(%d)", index);
+		return INVALID_OPERATION;
+    }
+
+    int pi = m_ti_playing.a /*- 1*/; /* !!! */
+    if (m_mi.audio_num <= 1 || (size_t)pi == (size_t)index) {
+    		return INVALID_OPERATION;
+    }
+
+	  sp<MetaData> meta = getTrackMetaData(index/*+1*/,0);
+	    const char *_mime;
+	    CHECK(meta->findCString(kKeyMIMEType, &_mime));
+	    String8 mime = String8(_mime);
+
+	if (!(strncasecmp(mime.string(), "audio/unsupport", sizeof("audio/unsupport")))) {
+		ALOGW("The current track format(%s) not support!!!", mime.string());
+		return INVALID_OPERATION;
+	}
+
+
+    CHECK(m_dp != NULL);
+    CHECK(m_dh != NULL);
+
+    track_param_t tp;
+    packet_header_t *ph;
+
+    ph = (packet_header_t*)m_ao_buf.data;
+    if(ph != NULL) {
+    	tp.a_pos = ph->packet_offset;
+    	tp.a_pts = ph->packet_ts;
+    }
+
+    ph = (packet_header_t*)m_vo_buf.data;
+    if(ph != NULL) {
+    	tp.v_pos = ph->packet_offset;
+    	tp.v_pts = ph->packet_ts;
+    }
+
+    tp.cur_time = (int32_t)(cur_playing_time/1000);
+    tp.out_basetime = 0;
+    tp.track_num = index-1;
+
+    log_track_param(&tp);
+
+    if(0 != m_dp->ex_ops(m_dh, SET_TRACK, (uint32_t)&tp)) {
+        ALOGE("setAudioTrack()->ex_ops SET_TRACK error!");
+        return UNKNOWN_ERROR;
+    }
+
+    if((tp.cur_time - tp.out_basetime) < 0) {
+    	ALOGE("ex_ops SET_TRACK error, cur_time:%d, out_baseTime:%d!", tp.cur_time, tp.out_basetime);
+    	return UNKNOWN_ERROR;
+    }
+
+    log_track_param(&tp);
+
+    stream_buf_reset();
+    m_ti_playing.a = index /*+ 1*/; /* !!! */
+    sp < MetaData > m = mTracks.itemAt(m_ti_playing.a).mMeta;
+    m->setInt64(kKeyDriftTime, (((uint64_t)tp.cur_time)<<32) | ((uint64_t)(tp.cur_time - tp.out_basetime)));
+
+    mIsSetTrack=true;
+    AUDIOTRACK_LOGD("Set m_ti_playing.a to %d, audioOffset: %d ms", m_ti_playing.a, tp.cur_time - tp.out_basetime);
+
+    return OK;
+}
+
+const char* ActVideoExtractor::setSubTrack(int index, int64_t cur_playing_time)
+{
+    Mutex::Autolock autoLock(mLock);
+    SUB_LOGD("m_ti_playing.s(%d), m_mi.sub_num(%d), index(%d)", \
+        m_ti_playing.a, m_mi.sub_num, index);
+
+    if ((index < 0) || ((uint32_t)index >= m_mi.sub_num) ||
+        (m_ti_playing.s == (size_t)-1)) {
+    	ALOGE("setSubTrack()->parameter err. index(%d)", index);
+        return NULL;
+    }
+
+    int pi = m_ti_playing.s;
+    if ((m_mi.sub_num <= 0) || (size_t)pi == (size_t)index)
+        return (const char*)m_mi.parser_subtitle[index].buf;
+
+    CHECK(m_dp != NULL);
+    CHECK(m_dh != NULL);
+
+    track_param_t tp;
+    packet_header_t *ph=NULL;
+   memset(&tp, 0, sizeof(track_param_t));
+    ph = (packet_header_t*)m_ao_buf.data;
+    if(ph!=NULL) {
+    	tp.a_pos = ph->packet_offset;
+    	tp.a_pts = ph->packet_ts;
+    }
+    ph = (packet_header_t*)m_vo_buf.data;
+    if(ph!=NULL) {
+    	tp.v_pos = ph->packet_offset;
+    	tp.v_pts = ph->packet_ts;
+    }
+    tp.cur_time = (int32_t)(cur_playing_time/1000);
+    tp.out_basetime = 0;
+    tp.track_num = index;
+
+    log_track_param(&tp);
+
+    if(0 != m_dp->ex_ops(m_dh, SET_SUBPIC, (uint32_t)&tp)) {
+        ALOGE("setSubTrack()->ex_ops SET_SUBPIC error!");
+        return NULL;
+    }
+	
+#ifdef MMM_ENABLE_SUBTITLE
+    need_subtitle = 1;
+#endif 
+    m_ti_playing.s = index;
+
+    return (const char*)m_mi.parser_subtitle[index].buf;
+}
+
+#ifdef MMM_ENABLE_SUBTITLE  
+int64_t ActVideoExtractor::getsubtitle()
+{
+	if(m_mi.sub_num < 1){
+		ALOGW("no subtitle");
+		return -1;
+	}
+	Mutex::Autolock autoLock(mLock);
+	packet_header_t *packet_header =(packet_header_t *)subtitle_data[subtitle_buf_No_1];
+	if(subtitle_get_flag == 0&& packet_header->header_type != 0&&packet_header->reserved2 >= 1){
+		SUB_LOGD("return packet_ts %d\n",packet_header->packet_ts);
+		SUB_LOGD("getsubtitle: set subtitle_get_flag = 1");	
+		subtitle_get_flag = 1;
+		return packet_header->packet_ts*1000;
+	}else{
+		//SUB_LOGD("subtitle_get_flag %d  packet_header->header_type %d",subtitle_get_flag,packet_header->header_type);
+ 		return -1;
+ 	}
+}
+
+int ActVideoExtractor::putsubtitle()
+{
+	Mutex::Autolock autoLock(mLock);
+	packet_header_t *packet_header =(packet_header_t *)subtitle_data[subtitle_buf_No_1];
+    av_buf_t sub_buf;
+    int sub_buf_len,i,sub_buf_num,sub_buf_oft;
+    unsigned char *ph = subtitle_data[subtitle_buf_No_1];
+    SUB_LOGD("putsubtitle: reserved2 = %d, subtitle_buf_No_1 = %d",packet_header->reserved2,subtitle_buf_No_1);
+    sub_buf_len = 0; 
+    sub_buf_num = packet_header->reserved2;  
+    if(packet_header->reserved2 >= 1){
+	    	//actal_memcpy((unsigned char *)args,subtitle_data[subtitle_buf_No_1],MMM_SUBTITLE_DATA_LEN);
+	    	sub_buf.data = subtitle_data[subtitle_buf_No_1];
+	    	sub_buf.data_len = MMM_SUBTITLE_DATA_LEN;
+		SUB_LOGD("putsubtitle: set subtitle_get_flag = 0");	
+	    	subtitle_get_flag = 0;
+	    	subtitle_buf_No_1++;
+	    	if(subtitle_buf_No_1 == MMM_SUBTITLE_NUM){
+	        	subtitle_buf_No_1 = 0;
+	        }
+	    	//packet_header->reserved2 = 0;
+	    	for(i=0;i<sub_buf_num;i++){
+		    	//SUB_LOGD("0packet_header->block_len %d",packet_header->block_len);
+		    	sub_buf_oft = (packet_header->block_len + sizeof(packet_header_t) + 3)&(~3);
+		    	sub_buf_len += sub_buf_oft;
+			SUB_LOGD("putsubtitle: sub_buf_len = %d, sub_buf_oft = %d",sub_buf_len,sub_buf_oft);
+			ph += sub_buf_oft;
+			packet_header = (packet_header_t *)ph;					
+		}	   
+	    	notifyEvent(EXTRACTOR_SUBMIT_SUB_BUF, (int)(&sub_buf), sub_buf_len);    
+	    	return 0;
+    }   else    {
+	       ALOGW("putsubtitle return -1");
+	    	return -1;
+    }	
+}
+
+int ActVideoExtractor::waitsubtitle()
+{
+	Mutex::Autolock autoLock(mLock);	
+	SUB_LOGD("waitsubtitle: set subtitle_get_flag = 0");	
+    	subtitle_get_flag = 0;    	
+    	return 0;    
+}
+int ActVideoExtractor::dropsubtitle()
+{
+    	Mutex::Autolock autoLock(mLock);
+    	packet_header_t *packet_header =(packet_header_t *)subtitle_data[subtitle_buf_No_1];   
+    	SUB_LOGD("dropsubtitle: reserved2 = %d, subtitle_buf_No_1 = %d",packet_header->reserved2,subtitle_buf_No_1);   
+    	if(packet_header->reserved2 >= 1) {    	
+		SUB_LOGD("dropsubtitle: set subtitle_get_flag = 0");	
+	    	subtitle_get_flag = 0;
+	    	subtitle_buf_No_1++;
+	    	if(subtitle_buf_No_1 == MMM_SUBTITLE_NUM){
+	        	subtitle_buf_No_1 = 0;
+	        }    	
+	    	return 0;
+   	 }else{
+	       ALOGW("dropsubtitle return -1");
+	    	return -1;
+    	}	
+}
+
+
+#endif
+
+sp<MetaData> ActVideoExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    char tmp[32] = {'v', 'i', 'd', 'e', 'o', '/', '\0'};
+    char location[18] ={'+','0','0','.','0','0','0','0','-', '1','8','0','.','0','0','0','0','\0'};
+    if(m_ext && strlen(m_ext) + strlen(tmp) <= sizeof(tmp)) {
+    	strcat(tmp, m_ext);
+    	EXTRACT_LOGV("getMetaData kKeyMIMEType(%s)", tmp);
+    } else {
+    	ALOGE("getMetaData() => set kKeyMIMEType para. error");
+    }
+
+    meta->setCString(kKeyMIMEType, (const char *)tmp);
+    meta->setPointer(kKeyActMediaInfo, (void*)(&m_mi));
+    if(m_exist_location==true){
+    	strcpy(location,(char*)(&(m_mi.v_len_array[3])));
+    	meta->setCString(kKeyLocation,(const char*)location);
+    }
+    	 
+
+    return meta;
+}
+
+bool ActVideoExtractor::seekable() {
+	if (mExtractorFlags & (CAN_SEEK_BACKWARD | CAN_SEEK_FORWARD | CAN_SEEK)) {
+		return true;
+	}else{
+		ALOGE("seekable: seek flag(0x%x) error!!!", mExtractorFlags);
+		return false;
+	}
+}
+
+uint32_t ActVideoExtractor::flags() const {
+	EXTRACT_LOGV("flags(0x%x)", mExtractorFlags);
+	return mExtractorFlags;
+}
+
+inline int toupper(int c)
+{
+    c = ((c)>='a' && (c)<='z')? (c)-('a'-'A'):(c);
+    return c;
+}
+
+char* strtoupper(char* dst, const char* src)
+{
+	const char* p = src;
+	char* q = dst;
+	if(!dst)
+		return dst;
+
+	do {
+		*q++ = toupper(*p++);
+	} while (*p != '\0');
+
+	EXTRACT_LOGD("%s strtoupper is %s", src, dst);
+	return dst;
+}
+
+status_t getNextNalUnit(
+        const uint8_t **_data, size_t *_size,
+        const uint8_t **nalStart, size_t *nalSize,
+        bool startCodeFollows) {
+    const uint8_t *data = *_data;
+    size_t size = *_size;
+
+    *nalStart = NULL;
+    *nalSize = 0;
+
+    if (size == 0) {
+        return -EAGAIN;
+    }
+
+    // Skip any number of leading 0x00.
+
+    size_t offset = 0;
+    while (offset < size && data[offset] == 0x00) {
+        ++offset;
+    }
+
+    if (offset == size) {
+        return -EAGAIN;
+    }
+
+    // A valid startcode consists of at least two 0x00 bytes followed by 0x01.
+
+    if (offset < 2 || data[offset] != 0x01) {
+        return ERROR_MALFORMED;
+    }
+
+    ++offset;
+
+    size_t startOffset = offset;
+
+    for (;;) {
+        while (offset < size && data[offset] != 0x01) {
+            ++offset;
+        }
+
+        if (offset == size) {
+            if (startCodeFollows) {
+                offset = size + 2;
+                break;
+            }
+
+            return -EAGAIN;
+        }
+
+        if (data[offset - 1] == 0x00 && data[offset - 2] == 0x00) {
+            break;
+        }
+
+        ++offset;
+    }
+
+    size_t endOffset = offset - 2;
+    while (endOffset > startOffset + 1 && data[endOffset - 1] == 0x00) {
+        --endOffset;
+    }
+
+    *nalStart = &data[startOffset];
+    *nalSize = endOffset - startOffset;
+
+    if (offset + 2 < size) {
+        *_data = &data[offset - 2];
+        *_size = size - offset + 2;
+    } else {
+        *_data = NULL;
+        *_size = 0;
+    }
+
+    return OK;
+}
+
+
+bool getAVCHeaderInfo(void *buf,  int32_t *Length){
+	const uint8_t *nalStart=NULL;
+	const uint8_t *seqStart=NULL;
+	const uint8_t * data = NULL;
+	size_t nalSize=0;
+	size_t size = 0;
+	
+	int32_t headerLen = 0;
+	uint8_t   getHeaderFlag=0;
+	int32_t seqLen = 0;
+	
+	data = (uint8_t *)buf;
+	size = 1024; 
+	
+	ALOGI("getAVCHeaderInfo--: data: 0x%x size: %d", (void *)data, size);
+	while (getNextNalUnit(&data, &size, &nalStart, &nalSize, true) == OK) {
+		unsigned nalType = nalStart[0] & 0x1f;
+
+		if (nalType == 7) {
+			 headerLen += nalSize + 4;
+			 getHeaderFlag |= 1;
+			 ALOGI("getAVCHeaderInfo-0: nalType: %d nalSize: %d headerLen: %d getHeaderFlag: %d", nalType, nalSize, headerLen, getHeaderFlag);
+		}else if (nalType == 8) {
+			headerLen += nalSize + 4;
+			getHeaderFlag |= 2; 
+			ALOGI("getAVCHeaderInfo-1: nalType: %d nalSize: %d headerLen: %d getHeaderFlag: %d", nalType, nalSize, headerLen, getHeaderFlag);
+		}else{
+			ALOGI("getAVCHeaderInfo-2: nalType: %d nalSize: %d headerLen: %d getHeaderFlag: %d", nalType, nalSize, headerLen, getHeaderFlag);
+		}
+		
+		if ((getHeaderFlag & 0x3) == 0x3) {
+			seqLen = headerLen + ((int32_t)seqStart - (int32_t)buf);
+			ALOGI("getAVCHeaderInfo-3: nalType: %d nalSize: %d headerLen: %d getHeaderFlag: %d seqStart: 0x%x buf: 0x%x", 
+					nalType, nalSize, headerLen, getHeaderFlag, (void *)seqStart, (void *)buf);
+			break;
+		}else if ((getHeaderFlag & 0x3) == 0x1) {
+			 seqStart = nalStart - 4;
+		}else{
+		}
+		
+	}
+
+	if (0){
+		FILE *fp1=fopen("/data/juan/seq1.264", "a+");
+		if (fp1 == NULL) {
+			ALOGE("open /data/juan/seq1.264 failed");
+		}else {
+			fwrite(buf, 1, seqLen, fp1);
+			fclose(fp1);
+		}
+	}
+
+	ALOGI("getAVCHeaderInfo-4: headerLen: %d seqLen: %d getHeaderFlag: %d seqStart: 0x%x buf: 0x%x", 
+			headerLen, seqLen, getHeaderFlag, (void *)seqStart, (void *)buf);
+
+	*Length = seqLen;
+	return true;
+}
+
+
+void ActVideoExtractor::addTracks() {
+	/* clear now playing track indexs*/
+	m_ti_playing.s = m_ti_playing.a = m_ti_playing.v = (size_t)-1;
+
+	if(!m_mi.index_flag) {
+		mExtractorFlags |= CAN_SEEK_BACKWARD | CAN_SEEK_FORWARD | CAN_SEEK | CAN_PAUSE;
+		EXTRACT_LOGD("addTracks: set index_flag(0x%x) mExtractorFlags(0x%x)", m_mi.index_flag, mExtractorFlags);
+	}
+
+	/* video */
+	parser_video_t *pv = &m_mi.parser_video;
+	sp<MetaData> meta = new MetaData;
+	if (pv->buf) {
+	#if 0 //for video_1_demo.mkv seek problem
+		if (!strcasecmp(pv->extension, "h264")) {
+			int32_t Length=0;
+			getAVCHeaderInfo(pv->buf, &Length);
+			meta->setInt32(kKeyActVDHrdLen, Length);
+			ALOGI("call getAVCHeaderInfo(pv->buf: 0x%x Length: %d)", pv->buf, Length);
+		}
+	#endif
+	 bool mNotNeedkKeyActVDPrv = (strncmp("mp4", m_ext, 3)==0 && strncmp("mpeg", pv->extension, 4)==0);
+	 if(!mNotNeedkKeyActVDPrv){
+	 	meta->setPointer(kKeyActVDPrv, pv->buf);
+	 }	
+
+		
+		
+		EXTRACT_LOGD("addTracks: sets Actions' VCodecs' privdata ");
+	}
+	size_t kNumExtToMime = sizeof(kExtToMime) / sizeof(kExtToMime[0]);
+	size_t i;
+	for (i = 0; i < kNumExtToMime; ++i) {
+		if (!strcasecmp(pv->extension, kExtToMime[i].ext)) {
+			mEtm = &kExtToMime[i];
+			break;
+		}
+	}	
+	if(!strncmp("mp4", m_ext, 3)){
+    	if(m_mi.v_len_array[0]>0){
+    		meta->setInt32(kKeyRotation, m_mi.v_len_array[1]);
+    	}else{
+    		m_mi.v_len_array[1]=0;
+    	}  	
+    	if(m_mi.v_len_array[2]>0){
+    		m_exist_location=true;
+    	}
+  }
+	CHECK(mEtm->mime != NULL);
+	if (!strcasecmp(mEtm->mime, "video/unsupport")) {
+		mNotPlayVideo = true;
+		ALOGW(" Not support video format(%s)",pv->extension);		
+	}
+	meta->setCString(kKeyMIMEType, mEtm->mime);  
+    if (!strcmp(mEtm->mime, MEDIA_MIMETYPE_VIDEO_VP6)
+    	|| !strcmp(mEtm->mime, MEDIA_MIMETYPE_VIDEO_VP8)
+    	|| !strcmp(mEtm->mime, MEDIA_MIMETYPE_VIDEO_WMV8)) {
+    	ALOGD("kKeyWidth/kKeyHeight set with 16 alignment");
+
+        meta->setInt32(kKeyWidth, /*(pv->width + 15)&(~15)*/pv->width);
+        meta->setInt32(kKeyHeight, /*(pv->height + 15)&(~15)*/pv->height);
+    } else {
+    	ALOGD("kKeyWidth/kKeyHeight set with no alignment");
+
+        meta->setInt32(kKeyWidth, /*(pv->width + 15)&(~15)*/pv->width);
+        meta->setInt32(kKeyHeight, /*(pv->height + 15)&(~15)*/pv->height);
+    }
+	meta->setInt32(kKeyBitRate, (int32_t)m_mi.parser_video.video_bitrate);
+	meta->setInt64(kKeyActFrmRate, (int64_t)m_mi.parser_video.frame_rate);
+	mVDuration = mADuration = ((int64_t)(m_mi.total_time))*1000;
+	meta->setInt64(kKeyDuration, mVDuration/*ms to us*/);
+		
+	 /* for decoder's(specific for CODA) stream buffer size FIXME */
+    CHECK(m_pkt_maxs.v);
+	ALOGD("addTracks: video format(%s) kKeyMIMEType: %s kKeyMaxInputSize: %d bytes", pv->extension,  mEtm->mime, m_pkt_maxs.v);
+	meta->setInt32(kKeyMaxInputSize, (int32_t)m_pkt_maxs.v);
+	
+	mTracks.push();
+	TrackInfo *trackInfo = &mTracks.editItemAt(mTracks.size() - 1);
+	trackInfo->mMeta = meta;
+	m_ti_playing.v = 0; /* video track index */
+
+	/* audio */
+	for(uint32_t i=0; i<m_mi.audio_num; i++) {
+		parser_audio_t *pa = &m_mi.parser_audio[i];
+		sp<MetaData> meta = new MetaData;
+		const char* ext = NULL;
+		char mimetmp[18] = {'a', 'u', 'd', 'i', 'o', '/', '\0'};
+		size_t j;
+		kNumExtToMime = sizeof(kAExtToMime) / sizeof(kAExtToMime[0]);
+		for (j= 0; j < kNumExtToMime; ++j) {
+			if (!strcasecmp(pa->extension, kAExtToMime[j].ext)) {
+				mAEtm = &kAExtToMime[j];
+				break;
+			}
+		}		
+		CHECK(mAEtm->mime != NULL);
+		if (!strcasecmp(mAEtm->mime, "unsupport")) {	
+			mUnsupportAudioTrackNum++;			
+			ALOGW(" Not support audio format(%s)",pa->extension);			
+		}
+		memcpy(&mimetmp[6], mAEtm->mime, mAEtm->len);
+		ALOGD("addTracks: pa->extension: %s mimetmp: %s    mAEtm->mime: %s", pa->extension, mimetmp, mAEtm->mime);
+		meta->setCString(kKeyMIMEType, mimetmp);  
+		meta->setInt32(kKeySampleRate, pa->sample_rate);
+		meta->setInt32(kKeyChannelCount, pa->channels);
+		meta->setInt64(kKeyDuration, mADuration);
+		meta->setInt32(kKeyBitRate, (int32_t)pa->audio_bitrate);
+		meta->setInt32(kKeyMaxInputSize, (int32_t)m_pkt_maxs.a);
+		
+		if (pa->buf && strcasecmp(mAEtm->mime, "unsupport")) {
+			meta->setPointer(kKeyESDS, (void*)(((uint8_t*)pa->buf) + SIZE_PHT));
+			ALOGE("initbuf:%x\n",((uint8_t*)pa->buf) + SIZE_PHT);
+		}
+
+		mTracks.push();
+		TrackInfo *trackInfo = &mTracks.editItemAt(mTracks.size() - 1);
+		trackInfo->mMeta = meta;
+		if(i == 0) {
+			m_ti_playing.a = 1; /* audio track index */
+		}
+	}
+ 
+	if(mUnsupportAudioTrackNum==m_mi.audio_num){
+		ALOGW("Not play audio!");		
+		mNotPlayAudio = true;
+	}
+	if(m_ti_playing.a == (size_t)-1) {
+		//ALOGD("-------------- %s, m_ti_playing.a(%d) ", __FUNCTION__, m_ti_playing.a);
+		mAlwaysDropAudio = 1;
+	}
+	/* subtitle */
+	for(uint32_t i=0; i<m_mi.sub_num; i++) {
+		parser_subtitle_t *ps = &m_mi.parser_subtitle[i];
+		sp<MetaData> meta = new MetaData;
+		/* fixme */
+		char mimetmp[24] = {'s', 'u', 'b', 't', 'i', 't', 'l', 'e', '/', '\0'};
+		strtoupper(&mimetmp[strlen(mimetmp)], (const char*)ps->extension);
+		EXTRACT_LOGD("addTracks: mime(%d): %s", i, mimetmp);
+		meta->setCString(kKeyMIMEType, (const char*)mimetmp);
+
+		mTracks.push();
+		TrackInfo *trackInfo = &mTracks.editItemAt(mTracks.size() - 1);
+		trackInfo->mMeta = meta;
+		if(i == 0) {
+			m_ti_playing.s = 0;
+		}
+	}
+	EXTRACT_LOGV("exit addTracks()  OK");
+}
+
+}  // namespace android
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index a859e4a..1c82ee7 100755
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -8,6 +8,13 @@ ifeq ($(BOARD_HTC_3D_SUPPORT),true)
 endif
 
 LOCAL_SRC_FILES:=                         \
+        ActAudioExtractor.cpp             \
+        ActDataSource.cpp                 \
+        ActAudioDownMix.cpp               \
+        ActAudioDecoder.cpp               \
+        ActAudioEncoder.cpp               \
+        ActAudioWriter.cpp                \
+        ActVideoExtractor.cpp             \
         ACodec.cpp                        \
         AACExtractor.cpp                  \
         AACWriter.cpp                     \
@@ -67,11 +74,19 @@ LOCAL_SRC_FILES+=                         \
 endif
 
 LOCAL_C_INCLUDES:= \
+        $(call include-path-for, alsp) \
+        $(TOP)/system/core/include/ion \
+        $(TOP)/device/actions/gs702a/include \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/external/flac/include \
         $(TOP)/external/tremolo \
-        $(TOP)/external/openssl/include
+        $(TOP)/external/openssl/include \
+        $(TOP)/frameworks/av/media/libstagefright/vendor/al_libc \
+        $(TOP)/frameworks/av/include/alsp/inc \
+        $(TOP)/hardware/libhardware/include/hardware \
+        $(TOP)/frameworks/av/media/libstagefright/vendor/mmminfo \
+        $(TOP)/frameworks/av/include/alsp/inc/common
 
 ifneq ($(TI_CUSTOM_DOMX_PATH),)
 LOCAL_C_INCLUDES += $(TI_CUSTOM_DOMX_PATH)/omx_core/inc
@@ -156,6 +171,8 @@ LOCAL_STATIC_LIBRARIES := \
         libstagefright_httplive \
         libstagefright_id3 \
         libFLAC \
+        libmmminfo \
+        libid3parser \
 
 LOCAL_SRC_FILES += \
         chromium_http_stub.cpp
@@ -168,9 +185,11 @@ LOCAL_SHARED_LIBRARIES += \
         libstagefright_enc_common \
         libstagefright_avc_common \
         libstagefright_foundation \
-        libdl
+        libdl \
+        libalc
 
 LOCAL_CFLAGS += -Wno-multichar
+LOCAL_CFLAGS += -DTURN_ON_MIDDLEWARE_FLAG
 
 ifeq ($(BOARD_USE_SAMSUNG_COLORFORMAT), true)
 LOCAL_CFLAGS += -DUSE_SAMSUNG_COLORFORMAT
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 80b64c2..97cd9f6 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -49,6 +49,7 @@ AudioPlayer::AudioPlayer(
       mReachedEOS(false),
       mFinalStatus(OK),
       mStarted(false),
+      mPause(false),
       mIsFirstBuffer(false),
       mFirstBufferResult(OK),
       mFirstBuffer(NULL),
@@ -189,13 +190,14 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
 
     mStarted = true;
     mPinnedTimeUs = -1ll;
+    mPause = false;
 
     return OK;
 }
 
 void AudioPlayer::pause(bool playPendingSamples) {
     CHECK(mStarted);
-
+    mPause = true;
     if (playPendingSamples) {
         if (mAudioSink.get() != NULL) {
             mAudioSink->stop();
@@ -218,7 +220,7 @@ void AudioPlayer::pause(bool playPendingSamples) {
 
 void AudioPlayer::resume() {
     CHECK(mStarted);
-
+    mPause = false;
     if (mAudioSink.get() != NULL) {
         mAudioSink->start();
     } else {
@@ -274,6 +276,7 @@ void AudioPlayer::reset() {
     mReachedEOS = false;
     mFinalStatus = OK;
     mStarted = false;
+    mPause = false;
 }
 
 // static
@@ -562,6 +565,12 @@ int64_t AudioPlayer::getMediaTimeUs() {
 
         return 0;
     }
+    
+    if(mPause == true) //cz-20121009锟斤拷锟斤拷停状态锟狡猴拷锟酵诧拷要锟劫讹拷取系统时锟戒，直锟接凤拷锟斤拷media时锟斤拷
+    {
+      return mPositionTimeMediaUs;  
+    }
+
 
     int64_t realTimeOffset = getRealTimeUsLocked() - mPositionTimeRealUs;
     if (realTimeOffset < 0) {
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 1b1ba37..e73ca4a 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -68,8 +68,10 @@
 
 #include <cutils/properties.h>
 
+#include <include/ActAudioDecoder.h>
+
 #define USE_SURFACE_ALLOC 1
-#define FRAME_DROP_FREQ 0
+#define FRAME_DROP_FREQ 10
 #define LPA_MIN_DURATION_USEC_ALLOWED 30000000
 #define LPA_MIN_DURATION_USEC_DEFAULT 60000000
 
@@ -212,11 +214,18 @@ AwesomePlayer::AwesomePlayer()
       mVideoBuffer(NULL),
       mDecryptHandle(NULL),
       mLastVideoTimeUs(-1),
-      mTextDriver(NULL) {
+      mTextDriver(NULL),
+      mIsStreamingFlag(false) {
     CHECK_EQ(mClient.connect(), (status_t)OK);
 
     DataSource::RegisterDefaultSniffers();
 
+#ifndef TURN_ON_MIDDLEWARE_FLAG
+    mUsingMidwareAudioDecFlag = false;
+#else
+    mUsingMidwareAudioDecFlag = true;
+#endif
+
     mVideoEvent = new AwesomeEvent(this, &AwesomePlayer::onVideoEvent);
     mVideoEventPending = false;
     mStreamDoneEvent = new AwesomeEvent(this, &AwesomePlayer::onStreamDone);
@@ -298,6 +307,10 @@ void AwesomePlayer::printStats() {
     }
 }
 
+bool AwesomePlayer::getStreamingFlag() {
+    return mIsStreamingFlag;
+}
+
 void AwesomePlayer::cancelPlayerEvents(bool keepNotifications) {
     mQueue.cancelEvent(mVideoEvent->eventID());
     mVideoEventPending = false;
@@ -399,12 +412,16 @@ status_t AwesomePlayer::setDataSource(const sp<IStreamSource> &source) {
 
 status_t AwesomePlayer::setDataSource_l(
         const sp<DataSource> &dataSource) {
-    sp<MediaExtractor> extractor = MediaExtractor::Create(dataSource);
+    sp<MediaExtractor> extractor = MediaExtractor::Create(dataSource,NULL,this);
 
     if (extractor == NULL) {
         return UNKNOWN_ERROR;
     }
 
+    if (extractor->getUsingMidwwareFlag() == false) {
+        mUsingMidwareAudioDecFlag = false;
+    }
+    
     if (extractor->getDrmFlag()) {
         checkDrmStatus(dataSource);
     }
@@ -469,6 +486,12 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
         String8 mime = String8(_mime);
 
         if (!haveVideo && !strncasecmp(mime.string(), "video/", 6)) {
+            if (!(strncasecmp(mime.string(), "video/unsupport", sizeof("video/unsupport")))) {
+                ALOGE("setDataSource_l: unsupport video format(%s)!!!", mime.string());
+                haveVideo = false;
+                continue;
+            }
+            
             setVideoSource(extractor->getTrack(i));
             haveVideo = true;
 
@@ -496,6 +519,11 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
                 !QCUtilityClass::helper_Awesomeplayer_checkIfAudioDisable() &&
 #endif
                     !strncasecmp(mime.string(), "audio/", 6)) {
+            if (!(strncasecmp(mime.string(), "audio/unsupport", sizeof("audio/unsupport")))) {
+                ALOGE("setDataSource_l: unsupport audio format(%s)!!!", mime.string());
+                haveAudio = false;
+                continue;
+            }
             setAudioSource(extractor->getTrack(i));
             haveAudio = true;
             mActiveAudioTrackIndex = i;
@@ -509,7 +537,8 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
                 stat->mMIME = mime.string();
             }
 
-            if (!strcasecmp(mime.string(), MEDIA_MIMETYPE_AUDIO_VORBIS)) {
+            if (!strcasecmp(mime.string(), MEDIA_MIMETYPE_AUDIO_VORBIS) ||
+                !strcasecmp(mime.string(), MEDIA_MIMETYPE_AUDIO_ACT_OGG)) {
                 // Only do this for vorbis audio, none of the other audio
                 // formats even support this ringtone specific hack and
                 // retrieving the metadata on some extractors may turn out
@@ -632,6 +661,7 @@ void AwesomePlayer::reset_l() {
     mTimeSourceDeltaUs = 0;
     mVideoTimeUs = 0;
 
+    mLastSetAudioTrackTimeUs = 0;
     mSeeking = NO_SEEK;
     mSeekNotificationSent = true;
     mSeekTimeUs = 0;
@@ -707,7 +737,7 @@ bool AwesomePlayer::getBitrate(int64_t *bitrate) {
 bool AwesomePlayer::getCachedDuration_l(int64_t *durationUs, bool *eos) {
     int64_t bitrate;
 
-    if (mCachedSource != NULL && getBitrate(&bitrate)) {
+    if (mCachedSource != NULL && getBitrate(&bitrate) && (bitrate > 0)) {
         status_t finalStatus;
         size_t cachedDataRemaining = mCachedSource->approxDataRemaining(&finalStatus);
         *durationUs = cachedDataRemaining * 8000000ll / bitrate;
@@ -1373,6 +1403,17 @@ status_t AwesomePlayer::setSurfaceTexture(const sp<ISurfaceTexture> &surfaceText
     Mutex::Autolock autoLock(mLock);
 
     status_t err;
+    char cts_value[PROPERTY_VALUE_MAX];
+    int32_t isCTSFlag = 0;
+    property_get("ro.build_mode", cts_value, "NORMAL");
+    if (!strncmp(cts_value, "CTS",3)) {
+        isCTSFlag = 1;
+    } else {
+        isCTSFlag = 0;        
+    }
+    if (isCTSFlag == 0) {
+        usleep(200*1000);
+    }
     if (surfaceTexture != NULL) {
         err = setNativeWindow_l(new SurfaceTextureClient(surfaceTexture));
     } else {
@@ -1689,6 +1730,9 @@ status_t AwesomePlayer::initAudioDecoder() {
                 false, // createEncoder
                 mAudioTrack, matchComponentName, flags,NULL);
 #else
+        if (mIsStreamingFlag) {
+            mAudioTrack->getFormat()->setInt32(kKeyActStreamingFlag, mIsStreamingFlag);
+        }
         mAudioSource = OMXCodec::Create(
                 mClient.interface(), mAudioTrack->getFormat(),
                 false, // createEncoder
@@ -1696,6 +1740,7 @@ status_t AwesomePlayer::initAudioDecoder() {
 #endif
     }
 
+
     if (mAudioSource != NULL) {
         int64_t durationUs;
         if (mAudioTrack->getFormat()->findInt64(kKeyDuration, &durationUs)) {
@@ -1787,11 +1832,30 @@ status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
     }
 #endif
     ALOGV("initVideoDecoder flags=0x%x", flags);
+    if (mIsStreamingFlag) {
+        mVideoTrack->getFormat()->setInt32(kKeyActStreamingFlag, mIsStreamingFlag);
+    }
+    sp<MetaData> meta = mExtractor->getMetaData();
+    const char *ConMimeType;
+    bool success = meta->findCString(kKeyMIMEType,&ConMimeType);
+    if (mIsStreamingFlag == true && success == true) {
+        success = !strcasecmp(ConMimeType, MEDIA_MIMETYPE_CONTAINER_WVM);                                       
+        if (success == true) {          
+            flags |= OMXCodec::kPreferSoftwareCodecs;
+        }
+    }
     mVideoSource = OMXCodec::Create(
             mClient.interface(), mVideoTrack->getFormat(),
             false, // createEncoder
             mVideoTrack,
             NULL, flags, USE_SURFACE_ALLOC ? mNativeWindow : NULL);
+    
+    if (mIsStreamingFlag == true && success == true) {
+        success = !strcasecmp(ConMimeType, MEDIA_MIMETYPE_CONTAINER_WVM);
+        if (success == true) {
+            flags &= ~(OMXCodec::kPreferSoftwareCodecs); 
+        }
+    }
 
     if (mVideoSource != NULL) {
         int64_t durationUs;
@@ -1996,6 +2060,7 @@ void AwesomePlayer::onVideoEvent() {
     }
 
     int64_t timeUs;
+    int32_t framewidth;
     CHECK(mVideoBuffer->meta_data()->findInt64(kKeyTime, &timeUs));
 
     mLastVideoTimeUs = timeUs;
@@ -2032,6 +2097,10 @@ void AwesomePlayer::onVideoEvent() {
     TimeSource *ts =
         ((mFlags & AUDIO_AT_EOS) || !(mFlags & AUDIOPLAYER_STARTED))
             ? &mSystemTimeSource : mTimeSource;
+    
+    if (mVideoSource->getFormat()->findInt32(kKeyWidth,&framewidth) && framewidth > 3840) {
+        ts = &mSystemTimeSource;
+    }
 
     if (mFlags & FIRST_FRAME) {
         modifyFlags(FIRST_FRAME, CLEAR);
@@ -2053,6 +2122,7 @@ void AwesomePlayer::onVideoEvent() {
         mTimeSourceDeltaUs = realTimeUs - mediaTimeUs;
     }
 
+#ifndef TURN_ON_MIDDLEWARE_FLAG
     if (wasSeeking == SEEK_VIDEO_ONLY) {
         nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
 
@@ -2064,6 +2134,7 @@ void AwesomePlayer::onVideoEvent() {
             ALOGI("after SEEK_VIDEO_ONLY we're late by %.2f secs", latenessUs / 1E6);
         }
     }
+#endif
 
     if (wasSeeking == NO_SEEK) {
         // Let's display the first frame after seeking right away.
@@ -2074,6 +2145,7 @@ void AwesomePlayer::onVideoEvent() {
 
         ATRACE_INT("Video Lateness (ms)", latenessUs / 1E3);
 
+#ifndef TURN_ON_MIDDLEWARE_FLAG
         if (latenessUs > 500000ll
                 && mAudioPlayer != NULL
                 && mAudioPlayer->getMediaTimeMapping(
@@ -2097,14 +2169,14 @@ void AwesomePlayer::onVideoEvent() {
                 ALOGI("we're very late (%.2f secs)", latenessUs / 1E6);
             }
         }
+#endif
 
         if (latenessUs > 40000) {
             // We're more than 40ms late.
             ALOGE("we're late by %lld us nowUs %lld, timeUs %lld",
                   latenessUs, nowUs, timeUs);
 
-            if (!(mFlags & SLOW_DECODER_HACK)
-                    || mSinceLastDropped > FRAME_DROP_FREQ)
+            if (mSinceLastDropped > FRAME_DROP_FREQ)
             {
                 ALOGV("we're late by %lld us (%.2f secs) dropping "
                      "one after %d frames",
@@ -2342,6 +2414,7 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         String8 newURI = String8("http://");
         newURI.append(mUri.string() + 11);
 
+        mIsStreamingFlag = true;
         mUri = newURI;
     }
 
@@ -2350,6 +2423,8 @@ status_t AwesomePlayer::finishSetDataSource_l() {
     if (!strncasecmp("http://", mUri.string(), 7)
             || !strncasecmp("https://", mUri.string(), 8)
             || isWidevineStreaming) {
+        mIsStreamingFlag = true;
+        ALOGI("finishSetDataSource_l: https:// http:// isWidevineStreaming: %d mIsStreamingFlag: %d", isWidevineStreaming, mIsStreamingFlag);
         mConnectingDataSource = HTTPBase::Create(
                 (mFlags & INCOGNITO)
                     ? HTTPBase::kFlagIncognito
@@ -2369,6 +2444,9 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         mLock.lock();
 
         if (err != OK) {
+            ALOGE("finishSetDataSource_l: mConnectingDataSource->connect() !OK returned %d", err);
+            mNewUri= mConnectingDataSource->getUri();
+            ALOGI("finishSetDataSource_l: set new uri length: %d uri: %s", mNewUri.length(), mNewUri.string());
             mConnectingDataSource.clear();
 
             ALOGI("mConnectingDataSource->connect() returned %d", err);
@@ -2442,8 +2520,9 @@ status_t AwesomePlayer::finishSetDataSource_l() {
                         float confidence;
                         sp<AMessage> meta;
                         if (!dataSource->sniff(&tmp, &confidence, &meta)) {
-                            mLock.lock();
-                            return UNKNOWN_ERROR;
+                            //mLock.lock();
+                            //return UNKNOWN_ERROR;
+                            break;
                         }
 
                         // We successfully identified the file's extractor to
@@ -2516,8 +2595,12 @@ status_t AwesomePlayer::finishSetDataSource_l() {
             mWVMExtractor->setUID(mUID);
         extractor = mWVMExtractor;
     } else {
+#ifndef TURN_ON_MIDDLEWARE_FLAG
         extractor = MediaExtractor::Create(
                 dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str());
+#else
+        extractor = MediaExtractor::Create(dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str(), this);
+#endif
 
         if (extractor == NULL) {
             return UNKNOWN_ERROR;
@@ -2528,6 +2611,10 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         checkDrmStatus(dataSource);
     }
 
+    if (extractor->getUsingMidwwareFlag() == false) {
+        mUsingMidwareAudioDecFlag = false;
+    }
+
     status_t err = setDataSource_l(extractor);
 
     if (err != OK) {
@@ -2631,7 +2718,7 @@ void AwesomePlayer::postAudioEOS(int64_t delayUs) {
 }
 
 void AwesomePlayer::postAudioSeekComplete() {
-    postCheckAudioStatusEvent(0);
+    postCheckAudioStatusEvent(50000);
 }
 
 status_t AwesomePlayer::setParameter(int key, const Parcel &request) {
@@ -2725,6 +2812,103 @@ status_t AwesomePlayer::getTrackInfo(Parcel *reply) const {
     return OK;
 }
 
+#if 1
+status_t AwesomePlayer::selectAudioTrack_l(const sp<MediaSource>& source,size_t index) {
+        ALOGV("Entry setAudioTrack()");
+        ALOGD("setAudioTrack : %d", index);
+    CHECK(mExtractor != NULL);
+    if ((ssize_t)index == mActiveAudioTrackIndex) {
+            ALOGI("Track %d is active. Does nothing.", index);
+            return OK;
+    }
+
+    bool setTrackAtPlaying = false;   
+
+    // setAudioTrack() would be called by APP at prepare() when starting;  do not need to call pause_l();
+    if(mFlags & PLAYING) {
+        setTrackAtPlaying = true;
+        ALOGI("setAudioTrack at playing, now pause");
+        //make sure we get the proper extractor status and data
+        pause_l();
+        //FIXME : make sure awesomeplayer idle;
+        //usleep(30000);        
+    }else{
+        ALOGI("setAudioTrack at pause or beginning");
+    }
+        
+
+    int64_t realTimeUs, mediaTimeUs, deltaUs, nowUs;
+    TimeSource *ts = (mFlags & AUDIO_AT_EOS) ? &mSystemTimeSource : mTimeSource;
+
+    if (!(mFlags & AUDIO_AT_EOS) && mAudioPlayer != NULL
+        && mAudioPlayer->getMediaTimeMapping(&realTimeUs, &mediaTimeUs)) {
+                deltaUs = realTimeUs - mediaTimeUs;
+                nowUs = ts? (ts->getRealTimeUs()- deltaUs) : 0;
+                mLastSetAudioTrackTimeUs = nowUs;       
+    }else{      //audioplayer not start
+                if(!setTrackAtPlaying){ 
+                        ALOGI("setAudioTrack again at pause state, use mLastSetAudioTrackTimeUs %lld",mLastSetAudioTrackTimeUs);
+                        nowUs = mLastSetAudioTrackTimeUs;               
+                }else{  
+                        nowUs = ts? ts->getRealTimeUs():0;
+                        mLastSetAudioTrackTimeUs = nowUs;       
+                }
+    }
+
+    status_t ret = mExtractor->setAudioTrack(index, nowUs);
+    if(ret == INVALID_OPERATION)
+    {
+        //do nothing
+        ALOGW("INVALID_OPERATION, index:%d,  nowUs: %lld ", index, nowUs);
+        ret = OK;
+    } else if (ret == OK) {
+
+        mAudioTrack.clear();
+        setAudioSource(mExtractor->getTrack(index));
+
+        if (mAudioPlayer == NULL && mAudioSource != NULL) {
+ALOGE("mAudioSource stop start1 \n");
+            mAudioSource->stop();
+ALOGE("mAudioSource stop end1 \n");
+        }
+
+        mAudioSource.clear();
+   
+        ret = initAudioDecoder();
+        delete mAudioPlayer;
+
+        mAudioPlayer = NULL;
+
+         modifyFlags(AUDIOPLAYER_STARTED, CLEAR);
+         modifyFlags(AUDIO_RUNNING, CLEAR);
+                
+        if(ret == NO_ERROR) {
+            mTimeSource = NULL;
+        if (mAudioSource != NULL) {
+                if (mAudioPlayer == NULL) {
+                    if (mAudioSink != NULL) {
+                        mAudioPlayer = new AudioPlayer(mAudioSink,false, this);
+                        mAudioPlayer->setSource(mAudioSource);
+                            }
+                        }
+                        mTimeSource = mAudioPlayer;     
+                }
+  
+        } else {
+                ALOGE("%s %d error", __FUNCTION__, __LINE__);;
+        }
+    }   
+
+    if(setTrackAtPlaying) {
+        ALOGI("resume playing after setAudioTrack");
+        play_l();
+    } 
+
+    ALOGV("Exit setAudioTrack()");
+    mActiveAudioTrackIndex = index;
+    return ret;
+}
+#else
 status_t AwesomePlayer::selectAudioTrack_l(
         const sp<MediaSource>& source, size_t trackIndex) {
 
@@ -2795,6 +2979,7 @@ status_t AwesomePlayer::selectAudioTrack_l(
 
     return OK;
 }
+#endif
 
 status_t AwesomePlayer::selectTrack(size_t trackIndex, bool select) {
     ATRACE_CALL();
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index f7d452b..66862c4 100755
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -321,6 +321,7 @@ status_t CameraSource::configureCamera(
     getSupportedVideoSizes(*params, &isSetVideoSizeSupportedByCamera, sizes);
     bool isCameraParamChanged = false;
     if (width != -1 && height != -1) {
+#if 0
         if (!isVideoSizeSupported(width, height, sizes)) {
             ALOGE("Video dimension (%dx%d) is unsupported", width, height);
             return BAD_VALUE;
@@ -331,6 +332,16 @@ status_t CameraSource::configureCamera(
             params->setPreviewSize(width, height);
         }
         isCameraParamChanged = true;
+#endif
+        //should use max preview size? fixed later
+        if (isVideoSizeSupported(width, height, sizes)) {
+            if (isSetVideoSizeSupportedByCamera) {
+                params->setVideoSize(width, height);
+            } else {
+                params->setPreviewSize(width, height);
+            }
+            isCameraParamChanged = true;
+        }
     } else if ((width == -1 && height != -1) ||
                (width != -1 && height == -1)) {
         // If one and only one of the width and height is -1
@@ -418,17 +429,23 @@ status_t CameraSource::checkVideoSize(
     // Check the actual video frame size against the target/requested
     // video frame size.
     if (width != -1 && height != -1) {
-        if (frameWidthActual != width || frameHeightActual != height) {
-            ALOGE("Failed to set video frame size to %dx%d. "
-                    "The actual video size is %dx%d ", width, height,
-                    frameWidthActual, frameHeightActual);
-            return UNKNOWN_ERROR;
+        if (mIsMetaDataStoredInVideoBuffers == false) {
+            if (frameWidthActual > width || frameHeightActual > height) {
+                ALOGE("Failed to set video frame size to %dx%d. "
+                        "The actual video size is %dx%d ", width, height,
+                        frameWidthActual, frameHeightActual);
+                return UNKNOWN_ERROR;
+            }
         }
     }
 
     // Good now.
+#if 0    
     mVideoSize.width = frameWidthActual;
     mVideoSize.height = frameHeightActual;
+#endif
+    mVideoSize.width = width;
+    mVideoSize.height = height;
     return OK;
 }
 
@@ -522,11 +539,21 @@ status_t CameraSource::initWithCameraAccess(
         return err;
     }
 
+    // By default, do not store metadata in video buffers
+    mIsMetaDataStoredInVideoBuffers = false;
+    mCamera->storeMetaDataInBuffers(false);
+    if (storeMetaDataInVideoBuffers) {
+        if (OK == mCamera->storeMetaDataInBuffers(true)) {
+            mIsMetaDataStoredInVideoBuffers = true;
+        }
+    }
+
     // Set the camera to use the requested video frame size
     // and/or frame rate.
     if ((err = configureCamera(&params,
                     videoSize.width, videoSize.height,
                     frameRate))) {
+        mIsMetaDataStoredInVideoBuffers = false;
         return err;
     }
 
@@ -534,8 +561,10 @@ status_t CameraSource::initWithCameraAccess(
     CameraParameters newCameraParams(mCamera->getParameters());
     if ((err = checkVideoSize(newCameraParams,
                 videoSize.width, videoSize.height)) != OK) {
+        mIsMetaDataStoredInVideoBuffers = false;
         return err;
     }
+    mIsMetaDataStoredInVideoBuffers = false;
     if ((err = checkFrameRate(newCameraParams, frameRate)) != OK) {
         return err;
     }
@@ -572,6 +601,17 @@ status_t CameraSource::initWithCameraAccess(
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
+    int frameWidthActual = 0;
+    int frameHeightActual = 0;
+    if(mIsMetaDataStoredInVideoBuffers == true){
+       CameraParameters newCameraParams_ext(mCamera->getParameters());
+       //newCameraParams_ext.getPreviewSize(&frameWidthActual, &frameHeightActual);
+       frameWidthActual = newCameraParams_ext.getInt("record-video-width");
+       frameHeightActual = newCameraParams_ext.getInt("record-video-height");
+       mMeta->setInt32('pwdt', frameWidthActual);
+       mMeta->setInt32('phgt', frameHeightActual);
+    }
+    ALOGE("preview width source %d",frameWidthActual);
 
 #ifdef QCOM_HARDWARE
     QCUtilityClass::helper_CameraSource_hfr(params, mMeta);
diff --git a/media/libstagefright/CameraSourceTimeLapse.cpp b/media/libstagefright/CameraSourceTimeLapse.cpp
index 26ce7ae..64b6158 100644
--- a/media/libstagefright/CameraSourceTimeLapse.cpp
+++ b/media/libstagefright/CameraSourceTimeLapse.cpp
@@ -63,8 +63,8 @@ CameraSourceTimeLapse::CameraSourceTimeLapse(
         int32_t videoFrameRate,
         const sp<Surface>& surface,
         int64_t timeBetweenFrameCaptureUs)
-    : CameraSource(camera, proxy, cameraId, videoSize, videoFrameRate, surface, true),
-      mTimeBetweenTimeLapseVideoFramesUs(1E6/videoFrameRate),
+    : CameraSource(camera, proxy, cameraId, videoSize, (videoFrameRate&0x7fffffff), surface, (videoFrameRate&0x80000000)?false:true),
+       mTimeBetweenTimeLapseVideoFramesUs(1E6/(videoFrameRate&0x7fffffff)),
       mLastTimeLapseFrameRealTimestampUs(0),
       mSkipCurrentFrame(false) {
 
@@ -75,7 +75,8 @@ CameraSourceTimeLapse::CameraSourceTimeLapse(
     mVideoWidth = videoSize.width;
     mVideoHeight = videoSize.height;
 
-    if (!trySettingVideoSize(videoSize.width, videoSize.height)) {
+    if ((mInitCheck != OK) && !trySettingVideoSize(videoSize.width, videoSize.height)) {
+        ALOGE("mInitCheck NO_INIT");
         mInitCheck = NO_INIT;
     }
 
diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index 29bb056..098fcf9 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -122,7 +122,7 @@ private:
     // media buffers
     size_t mMaxBufferSize;
     MediaBufferGroup *mGroup;
-    void (*mCopy)(short *dst, const int *const *src, unsigned nSamples);
+    void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
 
     // handle to underlying libFLAC parser
     FLAC__StreamDecoder *mDecoder;
@@ -380,14 +380,14 @@ void FLACParser::errorCallback(FLAC__StreamDecoderErrorStatus status)
 // Copy samples from FLAC native 32-bit non-interleaved to 16-bit interleaved.
 // These are candidates for optimization if needed.
 
-static void copyMono8(short *dst, const int *const *src, unsigned nSamples)
+static void copyMono8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i] << 8;
     }
 }
 
-static void copyStereo8(short *dst, const int *const *src, unsigned nSamples)
+static void copyStereo8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i] << 8;
@@ -395,14 +395,23 @@ static void copyStereo8(short *dst, const int *const *src, unsigned nSamples)
     }
 }
 
-static void copyMono16(short *dst, const int *const *src, unsigned nSamples)
+static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+{
+    for (unsigned i = 0; i < nSamples; ++i) {
+        for (unsigned c = 0; c < nChannels; ++c) {
+            *dst++ = src[c][i] << 8;
+        }
+    }
+}
+
+static void copyMono16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i];
     }
 }
 
-static void copyStereo16(short *dst, const int *const *src, unsigned nSamples)
+static void copyStereo16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i];
@@ -410,16 +419,25 @@ static void copyStereo16(short *dst, const int *const *src, unsigned nSamples)
     }
 }
 
+static void copyMultiCh16(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+{
+    for (unsigned i = 0; i < nSamples; ++i) {
+        for (unsigned c = 0; c < nChannels; ++c) {
+            *dst++ = src[c][i];
+        }
+    }
+}
+
 // 24-bit versions should do dithering or noise-shaping, here or in AudioFlinger
 
-static void copyMono24(short *dst, const int *const *src, unsigned nSamples)
+static void copyMono24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i] >> 8;
     }
 }
 
-static void copyStereo24(short *dst, const int *const *src, unsigned nSamples)
+static void copyStereo24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     for (unsigned i = 0; i < nSamples; ++i) {
         *dst++ = src[0][i] >> 8;
@@ -427,7 +445,16 @@ static void copyStereo24(short *dst, const int *const *src, unsigned nSamples)
     }
 }
 
-static void copyTrespass(short *dst, const int *const *src, unsigned nSamples)
+static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
+{
+    for (unsigned i = 0; i < nSamples; ++i) {
+        for (unsigned c = 0; c < nChannels; ++c) {
+            *dst++ = src[c][i] >> 8;
+        }
+    }
+}
+
+static void copyTrespass(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 {
     TRESPASS();
 }
@@ -507,11 +534,7 @@ status_t FLACParser::init()
     }
     if (mStreamInfoValid) {
         // check channel count
-        switch (getChannels()) {
-        case 1:
-        case 2:
-            break;
-        default:
+        if (getChannels() == 0 || getChannels() > 8) {
             ALOGE("unsupported channel count %u", getChannels());
             return NO_INIT;
         }
@@ -536,9 +559,10 @@ status_t FLACParser::init()
         case 32000:
         case 44100:
         case 48000:
+        case 88200:
+        case 96000:
             break;
         default:
-            // 96000 would require a proper downsampler in AudioFlinger
             ALOGE("unsupported sample rate %u", getSampleRate());
             return NO_INIT;
         }
@@ -546,17 +570,20 @@ status_t FLACParser::init()
         static const struct {
             unsigned mChannels;
             unsigned mBitsPerSample;
-            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples);
+            void (*mCopy)(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels);
         } table[] = {
             { 1,  8, copyMono8    },
             { 2,  8, copyStereo8  },
+            { 8,  8, copyMultiCh8  },
             { 1, 16, copyMono16   },
             { 2, 16, copyStereo16 },
+            { 8, 16, copyMultiCh16 },
             { 1, 24, copyMono24   },
             { 2, 24, copyStereo24 },
+            { 8, 24, copyMultiCh24 },
         };
         for (unsigned i = 0; i < sizeof(table)/sizeof(table[0]); ++i) {
-            if (table[i].mChannels == getChannels() &&
+            if (table[i].mChannels >= getChannels() &&
                     table[i].mBitsPerSample == getBitsPerSample()) {
                 mCopy = table[i].mCopy;
                 break;
@@ -640,7 +667,7 @@ MediaBuffer *FLACParser::readBuffer(bool doSeek, FLAC__uint64 sample)
     short *data = (short *) buffer->data();
     buffer->set_range(0, bufferSize);
     // copy PCM from FLAC write buffer to our media buffer, with interleaving
-    (*mCopy)(data, mWriteBuffer, blocksize);
+    (*mCopy)(data, mWriteBuffer, blocksize, getChannels());
     // fill in buffer metadata
     CHECK(mWriteHeader.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
     FLAC__uint64 sampleNumber = mWriteHeader.number.sample_number;
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 04b508b..d70dfec 100755
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -40,6 +40,8 @@
 
 #include "include/ESDS.h"
 
+#define CACHE_FW //cache data write
+
 #ifdef QCOM_HARDWARE
 #include "include/QCUtilityClass.h"
 #endif
@@ -75,6 +77,13 @@ public:
     int32_t getTrackId() const { return mTrackId; }
     status_t dump(int fd, const Vector<String16>& args) const;
 
+#ifdef CACHE_FW             
+    int streamWrite(int fd,const void *buf,size_t len);
+    int streamSync(int fd);
+    int streamInit(int usesz);
+#endif
+    void releaseMediabuffer();
+
 private:
     enum {
         kMaxCttsOffsetTimeUs = 1000000LL,  // 1 second
@@ -218,11 +227,16 @@ private:
     int64_t mMaxChunkDurationUs;
 
     bool mIsRealTimeRecording;
+    int64_t mMaxTimeStampUs;
     int64_t mEstimatedTrackSizeBytes;
     int64_t mMdatSizeBytes;
     int32_t mTimeScale;
 
+    int64_t mbkLastTimestampUs;
+    int nbkChunks;
     pthread_t mThread;
+    int64_t mStartSysTime;
+    int64_t mSysAdjustTime;
 
 
     List<MediaBuffer *> mChunkSamples;
@@ -333,6 +347,20 @@ private:
     void writeVideoFourCCBox();
     void writeStblBox(bool use32BitOffset);
 
+#ifdef CACHE_FW         
+    /*
+     * Because of header unification ,we don't change the MPEG4Writer.h
+     * same as it,we don't encapsule write and lseek
+     */
+    int nBufLen;
+    int nBufPos;
+    unsigned char *pStrmBuf;
+#endif
+
+    Mutex mLockStop;
+    bool bUseCopy;
+    int nReleaseFrms;
+
     Track(const Track &);
     Track &operator=(const Track &);
 };
@@ -436,6 +464,13 @@ status_t MPEG4Writer::addSource(const sp<MediaSource> &source) {
     Track *track = new Track(this, source, 1 + mTracks.size());
     mTracks.push_back(track);
 
+#ifdef CACHE_FW
+    if(mTracks.size() == 1)
+    {
+       track->streamInit(64*1024);
+    }
+#endif
+
     return OK;
 }
 
@@ -605,17 +640,26 @@ status_t MPEG4Writer::start(MetaData *param) {
         mEstimatedMoovBoxSize = estimateMoovBoxSize(bitRate);
     }
     CHECK_GE(mEstimatedMoovBoxSize, 8);
+#ifdef CACHE_FW
+    Track *track = *mTracks.begin();
+#endif
     if (mStreamableFile) {
-        // Reserve a 'free' box only for streamable file
-        lseek64(mFd, mFreeBoxOffset, SEEK_SET);
-        writeInt32(mEstimatedMoovBoxSize);
-        write("free", 4);
-        mMdatOffset = mFreeBoxOffset + mEstimatedMoovBoxSize;
+        // Reserve a 'free' box only for streamable file        
+#ifdef CACHE_FW
+       track->streamSync(mFd);
+#endif
+       lseek64(mFd, mFreeBoxOffset, SEEK_SET);
+       writeInt32(mEstimatedMoovBoxSize);
+       write("free", 4);
+       mMdatOffset = mFreeBoxOffset + mEstimatedMoovBoxSize;
     } else {
         mMdatOffset = mOffset;
     }
 
     mOffset = mMdatOffset;
+#ifdef CACHE_FW
+    track->streamSync(mFd);
+#endif  
     lseek64(mFd, mMdatOffset, SEEK_SET);
     if (mUse32BitOffset) {
         write("????mdat", 8);
@@ -781,17 +825,32 @@ status_t MPEG4Writer::reset() {
         return err;
     }
 
+#ifdef CACHE_FW
+    Track *track = *mTracks.begin();
+    track->streamSync(mFd);
+#endif
     // Fix up the size of the 'mdat' chunk.
     if (mUse32BitOffset) {
         lseek64(mFd, mMdatOffset, SEEK_SET);
         int32_t size = htonl(static_cast<int32_t>(mOffset - mMdatOffset));
+#ifndef CACHE_FW
         ::write(mFd, &size, 4);
+#else
+        track->streamWrite(mFd, (const void*)&size, 4);
+#endif
     } else {
         lseek64(mFd, mMdatOffset + 8, SEEK_SET);
         int64_t size = mOffset - mMdatOffset;
         size = hton64(size);
+#ifndef CACHE_FW          
         ::write(mFd, &size, 8);
+#else
+        track->streamWrite(mFd, (const void*)&size, 8);
+#endif        
     }
+#ifdef CACHE_FW
+    track->streamSync(mFd);
+#endif    
     lseek64(mFd, mOffset, SEEK_SET);
 
     const off64_t moovOffset = mOffset;
@@ -805,12 +864,19 @@ status_t MPEG4Writer::reset() {
     if (mStreamableFile) {
         CHECK_LE(mMoovBoxBufferOffset + 8, mEstimatedMoovBoxSize);
 
+#ifdef CACHE_FW
+        Track *track = *mTracks.begin();
+        track->streamSync(mFd);
+#endif        
         // Moov box
         lseek64(mFd, mFreeBoxOffset, SEEK_SET);
         mOffset = mFreeBoxOffset;
         write(mMoovBoxBuffer, 1, mMoovBoxBufferOffset);
 
         // Free box
+#ifdef CACHE_FW
+        track->streamSync(mFd);
+#endif        
         lseek64(mFd, mOffset, SEEK_SET);
         writeInt32(mEstimatedMoovBoxSize - mMoovBoxBufferOffset);
         write("free", 4);
@@ -940,9 +1006,14 @@ void MPEG4Writer::unlock() {
 off64_t MPEG4Writer::addSample_l(MediaBuffer *buffer) {
     off64_t old_offset = mOffset;
 
+#ifndef CACHE_FW    
     ::write(mFd,
           (const uint8_t *)buffer->data() + buffer->range_offset(),
           buffer->range_length());
+#else
+    Track *track = *mTracks.begin();
+    track->streamWrite(mFd,(const uint8_t *)buffer->data() + buffer->range_offset(),buffer->range_length());
+#endif
 
     mOffset += buffer->range_length();
 
@@ -969,6 +1040,7 @@ off64_t MPEG4Writer::addLengthPrefixedSample_l(MediaBuffer *buffer) {
     size_t length = buffer->range_length();
 
     if (mUse4ByteNalLength) {
+#ifndef CACHE_FW        
         uint8_t x = length >> 24;
         ::write(mFd, &x, 1);
         x = (length >> 16) & 0xff;
@@ -981,16 +1053,40 @@ off64_t MPEG4Writer::addLengthPrefixedSample_l(MediaBuffer *buffer) {
         ::write(mFd,
               (const uint8_t *)buffer->data() + buffer->range_offset(),
               length);
+#else
+        Track *track = *mTracks.begin();
+        const uint8_t *bufferptr = (const uint8_t *)buffer->data() + buffer->range_offset();
+        uint8_t x = length >> 24;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        x = (length >> 16) & 0xff;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        x = (length >> 8) & 0xff;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        x = length & 0xff;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        track->streamWrite(mFd,
+              (const uint8_t *)buffer->data() + buffer->range_offset(),
+              length);
+ #endif        
 
         mOffset += length + 4;
     } else {
         CHECK_LT(length, 65536);
 
+#ifndef CACHE_FW        
         uint8_t x = length >> 8;
         ::write(mFd, &x, 1);
         x = length & 0xff;
         ::write(mFd, &x, 1);
         ::write(mFd, (const uint8_t *)buffer->data() + buffer->range_offset(), length);
+#else
+        Track *track = *mTracks.begin();
+        uint8_t x = length >> 8;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        x = length & 0xff;
+        track->streamWrite(mFd, (const void*)&x, 1);
+        track->streamWrite(mFd, (const uint8_t *)buffer->data() + buffer->range_offset(), length);
+#endif        
         mOffset += length + 2;
     }
 
@@ -1010,9 +1106,18 @@ size_t MPEG4Writer::write(
                  it != mBoxes.end(); ++it) {
                 (*it) += mOffset;
             }
+#ifdef CACHE_FW
+            Track *track = *mTracks.begin();
+            track->streamSync(mFd);
+#endif            
             lseek64(mFd, mOffset, SEEK_SET);
+#ifndef CACHE_FW            
             ::write(mFd, mMoovBoxBuffer, mMoovBoxBufferOffset);
             ::write(mFd, ptr, size * nmemb);
+#else
+            track->streamWrite(mFd, mMoovBoxBuffer, mMoovBoxBufferOffset);
+            track->streamWrite(mFd, ptr, size * nmemb);
+#endif            
             mOffset += (bytes + mMoovBoxBufferOffset);
             free(mMoovBoxBuffer);
             mMoovBoxBuffer = NULL;
@@ -1024,7 +1129,12 @@ size_t MPEG4Writer::write(
             mMoovBoxBufferOffset += bytes;
         }
     } else {
+#ifndef CACHE_FW        
         ::write(mFd, ptr, size * nmemb);
+#else
+        Track *track = *mTracks.begin();
+        track->streamWrite(mFd, ptr, size * nmemb);
+#endif        
         mOffset += bytes;
     }
     return bytes;
@@ -1050,9 +1160,16 @@ void MPEG4Writer::endBox() {
        int32_t x = htonl(mMoovBoxBufferOffset - offset);
        memcpy(mMoovBoxBuffer + offset, &x, 4);
     } else {
+#ifdef CACHE_FW
+        Track *track = *mTracks.begin();
+        track->streamSync(mFd);
+#endif        
         lseek64(mFd, offset, SEEK_SET);
         writeInt32(mOffset - offset);
         mOffset -= 4;
+#ifdef CACHE_FW
+        track->streamSync(mFd);
+#endif        
         lseek64(mFd, mOffset, SEEK_SET);
     }
 }
@@ -1271,8 +1388,77 @@ MPEG4Writer::Track::Track(
     mIsMPEG4 = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_MPEG4) ||
                !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC);
 
+#ifdef CACHE_FW
+    pStrmBuf = NULL;
+    nBufPos = 0;
+    nBufLen = 0;
+#endif
+    bUseCopy = false;               
     setTimeScale();
+    nReleaseFrms=0;
+    mStartSysTime = 0;
+    mSysAdjustTime = 0;
+}
+
+void  MPEG4Writer::Track::releaseMediabuffer(){
+        nReleaseFrms--;
+}
+
+#ifdef CACHE_FW 
+int MPEG4Writer::Track::streamWrite(int fd,const void *buf,size_t len){
+        size_t left_len = nBufLen - nBufPos;
+        size_t space_need = len;
+        const unsigned char *cur_buf =  (const unsigned char *)buf;
+        int nleft = 0;
+
+      if (space_need >= left_len)
+      { 
+        memcpy(pStrmBuf + nBufPos, cur_buf, left_len);
+        ::write(fd, pStrmBuf,nBufLen);//no write return check??
+              
+        space_need -= left_len;
+        cur_buf += left_len;
+ALOGE("streamWrite %d",nBufLen);
+        if((int)space_need >= (int)nBufLen)
+        {
+             nleft = space_need/nBufLen;
+             nleft = nleft * nBufLen;
+             ::write(fd, cur_buf,nleft);//no write return check??
+             space_need -= nleft;
+             cur_buf += nleft;
+        }            
+        nBufPos = 0;
+     }
+            
+     if (space_need > 0)
+     {
+        memcpy(pStrmBuf + nBufPos, cur_buf, space_need);
+        nBufPos += space_need;
+     }
+
+     return 0;
+}
+
+int MPEG4Writer::Track::streamSync(int fd){
+
+        if(nBufPos && pStrmBuf) {
+                ALOGE("streamWrite %d,%d",nBufLen,nBufPos);
+                        ::write(fd, pStrmBuf,nBufPos);//no write return check??
+                        nBufPos = 0;
+    }
+    return 0;
+}
+
+
+int MPEG4Writer::Track::streamInit(int usesz){
+    pStrmBuf = (unsigned char*)malloc(usesz + 1024);
+    
+    if(pStrmBuf == NULL) return -1;
+    nBufPos = 0;
+    nBufLen = usesz;
+    return 0;
 }
+#endif
 
 void MPEG4Writer::Track::updateTrackSizeEstimate() {
 
@@ -1412,6 +1598,16 @@ MPEG4Writer::Track::~Track() {
         free(mCodecSpecificData);
         mCodecSpecificData = NULL;
     }
+#ifdef   CACHE_FW
+    if(pStrmBuf)
+    {
+       free(pStrmBuf);
+       pStrmBuf = NULL;
+    }
+
+    nBufPos = 0;
+    nBufLen = 0;
+#endif    
 }
 
 void MPEG4Writer::Track::initTrackingProgressStatus(MetaData *params) {
@@ -1474,6 +1670,10 @@ void MPEG4Writer::writeChunkToFile(Chunk* chunk) {
 
         (*it)->release();
         (*it) = NULL;
+        if(!chunk->mTrack->isAudio())
+        {
+               chunk->mTrack->releaseMediabuffer();
+        }
         chunk->mSamples.erase(it);
     }
     chunk->mSamples.clear();
@@ -1597,6 +1797,10 @@ status_t MPEG4Writer::Track::start(MetaData *params) {
         return OK;
     }
 
+    int bncpy = 0;
+    mMeta->findInt32('ribf', &bncpy);
+    bUseCopy = bncpy;
+    ALOGE("ring buff go on now %d",bUseCopy);
     int64_t startTimeUs;
     if (params == NULL || !params->findInt64(kKeyTime, &startTimeUs)) {
         startTimeUs = 0;
@@ -1669,7 +1873,8 @@ status_t MPEG4Writer::Track::pause() {
 }
 
 status_t MPEG4Writer::Track::stop() {
-    ALOGD("Stopping %s track", mIsAudio? "Audio": "Video");
+    int cc = 0;
+    ALOGD("Stopping %s track,%d", mIsAudio? "Audio": "Video",bUseCopy);
     if (!mStarted) {
         ALOGE("Stop() called but track is not started");
         return ERROR_END_OF_STREAM;
@@ -1678,14 +1883,60 @@ status_t MPEG4Writer::Track::stop() {
     if (mDone) {
         return OK;
     }
+
+    while(mStszTableEntries->count()== 0){
+                usleep(10000);
+                cc++;
+                if(cc > 100){
+                        ALOGE("Stopping %s track source err", mIsAudio? "Audio": "Video");
+                         break;
+                }
+    }
+
+    cc =0;
     mDone = true;
+    if(bUseCopy == true){
+            usleep(10000);
+                if (!mIsAudio) {
+                        mLockStop.lock();
+                        //make sure the lasts release buffer to omx
+                        if(!mChunkSamples.empty()) {
+                                addOneStscTableEntry(++nbkChunks, mChunkSamples.size());
+                                //bufferChunk(mbkLastTimestampUs);
+                                Chunk chunk(this, mbkLastTimestampUs, mChunkSamples);
+                                mOwner->bufferChunk(chunk);
+                                mChunkSamples.clear();
+                                //mOwner->writeChunkToFile(&chunk);
+                        }
+                        mLockStop.unlock();
+                }
+   }
+
+        while(mReachedEOS != true){
+                usleep(10000);
+                cc++;
+                if(cc > 100){
+                        ALOGE("Stopping %s track source err", mIsAudio? "Audio": "Video");
+                         break;
+                }
+        }
 
     void *dummy;
     pthread_join(mThread, &dummy);
 
     status_t err = (status_t) dummy;
 
-    ALOGD("Stopping %s track source", mIsAudio? "Audio": "Video");
+    if(err) {
+       ALOGE("Stopping %s track source %d", mIsAudio? "Audio": "Video",err);
+    }
+
+    if(!mIsAudio && bUseCopy){
+       while(nReleaseFrms > 0)
+       {
+               usleep(10000);
+               ALOGE("wait for %d",nReleaseFrms);
+       }
+    }
     {
         status_t status = mSource->stop();
         if (err == OK && status != OK && status != ERROR_END_OF_STREAM) {
@@ -2020,6 +2271,10 @@ status_t MPEG4Writer::Track::threadEntry() {
             continue;
         }
 
+        if(!mIsAudio){
+            nReleaseFrms++;
+        }
+
         ++count;
 
         int32_t isCodecConfig;
@@ -2045,6 +2300,7 @@ status_t MPEG4Writer::Track::threadEntry() {
             buffer->release();
             buffer = NULL;
 
+            nReleaseFrms--;
             mGotAllCodecSpecificData = true;
             continue;
         }
@@ -2128,24 +2384,53 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         // Make a deep copy of the MediaBuffer and Metadata and release
         // the original as soon as we can
-        MediaBuffer *copy = new MediaBuffer(buffer->range_length());
-        memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
-                buffer->range_length());
-        copy->set_range(0, buffer->range_length());
         meta_data = new MetaData(*buffer->meta_data().get());
-        buffer->release();
-        buffer = NULL;
+        size_t sampleSize = 0;
+        MediaBuffer *copy =  NULL;
+        if(bUseCopy == true){
+                        if (mIsAudio) {
+                                copy = new MediaBuffer(buffer->range_length());
+                                memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
+                                        buffer->range_length());
+                                copy->set_range(0, buffer->range_length());
+                                sampleSize = buffer->range_length();
+                                buffer->release();
+                                buffer = NULL;
+                        }
+                        else
+                        {
+                                if (mIsAvc) StripStartcode(buffer);
+                                sampleSize = buffer->range_length();
+
+                                if (mIsAvc) {
+                                          if (mOwner->useNalLengthFour()) {
+                                                  sampleSize += 4;
+                                          } else {
+                                                  sampleSize += 2;
+                                          }
+                                  }
+                        }
 
-        if (mIsAvc) StripStartcode(copy);
-
-        size_t sampleSize = copy->range_length();
-        if (mIsAvc) {
-            if (mOwner->useNalLengthFour()) {
-                sampleSize += 4;
-            } else {
-                sampleSize += 2;
-            }
-        }
+                }
+                else{
+                                copy = new MediaBuffer(buffer->range_length());
+                    memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
+                buffer->range_length());
+                    copy->set_range(0, buffer->range_length());
+        
+                            buffer->release();
+                            buffer = NULL;
+                            if (mIsAvc) StripStartcode(copy);
+
+                            sampleSize = copy->range_length();
+                                if (mIsAvc) {
+                                   if (mOwner->useNalLengthFour()) {
+                                          sampleSize += 4;
+                                   } else {
+                                          sampleSize += 2;
+                                   }
+                                }
+                }
 
         // Max file size or duration handling
         mMdatSizeBytes += sampleSize;
@@ -2177,6 +2462,7 @@ status_t MPEG4Writer::Track::threadEntry() {
             mStartTimestampUs = timestampUs;
             mOwner->setStartTimestampUs(mStartTimestampUs);
             previousPausedDurationUs = mStartTimestampUs;
+            mStartSysTime = mFirstSampleTimeRealUs;
         }
 
         if (mResumed) {
@@ -2189,6 +2475,24 @@ status_t MPEG4Writer::Track::threadEntry() {
         }
 
         timestampUs -= previousPausedDurationUs;
+        int64_t decodedTimeUs = mSysAdjustTime;
+        if(mIsAudio){
+                        mSysAdjustTime = systemTime() / 1000 - mStartSysTime;
+                        if(timestampUs > (mSysAdjustTime + 50000)){
+                                List<Track *>::iterator it = mOwner->mTracks.begin();
+                                int64_t TmpTimeUs = timestampUs - mSysAdjustTime;
+                        if((*it)->mSysAdjustTime < TmpTimeUs){
+                                (*it)->mSysAdjustTime = TmpTimeUs;
+                        }
+                        }
+                        ALOGV("TimeStamp Audio %lld,%lld,%lld",mSysAdjustTime,timestampUs,timestampUs-mSysAdjustTime);
+                }
+                else {
+                        //ALOGE("TimeStamp video %lld,%lld,%lld",mSysAdjustTime,timestampUs,timestampUs+mSysAdjustTime);
+                        timestampUs += decodedTimeUs;
+                        //if(timestampUs < 0) timestampUs = 100;
+                        ALOGV("TimeStamp Video %lld,%lld",mSysAdjustTime,timestampUs);
+                }
 #ifndef OMAP_ENHANCEMENT
         CHECK_GE(timestampUs, 0ll);
 #endif
@@ -2205,12 +2509,18 @@ status_t MPEG4Writer::Track::threadEntry() {
 #endif
 
             decodingTimeUs -= previousPausedDurationUs;
+            decodingTimeUs += decodedTimeUs;
             cttsOffsetTimeUs =
                     timestampUs + kMaxCttsOffsetTimeUs - decodingTimeUs;
+            if(cttsOffsetTimeUs < 0){
+                ALOGE("AV decoding time: %lld and ctts offset time: %lld,%lld,%lld",
+                    timestampUs, cttsOffsetTimeUs,decodingTimeUs,previousPausedDurationUs);
+                    cttsOffsetTimeUs = kMaxCttsOffsetTimeUs;
+            }
             CHECK_GE(cttsOffsetTimeUs, 0ll);
             timestampUs = decodingTimeUs;
-            ALOGV("decoding time: %lld and ctts offset time: %lld",
-                timestampUs, cttsOffsetTimeUs);
+            ALOGV("decoding time: %lld and ctts offset time: %lld,%lld,%lld,%lld",
+                timestampUs, cttsOffsetTimeUs,lastTimestampUs,mSysAdjustTime,lastCttsOffsetTimeTicks);
 
             // Update ctts box table if necessary
             currCttsOffsetTimeTicks =
@@ -2253,6 +2563,11 @@ status_t MPEG4Writer::Track::threadEntry() {
             }
         }
 
+        if(timestampUs < 0){
+            ALOGE("%s media time stamp: %lld and previous paused duration %lld",
+                mIsAudio? "Audio": "Video", timestampUs, previousPausedDurationUs);
+        }
+
         CHECK_GE(timestampUs, 0ll);
         ALOGV("%s media time stamp: %lld and previous paused duration %lld",
                 mIsAudio? "Audio": "Video", timestampUs, previousPausedDurationUs);
@@ -2268,11 +2583,12 @@ status_t MPEG4Writer::Track::threadEntry() {
         currDurationTicks =
             ((timestampUs * mTimeScale + 500000LL) / 1000000LL -
                 (lastTimestampUs * mTimeScale + 500000LL) / 1000000LL);
-        if (currDurationTicks < 0ll) {
-            ALOGE("timestampUs %lld < lastTimestampUs %lld for %s track",
-                timestampUs, lastTimestampUs, mIsAudio? "Audio": "Video");
-            return UNKNOWN_ERROR;
-        }
+        if(currDurationTicks < 0)
+        {
+               ALOGE("AV not sync,audio maybe overflow....");
+               currDurationTicks = lastDurationTicks;
+         }
+        CHECK_GE(currDurationTicks, 0ll);
 
         mStszTableEntries->add(htonl(sampleSize));
         if (mStszTableEntries->count() > 2) {
@@ -2293,8 +2609,8 @@ status_t MPEG4Writer::Track::threadEntry() {
             }
             previousSampleSize = sampleSize;
         }
-        ALOGV("%s timestampUs/lastTimestampUs: %lld/%lld",
-                mIsAudio? "Audio": "Video", timestampUs, lastTimestampUs);
+        ALOGV("%s timestampUs/lastTimestampUs: %lld/%lld,%lld/%lld",
+                mIsAudio? "Audio": "Video", timestampUs, lastTimestampUs,currDurationTicks,currCttsOffsetTimeTicks);
         lastDurationUs = timestampUs - lastTimestampUs;
         lastDurationTicks = currDurationTicks;
         lastTimestampUs = timestampUs;
@@ -2310,26 +2626,71 @@ status_t MPEG4Writer::Track::threadEntry() {
             trackProgressStatus(timestampUs);
         }
         if (!hasMultipleTracks) {
-            off64_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(copy)
-                                 : mOwner->addSample_l(copy);
+                if(bUseCopy == true){
+                          if (mIsAudio) {
+                                off64_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(copy)
+                                                                         : mOwner->addSample_l(copy);
+                                uint32_t count = (mOwner->use32BitFileOffset()
+                        ? mStcoTableEntries->count()
+                        : mCo64TableEntries->count());
 
-            uint32_t count = (mOwner->use32BitFileOffset()
+                if (count == 0) {
+                                        addChunkOffset(offset);
+                                }
+                                copy->release();
+                                copy = NULL;
+                          }
+                          else
+                          {
+                                ALOGV("one chunk hasMultipleTracks %d",hasMultipleTracks);
+                                        off64_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(buffer)
+                                                                         : mOwner->addSample_l(buffer);
+                                uint32_t count = (mOwner->use32BitFileOffset()
                         ? mStcoTableEntries->count()
                         : mCo64TableEntries->count());
 
-            if (count == 0) {
-                addChunkOffset(offset);
+                if (count == 0) {
+                                        addChunkOffset(offset);
+                                }
+                                buffer->release();
+                                buffer = NULL;
+
+                        nReleaseFrms--;
+                          }
+            }else {
+                                off64_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(copy)
+                                 : mOwner->addSample_l(copy);
+                                  uint32_t count = (mOwner->use32BitFileOffset()
+                        ? mStcoTableEntries->count()
+                        : mCo64TableEntries->count());
+
+                        if (count == 0) {
+                                          addChunkOffset(offset);
+                                  }
+                                  copy->release();
+                                  copy = NULL;
             }
-            copy->release();
-            copy = NULL;
-            continue;
+                          continue;
         }
-
-        mChunkSamples.push_back(copy);
+        if(bUseCopy == true){
+                if (mIsAudio) {
+                   ALOGV("Audio mChunkSamples %p",copy);
+           mChunkSamples.push_back(copy);
+        }
+        else
+        {
+                ALOGV("Video mChunkSamples %p",buffer);
+                mChunkSamples.push_back(buffer);
+        }
+        }else {
+            mChunkSamples.push_back(copy);
+        }      
+        //interleaveDurationUs 瑕copy 1s版锛702P about 1Mbytes videos,120 video units
         if (interleaveDurationUs == 0) {
             addOneStscTableEntry(++nChunks, 1);
             bufferChunk(timestampUs);
         } else {
+            mbkLastTimestampUs = timestampUs;
             if (chunkTimestampUs == 0) {
                 chunkTimestampUs = timestampUs;
             } else {
@@ -2349,6 +2710,7 @@ status_t MPEG4Writer::Track::threadEntry() {
                 }
             }
         }
+        nbkChunks = nChunks;
 
     }
 
@@ -2362,8 +2724,31 @@ status_t MPEG4Writer::Track::threadEntry() {
     if (!hasMultipleTracks) {
         addOneStscTableEntry(1, mStszTableEntries->count());
     } else if (!mChunkSamples.empty()) {
+        if(bUseCopy == true){
+                 if(!mIsAudio){
+                mLockStop.lock();
+                if(!mChunkSamples.empty()){
+                        addOneStscTableEntry(++nChunks, mChunkSamples.size());
+                                        Chunk chunk(this, timestampUs, mChunkSamples);
+                                        mOwner->bufferChunk(chunk);
+                                        mChunkSamples.clear();
+                                        ALOGE("track stop empty?..... %d,%d",mChunkSamples.empty(),mChunkSamples.size());
+                                }
+                mLockStop.unlock();
+    }
+    else {
         addOneStscTableEntry(++nChunks, mChunkSamples.size());
-        bufferChunk(timestampUs);
+                        Chunk chunk(this, timestampUs, mChunkSamples);
+                        mOwner->bufferChunk(chunk);
+                        mChunkSamples.clear();
+    }
+}else {
+                        addOneStscTableEntry(++nChunks, mChunkSamples.size());
+                        Chunk chunk(this, timestampUs, mChunkSamples);
+                        mOwner->bufferChunk(chunk);
+                        mChunkSamples.clear();
+}
+       // bufferChunk(timestampUs);
     }
 
     // We don't really know how long the last frame lasts, since
@@ -2538,11 +2923,20 @@ bool MPEG4Writer::useNalLengthFour() {
 }
 
 void MPEG4Writer::Track::bufferChunk(int64_t timestampUs) {
-    ALOGV("bufferChunk");
-
-    Chunk chunk(this, timestampUs, mChunkSamples);
-    mOwner->bufferChunk(chunk);
-    mChunkSamples.clear();
+    ALOGV("bufferChunk %d",mIsAudio);
+    if(bUseCopy == true){
+    mLockStop.lock();
+    if(!mChunkSamples.empty()){
+        Chunk chunk(this, timestampUs, mChunkSamples);
+        mOwner->bufferChunk(chunk);
+        mChunkSamples.clear();
+    }
+    mLockStop.unlock();
+    } else {
+        Chunk chunk(this, timestampUs, mChunkSamples);
+        mOwner->bufferChunk(chunk);
+        mChunkSamples.clear();
+    }
 }
 
 int64_t MPEG4Writer::Track::getDurationUs() const {
@@ -2655,7 +3049,8 @@ void MPEG4Writer::Track::writeVideoFourCCBox() {
     mOwner->writeInt32(0x480000);    // vert resolution
     mOwner->writeInt32(0);           // reserved
     mOwner->writeInt16(1);           // frame count
-    mOwner->write("                                ", 32);
+    mOwner->writeInt8(0);            // compressor string length
+    mOwner->write("                               ", 31);
     mOwner->writeInt16(0x18);        // depth
     mOwner->writeInt16(-1);          // predefined
 
diff --git a/media/libstagefright/MediaCodecList.cpp b/media/libstagefright/MediaCodecList.cpp
index f815ec9..957041e 100644
--- a/media/libstagefright/MediaCodecList.cpp
+++ b/media/libstagefright/MediaCodecList.cpp
@@ -87,7 +87,7 @@ MediaCodecList::MediaCodecList()
         for (size_t j = 0; j < mTypes.size(); ++j) {
             uint32_t value = mTypes.valueAt(j);
 
-            if (info.mTypes & (1ul << value)) {
+            if (info.mTypes & (1ull << value)) {
                 line.append(mTypes.keyAt(j));
                 line.append(" ");
             }
@@ -408,7 +408,7 @@ void MediaCodecList::addType(const char *name) {
     if (index < 0) {
         bit = mTypes.size();
 
-        if (bit == 32) {
+        if (bit == 64) {
             ALOGW("Too many distinct type names in configuration.");
             return;
         }
@@ -419,7 +419,7 @@ void MediaCodecList::addType(const char *name) {
     }
 
     CodecInfo *info = &mCodecInfos.editItemAt(mCodecInfos.size() - 1);
-    info->mTypes |= 1ul << bit;
+    info->mTypes |= 1ull << bit;
 }
 
 ssize_t MediaCodecList::findCodecByType(
@@ -430,7 +430,7 @@ ssize_t MediaCodecList::findCodecByType(
         return -ENOENT;
     }
 
-    uint32_t typeMask = 1ul << mTypes.valueAt(typeIndex);
+    uint64_t typeMask = 1ull << mTypes.valueAt(typeIndex);//scz
 
     while (startIndex < mCodecInfos.size()) {
         const CodecInfo &info = mCodecInfos.itemAt(startIndex);
@@ -508,7 +508,7 @@ status_t MediaCodecList::getSupportedTypes(
     const CodecInfo &info = mCodecInfos.itemAt(index);
 
     for (size_t i = 0; i < mTypes.size(); ++i) {
-        uint32_t typeMask = 1ul << mTypes.valueAt(i);
+        uint64_t typeMask = 1ull << mTypes.valueAt(i);
 
         if (info.mTypes & typeMask) {
             types->push(mTypes.keyAt(i));
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index e7b5903..0ff9beb 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -24,7 +24,7 @@ const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
-const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
+//const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";//sync from zh, why?
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
 
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
@@ -54,4 +54,38 @@ const char *MEDIA_MIMETYPE_CONTAINER_WVM = "video/wvm";
 const char *MEDIA_MIMETYPE_TEXT_3GPP = "text/3gpp-tt";
 const char *MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
 
+
+/*******************************Actions inside*********************************/
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
+const char *MEDIA_MIMETYPE_VIDEO_DIV3 = "video/div3";
+const char *MEDIA_MIMETYPE_VIDEO_RV = "video/rv";
+const char *MEDIA_MIMETYPE_VIDEO_AVS = "video/avs";
+const char *MEDIA_MIMETYPE_VIDEO_MJPG = "video/mjpg";
+const char *MEDIA_MIMETYPE_VIDEO_WMV8 = "video/wmv8";
+const char *MEDIA_MIMETYPE_VIDEO_RVG2 = "video/rvg2";
+const char *MEDIA_MIMETYPE_VIDEO_VP8 = "video/vp8";
+const char *MEDIA_MIMETYPE_VIDEO_VP6 = "video/vp6";
+const char *MEDIA_MIMETYPE_VIDEO_FLV1 ="video/flv1";
+
+const char *MEDIA_MIMETYPE_AUDIO_ACT_MP3 = "audio/MP3";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_AAC = "audio/AAC";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_WMASTD = "audio/WMASTD";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_WMALSL = "audio/WMALSL";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_WMAPRO = "audio/WMAPRO";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_COOK  = "audio/COOK";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_PCM = "audio/PCM";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_OGG = "audio/OGG";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_DTS = "audio/DTS";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_AC3 = "audio/AC3";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_APE = "audio/APE";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_FLAC= "audio/FLAC";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_ACELP = "audio/ACELP";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_MPC= "audio/MPC";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_AIFF = "audio/AIFF";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_AMR = "audio/AMR";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_SAMPLE = "audio/SAMPLE";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_ALAC = "audio/ALAC";
+const char *MEDIA_MIMETYPE_AUDIO_ACT_AWB = "audio/AWB";
+
 }  // namespace android
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 33e526a..66ddfeb 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -20,6 +20,8 @@
 #include <utils/Log.h>
 #include <cutils/properties.h>
 
+#include "include/ActAudioExtractor.h"
+#include "include/ActVideoExtractor.h"
 #include "include/AMRExtractor.h"
 #include "include/MP3Extractor.h"
 #include "include/MPEG4Extractor.h"
@@ -33,6 +35,7 @@
 #include "include/WVMExtractor.h"
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
+#include "include/AwesomePlayer.h"
 #ifdef QCOM_HARDWARE
 #include "include/ExtendedExtractor.h"
 #include "include/QCUtilityClass.h"
@@ -41,6 +44,7 @@
 #include "matroska/MatroskaExtractor.h"
 
 #include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaExtractor.h>
@@ -59,16 +63,55 @@ uint32_t MediaExtractor::flags() const {
 
 // static
 sp<MediaExtractor> MediaExtractor::Create(
-        const sp<DataSource> &source, const char *mime) {
-    sp<AMessage> meta;
+        const sp<DataSource> &source, const char *mime, void* cookie) {
+    // first check if can use android extractor
+        sp<AMessage> meta;
+        String8 tmp;
+        bool usingMidwareFlag = false;
+        MediaExtractor *ret = NULL;
+        bool isDrm = false;
+
+        int32_t isStreamFlag= 0;
+        if (cookie!=NULL) {
+                isStreamFlag = ((AwesomePlayer *)cookie)->getStreamingFlag();
+        }
+        
+        //cz_20130723 NuMedia璧颁
+        if(mime!=NULL)
+        {
+          ALOGE("cz**********************MediaExtractor creat=%s",mime);
+          if(!strcasecmp(mime, "NuMediaExtractor"))  
+          {
+            isStreamFlag = 1;
+            mime=NULL;
+          } 
+        }
+        
+        //cz_20130723 涓ㄥ缓浜涓涓CTS
+        char cts_value[PROPERTY_VALUE_MAX];
+        int32_t isCTSFlag= 0;
+        property_get("ro.build_mode", cts_value, "NORMAL");
+
+        if(!strncmp(cts_value, "CTS",3))
+        {
+         isCTSFlag=1;
+        }
+        else
+        {
+         isCTSFlag=0;               
+        }
+    ALOGE("cts_value=%s isCTSFlag=%d", cts_value,isCTSFlag);
+        ALOGE("Create: firstly choose to use android extractor !!! isStreamFlag: %s", (isStreamFlag==true) ? "true" : "false");
 
-    String8 tmp;
     if (mime == NULL) {
         float confidence;
         if (!source->sniff(&tmp, &confidence, &meta)) {
-            ALOGV("FAILED to autodetect media content.");
-
+            ALOGE("FAILED to autodetect media content.");
+#ifdef TURN_ON_MIDDLEWARE_FLAG
+            goto middleware_extractor;
+#else
             return NULL;
+#endif
         }
 
         mime = tmp.string();
@@ -76,7 +119,7 @@ sp<MediaExtractor> MediaExtractor::Create(
              mime, confidence);
     }
 
-    bool isDrm = false;
+    // bool isDrm = false;
     // DRM MIME type syntax is "drm+type+original" where
     // type is "es_based" or "container_based" and
     // original is the content's cleartext MIME type
@@ -98,7 +141,98 @@ sp<MediaExtractor> MediaExtractor::Create(
         }
     }
 
-    MediaExtractor *ret = NULL;
+        ALOGV("Create: use android extractor !!! mime: %s ", mime);
+    if(isCTSFlag==0)
+    {
+        if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {//parser and decoder: both playback and streaming use android's 
+                //isStreamFlag = true;
+                if(isStreamFlag==1)
+                {
+                  ALOGD("use google ogg decoder");   
+                }
+                else
+                {
+                  ALOGD("use actions ogg decoder");      
+                }
+        }
+      if (isStreamFlag == 0 || !strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4) ){//parserand decoder: playback use middleware's and streaming use android's 
+                        mime = NULL;
+                        goto middleware_extractor;
+        }
+        }
+        else if(isCTSFlag==1) //cz_20130723 涓ㄥ缓浜涓涓CTS
+        {
+        
+         if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_OGG)) {//parser and decoder: both playback and streaming use android's                  
+                  ALOGD("use google ogg decoder"); 
+                  isStreamFlag=1;       
+        }
+        if ((!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) || (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4))) {//parser and decoder: both playback and streaming use android's 
+        
+                 // then check if can use middleware extractor
+                off64_t filelen=0;
+                int rt = 0;
+                storage_io_t *storage_io = NULL;
+                const char mime_type[32] = "";          
+                ALOGV("Create: then choose to use middleware parser mime: %s !!!", mime);
+          
+                storage_io = create_storage_io();
+                if (storage_io == NULL) {
+                        return NULL;
+                }
+        
+                filelen = init_storage_io(storage_io, source);
+                //if (filelen == 0) {
+                    //ALOGE("unsupport file, because filelen = 0 !!!");     
+                    //dispose_storage_io(storage_io);
+                    //return NULL;          
+                        
+                //}else {
+                        ALOGV("Create: fileLen: %lld", filelen);
+                //}
+                //CHECK(filelen>0);
+                rt = format_check(storage_io, mime_type);
+        
+                if (mime_type[0] == '\0' || rt != 0) {
+                        dispose_storage_io(storage_io);
+                        ALOGE("no media content detected error !!!");
+                        return NULL;
+                }
+                
+                dispose_storage_io(storage_io);
+                ALOGV("Create: format mime_type: %s", mime_type);
+                if ((mime_type[0] >= 'a') && (mime_type[0] <= 'z')) {/* video */
+                        ALOGE("mp4 is video");
+                        if(filelen==504541){
+                                isStreamFlag=1;
+                                ALOGD("using mp4 for subtitle cts \n");
+                        }else{
+                                isStreamFlag=0; 
+                        }
+                        
+                }else if ( (mime_type[0] >= 'A') && (mime_type[0] <= 'Z')) {        
+                     ALOGE("audio type: mp3 or mp4");     
+                         ALOGD("use google mp4 decoder");
+                          isStreamFlag=1;                         
+                }else {
+                        ALOGE("Creat: find extractor meet error!!!");
+                }
+        
+                
+        }
+        
+        if (isStreamFlag == 0) {//parserand decoder: playback use middleware's and streaming use android's 
+                        mime = NULL;
+                        goto middleware_extractor;
+        }
+        
+    }
+    else
+    {
+      ALOGE("CTS flag erro!!!");         
+     }
+
+//    MediaExtractor *ret = NULL;
     if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
             || !strcasecmp(mime, "audio/mp4")) {
         int fragmented = 0;
@@ -136,11 +270,13 @@ sp<MediaExtractor> MediaExtractor::Create(
     }
 
     if (ret != NULL) {
+        ret->setUsingMidwwareFlag(false);
        if (isDrm) {
            ret->setDrmFlag(true);
        } else {
            ret->setDrmFlag(false);
        }
+       return ret;
     }
 
 #ifdef QCOM_HARDWARE
@@ -149,7 +285,61 @@ sp<MediaExtractor> MediaExtractor::Create(
                                                                  source,
                                                                    mime);
 #else
-    return ret;
+    //return ret;
+middleware_extractor:
+        
+        // then check if can use middleware extractor
+        off64_t filelen=0;
+        int rt = 0;
+        storage_io_t *storage_io = NULL;
+        const char mime_type[32] = "";          
+        ALOGV("Create: then choose to use middleware parser mime: %s !!!", mime);
+        if (mime != NULL) {
+                ALOGE("Create: fail to load %s", mime);
+                return NULL;
+        }
+
+        storage_io = create_storage_io();
+        if (storage_io == NULL) {
+                return NULL;
+        }
+
+        filelen = init_storage_io(storage_io, source);
+        //if (filelen == 0) {
+            //ALOGE("unsupport file, because filelen = 0 !!!");     
+            //dispose_storage_io(storage_io);
+            //return NULL;          
+                
+        //}else {
+                ALOGV("Create: fileLen: %lld", filelen);
+        //}
+        //CHECK(filelen>0);
+        rt = format_check(storage_io, mime_type);
+
+        if (mime_type[0] == '\0' || rt != 0) {
+                dispose_storage_io(storage_io);
+                ALOGE("no media content detected error !!!");
+                return NULL;
+        }
+        
+        dispose_storage_io(storage_io);
+        ALOGV("Create: format mime_type: %s", mime_type);
+        if ((mime_type[0] >= 'a') && (mime_type[0] <= 'z')) {/* video */
+                ALOGV("Create()->new ActVideoExtractor!!!");
+                ret = new ActVideoExtractor(source, mime_type, cookie);
+        }else if ( (mime_type[0] >= 'A') && (mime_type[0] <= 'Z')) {
+                ret = new ActAudioExtractor(source, mime_type);
+        }else {
+                ALOGE("Creat: find extractor meet error!!!");
+                ret = NULL;
+        }
+        
+        if (ret != NULL) {
+                isDrm ? ret->setDrmFlag(true) : ret->setDrmFlag(false);
+                ret->setUsingMidwwareFlag(true);
+                return ret;
+        }
+    return NULL;
 #endif
 }
 
diff --git a/media/libstagefright/MetaData.cpp b/media/libstagefright/MetaData.cpp
index a01ec97..ae6ae2d 100644
--- a/media/libstagefright/MetaData.cpp
+++ b/media/libstagefright/MetaData.cpp
@@ -282,6 +282,7 @@ void MetaData::typed_data::freeStorage() {
     if (!usesReservoir()) {
         if (u.ext_data) {
             free(u.ext_data);
+            u.ext_data = NULL;
         }
     }
 
diff --git a/media/libstagefright/NuCachedSource2.cpp b/media/libstagefright/NuCachedSource2.cpp
index 05e599b..a77ac86 100644
--- a/media/libstagefright/NuCachedSource2.cpp
+++ b/media/libstagefright/NuCachedSource2.cpp
@@ -297,6 +297,11 @@ void NuCachedSource2::fetchInternal() {
             mSource->reconnectAtOffset(mCacheOffset + mCache->totalSize());
 
         Mutex::Autolock autoLock(mLock);
+        if (err == ERROR_READ_TIME_OUT_SP) {
+            ALOGW("time out:mNumRetriesLeft %d",mNumRetriesLeft);
+            mNumRetriesLeft = mNumRetriesLeft > 1 ? 1 : 0;
+            return;
+        }
 
         if (err == ERROR_UNSUPPORTED || err == -EPIPE) {
             // These are errors that are not likely to go away even if we
@@ -325,6 +330,10 @@ void NuCachedSource2::fetchInternal() {
             // retry, i.e. the server doesn't support range requests or similar.
             mNumRetriesLeft = 0;
         }
+        if (n == ERROR_READ_TIME_OUT_SP) {
+            ALOGW("time out:mNumRetriesLeft %d",mNumRetriesLeft);
+            mNumRetriesLeft = mNumRetriesLeft > 1 ? 1 : 0;
+        }
 
         ALOGE("source returned error %ld, %d retries left", n, mNumRetriesLeft);
         mCache->releasePage(page);
diff --git a/media/libstagefright/NuMediaExtractor.cpp b/media/libstagefright/NuMediaExtractor.cpp
index 404fa94..c3a430c 100644
--- a/media/libstagefright/NuMediaExtractor.cpp
+++ b/media/libstagefright/NuMediaExtractor.cpp
@@ -139,8 +139,9 @@ status_t NuMediaExtractor::setDataSource(int fd, off64_t offset, off64_t size) {
     if (err != OK) {
         return err;
     }
+    const char mime_type[32] = "NuMediaExtractor"; //cz_20130723 NuMedia锟竭伙拷原锟斤拷
 
-    mImpl = MediaExtractor::Create(fileSource);
+    mImpl = MediaExtractor::Create(fileSource,mime_type);
 
     if (mImpl == NULL) {
         return ERROR_UNSUPPORTED;
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 91ba093..e049bd8 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -47,6 +47,10 @@
 #include <OMX_Audio.h>
 #include <OMX_Component.h>
 
+#include <actal_posix_dev.h>
+#include <ALdec_plugin.h>
+#include "ACT_OMX_Index.h"
+
 #ifdef QCOM_HARDWARE
 #include <QCMediaDefs.h>
 #include <QCMetaData.h>
@@ -57,6 +61,10 @@
 
 #include "include/avc_utils.h"
 
+#include "gralloc_priv.h"
+
+#include "ACT_OMX_IVCommon.h"
+
 #ifdef USE_SAMSUNG_COLORFORMAT
 #include <sec_format.h>
 #endif
@@ -91,7 +99,10 @@ static int calc_plane(int width, int height)
 
 // Treat time out as an error if we have not received any output
 // buffers after 3 seconds.
-const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
+const static int64_t kBufferFilledEventTimeOutNs = 90000000000LL;//3000000000LL;
+const static int64_t kBufferFilledEventTimeOutNsForVideo = 60000000000LL;//3000000000LL;
+const static int64_t kBufferFilledEventTimeOutNsForSP = 90000000000LL; 
+const static int64_t kEncBufferFilledEventTimeOutNs = 13000000000LL;
 
 // OMX Spec defines less than 50 color formats. If the query for
 // color format is executed for more than kMaxColorFormatSupported,
@@ -164,6 +175,11 @@ static sp<MediaSource> InstantiateSoftwareDecoder(
 #define CODEC_LOGV(x, ...) ALOGV("[%s] "x, mComponentName, ##__VA_ARGS__)
 #define CODEC_LOGE(x, ...) ALOGE("[%s] "x, mComponentName, ##__VA_ARGS__)
 
+#define ACTIONS_PREFIX                  "OMX.Action"
+#define ACTIONS_VIDEO_DECODER  ACTIONS_PREFIX".Video.Decoder"
+#define ACTIONS_VIDEO_ENCODER  ACTIONS_PREFIX".Video.Encoder"
+#define ACTIONS_AUDIO_DECODER  ACTIONS_PREFIX".Audio.Decoder"
+
 struct OMXCodecObserver : public BnOMXObserver {
     OMXCodecObserver() {
     }
@@ -299,9 +315,14 @@ void OMXCodec::findMatchingCodecs(
         }
     }
 
+#if 0
+    // comment by reis:20121005
+    // never do this when multi h264 decoder is avaiable
+    // MatchingCodecQuirks is not sorted at all.    
     if (flags & kPreferSoftwareCodecs) {
         matchingCodecs->sort(CompareSoftwareCodecsFirst);
     }
+#endif    
 }
 
 // static
@@ -342,6 +363,22 @@ uint32_t OMXCodec::getComponentQuirks(
                 index, "output-buffers-are-unreadable")) {
         quirks |= kOutputBuffersAreUnreadable;
     }
+    if (list->codecHasQuirk(
+                index, "input-buffer-sizes-are-bogus")) {
+               quirks |= kInputBufferSizesAreBogus;
+       }
+       if (list->codecHasQuirk(
+                index, "needs-flush-before-disable")) {
+               quirks |= kNeedsFlushBeforeDisable;
+    }
+       if (list->codecHasQuirk(
+                index, "kRequiresLoadedToIdleAfterAllocation")) {
+               quirks |= kRequiresLoadedToIdleAfterAllocation;
+    }
+    if (list->codecHasQuirk(
+                index, "defers-output-buffer-allocation")) {
+               quirks |= kDefersOutputBufferAllocation;
+    }
 #ifdef QCOM_HARDWARE
     if (list->codecHasQuirk(
                 index, "requires-loaded-to-idle-after-allocation")) {
@@ -499,6 +536,15 @@ sp<MediaSource> OMXCodec::Create(
             }
         }
 
+        if(!strcmp(componentName, ACTIONS_VIDEO_DECODER)){
+                int64_t fps=0;
+                if((meta->findInt64(kKeyActFrmRate, &fps)&& fps>0)){
+                       ALOGI("==using action ===\n");
+                }else{
+                       ALOGI("==using client side ===\n");
+                       flags |= kPreferSoftwareCodecs;
+                }
+        }
         status_t err = omx->allocateNode(componentName, observer, &node);
         if (err == OK) {
             ALOGV("Successfully allocated OMX node '%s'", componentName);
@@ -510,6 +556,23 @@ sp<MediaSource> OMXCodec::Create(
 
             observer->setCodec(codec);
 
+     if(!strcmp(componentName, ACTIONS_VIDEO_DECODER) && !strncasecmp(mime, "video",5)){
+                                codec->IS_THUMBNAIL = 0;
+                                if(!meta->findInt32(kKeyActCreateThumbnail, &(codec->IS_THUMBNAIL))){   
+                                            codec->IS_THUMBNAIL = 0;
+                                    }   
+                                    ALOGD("Create: video IS_THUMBNAIL  %d",codec->IS_THUMBNAIL);
+     }
+
+                         int32_t isStreamingFlag=0;
+                if(meta->findInt32(kKeyActStreamingFlag, &isStreamingFlag) && isStreamingFlag==1) {
+                                codec->mIsStreamingFlag = isStreamingFlag;
+                                codec->mKBufferFilledEventTimeOutNs = kBufferFilledEventTimeOutNsForSP;
+                         }else{
+                                codec->mIsStreamingFlag = 0;
+                                codec->mKBufferFilledEventTimeOutNs = kBufferFilledEventTimeOutNs;
+                         }
+
             err = codec->configureCodec(meta);
 
             if (err == OK) {
@@ -614,7 +677,51 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         uint32_t type;
         const void *data;
         size_t size;
-        if (meta->findData(kKeyESDS, &type, &data, &size)) {
+        if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){
+        void* pd;
+        CODEC_LOGV("===init packet===\n");
+        if (meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mMIME)) {
+                        packet_header_t* ph = (packet_header_t*)pd;
+                        addCodecSpecificData((const void *)pd, \
+                        ph->block_len + sizeof(packet_header_t));       
+        }else if(meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIV3, mMIME)){
+                        addCodecSpecificData((const void *)pd, \
+                        16);    
+        }else if(meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mMIME)){
+                        packet_header_t* ph = (packet_header_t*)pd;
+                        addCodecSpecificData((const void *)pd, \
+                        ph->block_len + sizeof(packet_header_t));       
+        }else if(meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_RVG2, mMIME)){
+                        packet_header_t* ph = (packet_header_t*)pd;
+                        addCodecSpecificData((const void *)pd, \
+                        ph->block_len + sizeof(packet_header_t));       
+        }else if(meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mMIME)){
+                        addCodecSpecificData((const void *)pd, \
+                        20);    
+        } else if (meta->findPointer(kKeyActVDPrv, &pd) && !strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mMIME)){
+                typedef struct tVideoParam
+                {
+                    unsigned int  uiFOURCCCompressed;
+                    unsigned int  fltFrameRate;
+                    unsigned int  fltBitRate;
+                    unsigned int  iWidthSource;
+                    unsigned int  iHeightSource;
+                    unsigned int  iPostFilterLevel;
+                    unsigned char *pSequenceHeader;
+                    unsigned int  uipSequenceHeaderLength;
+                    unsigned int  bHostDeinterlace;
+                } WMV_VIDEOPARAM;
+                WMV_VIDEOPARAM* p = (WMV_VIDEOPARAM*)pd;
+                size_t size = sizeof(WMV_VIDEOPARAM);
+                if (p->pSequenceHeader == (uint8_t*)pd + sizeof(WMV_VIDEOPARAM)) {
+                        size += p->uipSequenceHeaderLength;
+                }
+                addCodecSpecificData((const void *)pd, \
+                        size);  
+                        }
+        }
+        if (meta->findData(kKeyESDS, &type, &data, &size) 
+           && strcmp(mComponentName, ACTIONS_AUDIO_DECODER)) {  
             ESDS esds((const char *)data, size);
             CHECK_EQ(esds.InitCheck(), (status_t)OK);
 
@@ -807,6 +914,22 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
 
     initOutputFormat(meta);
 
+    if (mIsEncoder) {
+        //TS writer extension for actions' component, by noahkong 2012.09.05
+        OMX_INDEXTYPE index;
+        int bTsp = 0;
+                status_t err =
+                        mOMX->getExtensionIndex(mNode,"OMX.actions.index.tspacket",&index);
+                mOutputFormat->setInt32('tsMd',0);
+                if (err == OK) {
+                        mOutputFormat->setInt32('tsMd',1);
+                }
+
+                if(meta->findInt32('ctlp', &bTsp)){
+                        mOutputFormat->setInt32('ctlp',bTsp);
+                }
+        }
+
     if ((mFlags & kClientNeedsFramebuffer)
             && !strncmp(mComponentName, "OMX.SEC.", 8)) {
         // This appears to no longer be needed???
@@ -846,6 +969,24 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         }
     }
 
+    if(mOMXLivesLocally && mIsEncoder && mIsVideo) {
+                OMX_INDEXTYPE index;
+
+                status_t err_ret = mOMX->getExtensionIndex(mNode,"OMX.actions.index.ringbuffer",&index);
+                if(err_ret == OK)
+                {
+                        OMX_ACTIONS_Params actionsParam;
+                        actionsParam.nVersion.s.nVersionMajor = 1;
+                        actionsParam.nVersion.s.nVersionMinor = 1;
+                        actionsParam.nVersion.s.nRevision = 0;
+                        actionsParam.nVersion.s.nStep = 0;
+                        actionsParam.nPortIndex = kPortIndexOutput;
+                        actionsParam.bEnable = OMX_TRUE;
+                        actionsParam.nSize = sizeof(OMX_ACTIONS_Params);
+                        mQuirks |= kRequiresAllocateBufferOnOutputPorts;
+                }
+    }
+
     return OK;
 }
 
@@ -1054,12 +1195,24 @@ void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
+    int frameWidthActual = 0;
+    int frameHeightActual = 0;
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
     success = success && meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyStride, &stride);
     success = success && meta->findInt32(kKeySliceHeight, &sliceHeight);
+    if(mIsEncoder && mIsVideo){
+       bool ret = meta->findInt32('pwdt', &frameWidthActual);
+       ret = ret && meta->findInt32('phgt', &frameHeightActual);
+       ALOGE("preview width b4... %d",frameWidthActual);
+       if(ret == 0){
+               frameWidthActual = width;
+               frameHeightActual = height;
+       }
+       ALOGE("preview width %d",frameWidthActual);
+    }
     CHECK(success);
     CHECK(stride != 0);
 
@@ -1111,10 +1264,19 @@ void OMXCodec::setVideoInputFormat(
 
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
-    video_def->nFrameWidth = width;
-    video_def->nFrameHeight = height;
-    video_def->nStride = stride;
-    video_def->nSliceHeight = sliceHeight;
+    if(mIsEncoder && mIsVideo){
+       video_def->nFrameWidth = frameWidthActual;
+       video_def->nFrameHeight = frameHeightActual;
+       video_def->nStride = frameWidthActual;
+       video_def->nSliceHeight = frameHeightActual;
+    }
+    else {
+       video_def->nFrameWidth = width;
+       video_def->nFrameHeight = height;
+       video_def->nStride = stride;
+       video_def->nSliceHeight = sliceHeight;
+    }
+
     video_def->xFramerate = (frameRate << 16);  // Q16 format
     video_def->eCompressionFormat = OMX_VIDEO_CodingUnused;
     video_def->eColorFormat = colorFormat;
@@ -1498,7 +1660,50 @@ status_t OMXCodec::setVideoOutputFormat(
 
     CODEC_LOGV("setVideoOutputFormat width=%ld, height=%ld", width, height);
 
-    OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
+ OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
+ if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){
+    typedef enum VIDDEC_CUSTOM_CODINGTYPE{
+        OMX_VIDEO_CodingVC1 = (OMX_VIDEO_CodingVendorStartUnused + 1),
+        OMX_VIDEO_CodingDIV3,
+        OMX_VIDEO_CodingAVS,
+        OMX_VIDEO_CodingRVG2,
+        OMX_VIDEO_CodingFLV1,
+        OMX_VIDEO_CodingVP6,
+        OMX_VIDEO_CodingVP8
+                } VIDDEC_CUSTOM_CODINGTYPE;
+    
+    
+    
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
+        compressionFormat = OMX_VIDEO_CodingAVC;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
+        compressionFormat = OMX_VIDEO_CodingMPEG4;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RV, mime)) {
+         compressionFormat = OMX_VIDEO_CodingRV;
+    }else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
+        compressionFormat = OMX_VIDEO_CodingH263;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP8, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP8;
+    } else if(!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP6, mime)){
+                compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP6;
+    }
+    else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
+        compressionFormat = OMX_VIDEO_CodingMPEG2;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIV3, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingDIV3;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_FLV1, mime)) {
+         compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingFLV1;
+        } else if(!strcasecmp(MEDIA_MIMETYPE_VIDEO_VC1, mime)) {
+                compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVC1;
+        }else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_RVG2, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingRVG2;
+    }else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MJPG, mime)) {
+        compressionFormat = OMX_VIDEO_CodingMJPEG;
+    }else {
+        ALOGE("Not a supported video mime type: %s", mime);
+        CHECK(!"Should not be here. Not a supported video mime type.");
+    }
+  }else{
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingAVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
@@ -1517,6 +1722,7 @@ status_t OMXCodec::setVideoOutputFormat(
 #endif
             ALOGE("Not a supported video mime type: %s", mime);
             CHECK(!"Should not be here. Not a supported video mime type.");
+        }
 #ifdef QCOM_HARDWARE
         }
 #endif
@@ -1650,6 +1856,14 @@ status_t OMXCodec::setVideoOutputFormat(
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
 
+    if(IS_THUMBNAIL&&!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){            
+                 def.nBufferCountActual = 3;           
+         }
+    if(IS_THUMBNAIL&&!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){           
+                err = mOMX->setParameter(
+                                       mNode, (OMX_INDEXTYPE)OMX_IndexThumbnail, &def, sizeof(def));
+    }
+
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -1701,13 +1915,46 @@ OMXCodec::OMXCodec(
     mPortStatus[kPortIndexInput] = ENABLED;
     mPortStatus[kPortIndexOutput] = ENABLED;
 
+    mFinalStatus = OK;
     setComponentRole();
 }
 
+#define VIDDEC_COMPONENTROLES_H263                              "video_decoder.h263"
+#define VIDDEC_COMPONENTROLES_AVC                               "video_decoder.avc"
+#define VIDDEC_COMPONENTROLES_MPEG2                             "video_decoder.mpeg2"
+#define VIDDEC_COMPONENTROLES_MPEG4                             "video_decoder.mpeg4"
+#define VIDDEC_COMPONENTROLES_VC1                               "video_decoder.vc1"
+#define VIDDEC_COMPONENTROLES_AVS                               "video_decoder.avs"
+#define VIDDEC_COMPONENTROLES_RV                                "video_decoder.rv"
+#define VIDDEC_COMPONENTROLES_RVG2                              "video_decoder.rvg2"
+#define VIDDEC_COMPONENTROLES_MJPEG                             "video_decoder.mjpeg"
+#define VIDDEC_COMPONENTROLES_DIV3                              "video_decoder.div3"
+#define VIDDEC_COMPONENTROLES_FLV1              "video_decoder.flv1"
+#define VIDDEC_COMPONENTROLES_VP6                               "video_decoder.VP6"
+#define VIDDEC_COMPONENTROLES_VP8                               "video_decoder.VP8"
 // static
 void OMXCodec::setComponentRole(
         const sp<IOMX> &omx, IOMX::node_id node, bool isEncoder,
         const char *mime) {
+#define AUDDEC_COMPONENTROLES_MP3                               "audio_decoder.mp3"
+#define AUDDEC_COMPONENTROLES_AAC                               "audio_decoder.aac"
+#define AUDDEC_COMPONENTROLES_WMASTD                    "audio_decoder.wmastd"
+#define AUDDEC_COMPONENTROLES_WMALSL                    "audio_decoder.wmalsl"
+#define AUDDEC_COMPONENTROLES_WMAPRO                    "audio_decoder.wmapro"
+#define AUDDEC_COMPONENTROLES_COOK                              "audio_decoder.cook"
+#define AUDDEC_COMPONENTROLES_PCM                               "audio_decoder.pcm"
+#define AUDDEC_COMPONENTROLES_OGG                               "audio_decoder.ogg"
+#define AUDDEC_COMPONENTROLES_DTS                               "audio_decoder.dts"  
+#define AUDDEC_COMPONENTROLES_AC3                               "audio_decoder.ac3"
+#define AUDDEC_COMPONENTROLES_APE                               "audio_decoder.ape"
+#define AUDDEC_COMPONENTROLES_FLAC                              "audio_decoder.flac"
+#define AUDDEC_COMPONENTROLES_ACELP                             "audio_decoder.acelp"
+#define AUDDEC_COMPONENTROLES_MPC                               "audio_decoder.mpc"
+#define AUDDEC_COMPONENTROLES_AIFF                              "audio_decoder.aiff"
+#define AUDDEC_COMPONENTROLES_AMR                               "audio_decoder.amr"
+#define AUDDEC_COMPONENTROLES_SAMPLE                "audio_decoder.sample"
+#define AUDDEC_COMPONENTROLES_ALAC                              "audio_decoder.alac"
+#define AUDDEC_COMPONENTROLES_AWB                               "audio_decoder.awb"    
     struct MimeToRole {
         const char *mime;
         const char *decoderRole;
@@ -1743,14 +1990,68 @@ void OMXCodec::setComponentRole(
             "video_decoder.avc", "video_encoder.avc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
-        { MEDIA_MIMETYPE_VIDEO_H263,
-            "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VPX,
             "video_decoder.vpx", "video_encoder.vpx" },
         { MEDIA_MIMETYPE_AUDIO_RAW,
             "audio_decoder.raw", "audio_encoder.raw" },
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
+        { MEDIA_MIMETYPE_VIDEO_H263,
+          VIDDEC_COMPONENTROLES_H263, "video_encoder.h263" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG2,
+          VIDDEC_COMPONENTROLES_MPEG2, "" },
+        { MEDIA_MIMETYPE_VIDEO_DIV3,
+          VIDDEC_COMPONENTROLES_DIV3, "" },
+        { MEDIA_MIMETYPE_VIDEO_VP6,
+          VIDDEC_COMPONENTROLES_VP6, "" },
+        { MEDIA_MIMETYPE_VIDEO_VP8,
+          VIDDEC_COMPONENTROLES_VP8, "" },
+        { MEDIA_MIMETYPE_VIDEO_RVG2,
+          VIDDEC_COMPONENTROLES_RVG2, "" },
+        { MEDIA_MIMETYPE_VIDEO_FLV1,
+          VIDDEC_COMPONENTROLES_FLV1, "" },
+        { MEDIA_MIMETYPE_VIDEO_RV,
+          VIDDEC_COMPONENTROLES_RV,"" },
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+          VIDDEC_COMPONENTROLES_VC1,"" },
+        { MEDIA_MIMETYPE_AUDIO_ACT_MP3,
+            AUDDEC_COMPONENTROLES_MP3, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_AAC,
+            AUDDEC_COMPONENTROLES_AAC, ""}, 
+        { MEDIA_MIMETYPE_AUDIO_ACT_WMASTD,
+            AUDDEC_COMPONENTROLES_WMASTD, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_WMALSL,
+            AUDDEC_COMPONENTROLES_WMALSL, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_WMAPRO,
+            AUDDEC_COMPONENTROLES_WMAPRO, ""},  
+        { MEDIA_MIMETYPE_AUDIO_ACT_COOK,
+            AUDDEC_COMPONENTROLES_COOK, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_PCM,
+            AUDDEC_COMPONENTROLES_PCM, ""},    
+        { MEDIA_MIMETYPE_AUDIO_ACT_OGG,
+            AUDDEC_COMPONENTROLES_OGG, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_DTS,
+            AUDDEC_COMPONENTROLES_DTS, ""},               
+        { MEDIA_MIMETYPE_AUDIO_ACT_AC3,
+            AUDDEC_COMPONENTROLES_AC3, ""}, 
+        { MEDIA_MIMETYPE_AUDIO_ACT_APE,
+            AUDDEC_COMPONENTROLES_APE, ""}, 
+        { MEDIA_MIMETYPE_AUDIO_ACT_FLAC,
+            AUDDEC_COMPONENTROLES_FLAC, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_ACELP,
+            AUDDEC_COMPONENTROLES_ACELP, ""},       
+        { MEDIA_MIMETYPE_AUDIO_ACT_MPC,
+            AUDDEC_COMPONENTROLES_MPC, ""},        
+        { MEDIA_MIMETYPE_AUDIO_ACT_AIFF,
+            AUDDEC_COMPONENTROLES_AIFF, ""},          
+        { MEDIA_MIMETYPE_AUDIO_ACT_AMR,
+            AUDDEC_COMPONENTROLES_AMR, ""}, 
+        { MEDIA_MIMETYPE_AUDIO_ACT_SAMPLE,
+            AUDDEC_COMPONENTROLES_SAMPLE, ""},   
+        { MEDIA_MIMETYPE_AUDIO_ACT_ALAC,
+            AUDDEC_COMPONENTROLES_ALAC, ""},
+        { MEDIA_MIMETYPE_AUDIO_ACT_AWB,
+            AUDDEC_COMPONENTROLES_AWB, ""}, 
 #ifdef QCOM_HARDWARE
         { MEDIA_MIMETYPE_VIDEO_DIVX,
             "video_decoder.divx", NULL },
@@ -1841,9 +2142,24 @@ status_t OMXCodec::init() {
 
     err = allocateBuffers();
     if (err != (status_t)OK) {
+        if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER) ){
+          freeBuffersOnPort(kPortIndexInput,true);
+          freeBuffersOnPort(kPortIndexOutput,true);  
+         setState(ERROR);  
+      }
         return err;
     }
 
+    if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){
+       int param;
+       if(mFlags & kPreferSoftwareCodecs){
+               CODEC_LOGE("The third party Extractor,Action Decoder \n");
+               mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexVideoDecInit,
+                &param, sizeof(int));
+       }
+
+    }
+
     if (mQuirks & kRequiresLoadedToIdleAfterAllocation) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
@@ -1926,7 +2242,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         IOMX::buffer_id buffer;
         if (portIndex == kPortIndexInput
                 && ((mQuirks & kRequiresAllocateBufferOnInputPorts)
-                    || (mFlags & kUseSecureInputBuffers))) {
+                    || (mFlags & kUseSecureInputBuffers)|| (mFlags & kPreferSoftwareCodecs))) {
             if (mOMXLivesLocally) {
                 mem.clear();
 
@@ -2073,6 +2389,8 @@ status_t OMXCodec::applyRotation() {
 status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     // Get the number of buffers needed.
     OMX_PARAM_PORTDEFINITIONTYPE def;
+    int grallocColorFormat;
+    int result;
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
 
@@ -2082,12 +2400,46 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         CODEC_LOGE("getParameter failed: %d", err);
         return err;
     }
+        err = mNativeWindow->query(mNativeWindow.get(),NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,&result);
+        if(err){
+          ALOGE("  mAnw->query  NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER = %d !",result);
+        }else{
+                ALOGE(" NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER  = %d !",result);
+        }
+        
+        /*ヨ window瀹浣绫诲淇℃锛姝ゅ杩搴璇ユsurfaceTextureClinent */
+        err =mNativeWindow->query(mNativeWindow.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
+        if(err){
+                ALOGE(" mAnw->query  NATIVE_WINDOW_CONCRETE_TYPE = %d !",result);
+        }else{
+                ALOGE(" NATIVE_WINDOW_CONCRETE_TYPE  = %d !",result);
+        }
+
+    err = native_window_set_scaling_mode(mNativeWindow.get(),
+            NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
+    if (err != OK) {
+        return err;
+    }
+    switch(def.format.video.eColorFormat)
+    {
+        case OMX_COLOR_FormatYUV420Planar:
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+                        case OMX_COLOR_FormatYUV420SemiPlanar:
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+                        default:
+                                ALOGE("Format: %d not support! Use HAL_PIXEL_FORMAT_YV12",def.format.video.eColorFormat);
+                                grallocColorFormat =  HAL_PIXEL_FORMAT_ACT_NV12;
+                                break;
+    }
+         def.format.video.eColorFormat=(OMX_COLOR_FORMATTYPE)grallocColorFormat;
 
 #ifndef USE_SAMSUNG_COLORFORMAT
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
-            def.format.video.nFrameWidth,
-            def.format.video.nFrameHeight,
+            def.format.video.nStride,
+            (def.format.video.nFrameHeight+15)&(~15),
             def.format.video.eColorFormat);
 #else
     OMX_COLOR_FORMATTYPE eColorFormat;
@@ -2157,7 +2509,7 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     ALOGV("native_window_set_usage usage=0x%lx", usage);
 
     err = native_window_set_usage(
-            mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
+            mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP |GRALLOC_USAGE_HW_VIDEO);
 
     if (err != 0) {
         ALOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
@@ -2280,22 +2632,41 @@ status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
 
 OMXCodec::BufferInfo* OMXCodec::dequeueBufferFromNativeWindow() {
     // Dequeue the next buffer from the native window.
+    size_t i;
+    size_t owned;
+    size_t totalBuffers;
+    Vector<BufferInfo> *buffers;
+
+    buffers = &mPortBuffers[kPortIndexOutput];
+    totalBuffers = buffers->size();
+    owned = 0;
+    for (i = 0; i < totalBuffers; i++) {
+        BufferInfo *info = &buffers->editItemAt(i);
+        if (info->mStatus != OWNED_BY_NATIVE_WINDOW) {
+           owned += 1;
+        }
+    }
+    if (owned >= 18) {
+        // stop request more video buffers if we already have enough
+        return NULL;
+    }
     ANativeWindowBuffer* buf;
     int fenceFd = -1;
     int err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf);
     if (err != 0) {
       CODEC_LOGE("dequeueBuffer failed w/ error 0x%08x", err);
 
-      setState(ERROR);
-      return 0;
+      //setState(ERROR);
+      //return 0;
+      return NULL;
     }
 
     // Determine which buffer we just dequeued.
-    Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
+    
     BufferInfo *bufInfo = 0;
-    for (size_t i = 0; i < buffers->size(); i++) {
-      sp<GraphicBuffer> graphicBuffer = buffers->itemAt(i).
-          mMediaBuffer->graphicBuffer();
+    for (i = 0; i < totalBuffers; i++) {
+      sp<GraphicBuffer> graphicBuffer 
+                = buffers->itemAt(i).mMediaBuffer->graphicBuffer();
       if (graphicBuffer->handle == buf->handle) {
         bufInfo = &buffers->editItemAt(i);
         break;
@@ -2522,6 +2893,17 @@ void OMXCodec::on_message(const omx_message &msg) {
 
             // Buffer could not be released until empty buffer done is called.
             if (info->mMediaBuffer != NULL) {
+                if (mIsEncoder &&
+                    (mQuirks & kDefersOutputBufferAllocation)) {
+                    // If zero-copy mode is enabled this will send the
+                    // input buffer back to the upstream source.
+                    //restorePatchedDataPointer(info);
+                    CHECK(mIsEncoder && (mQuirks & kDefersOutputBufferAllocation));
+                                                                CHECK(mOMXLivesLocally);
+
+                                                                OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+                                                                        header->pBuffer = (OMX_U8 *)info->mData;
+                }
 #ifdef OMAP_ENHANCEMENT
                 if (mIsEncoder &&
                     (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
@@ -2595,6 +2977,24 @@ void OMXCodec::on_message(const omx_message &msg) {
 #endif
             } else if (mPortStatus[kPortIndexOutput] != SHUTTING_DOWN) {
                 CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)ENABLED);
+                if(info->mMediaBuffer && !strcmp(mComponentName, ACTIONS_AUDIO_DECODER))
+                 {
+                    info->mMediaBuffer->setObserver(0);
+                    info->mMediaBuffer->release();
+                    info->mMediaBuffer = NULL;
+                    info->mMediaBuffer = new MediaBuffer(
+                            msg.u.extended_buffer_data.data_ptr,
+                            info->mSize);
+                    info->mMediaBuffer->setObserver(this);
+                 }
+                if(mIsEncoder && mIsVideo && info->mMediaBuffer && mOMXLivesLocally && \
+                                (mQuirks & kRequiresAllocateBufferOnOutputPorts) && \
+                                (mQuirks & kDefersOutputBufferAllocation) && \
+                                (!strncasecmp(mComponentName, "OMX.ACTION.", 11))){
+                                        info->mMediaBuffer->setObserver(0);
+                                        info->mMediaBuffer->release();
+                                        info->mMediaBuffer = NULL;
+                  }
 
                 if (info->mMediaBuffer == NULL) {
                     CHECK(mOMXLivesLocally);
@@ -2860,13 +3260,14 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             break;
         }
 
-#if 0
+#if 1
         case OMX_EventBufferFlag:
         {
             CODEC_LOGV("EVENT_BUFFER_FLAG(%ld)", data1);
 
-            if (data1 == kPortIndexOutput) {
+            if (data1 == kPortIndexOutput && !strcmp(mComponentName, ACTIONS_VIDEO_DECODER)) {
                 mNoMoreOutputData = true;
+                mBufferFilled.signal();
             }
             break;
         }
@@ -3469,9 +3870,11 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         return true;
     }
 
+#if 0    
     if (mPaused) {
         return false;
     }
+#endif    
 
     status_t err;
 
@@ -3553,6 +3956,20 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         }
 
         bool releaseBuffer = true;
+        if (mIsEncoder && (mQuirks & kDefersOutputBufferAllocation)) {
+            CHECK(mOMXLivesLocally && offset == 0);
+
+            OMX_BUFFERHEADERTYPE *header =
+                (OMX_BUFFERHEADERTYPE *)info->mBuffer;
+
+            CHECK(header->pBuffer == info->mData);
+
+            header->pBuffer =
+                (OMX_U8 *)srcBuffer->data() + srcBuffer->range_offset();
+
+            releaseBuffer = false;
+            info->mMediaBuffer = srcBuffer;
+        } else {
 #ifdef OMAP_ENHANCEMENT
         if (mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
             CHECK(mOMXLivesLocally && offset == 0);
@@ -3619,10 +4036,16 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             }
 #else
             CHECK(srcBuffer->data() != NULL) ;
-            memcpy((uint8_t *)info->mData + offset,
-                    (const uint8_t *)srcBuffer->data()
+            if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER) && (!(mFlags & kPreferSoftwareCodecs))){               
+                OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *) info->mBuffer;
+                header->pBuffer = (OMX_U8 *) srcBuffer->data() + srcBuffer->range_offset();   
+            }else{
+                memcpy((uint8_t *)info->mData + offset,
+                        (const uint8_t *)srcBuffer->data()
                         + srcBuffer->range_offset(),
-                    srcBuffer->range_length());
+                        srcBuffer->range_length());
+            }
+        }
 #endif // USE_SAMSUNG_COLORFORMAT
         }
 
@@ -3720,6 +4143,12 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                info->mBuffer, offset,
                timestampUs, timestampUs / 1E6);
 
+    if(mFinalStatus != OK && mIsEncoder){
+       //setState(ERROR);
+       ALOGE("err false");
+       return false;
+    }
+    else {
     err = mOMX->emptyBuffer(
             mNode, info->mBuffer, 0, offset,
             flags, timestampUs);
@@ -3728,6 +4157,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         setState(ERROR);
         return false;
     }
+    }
 
     // This component does not ever signal the EOS flag on output buffers,
     // Thanks for nothing.
@@ -3804,9 +4234,28 @@ status_t OMXCodec::waitForBufferFilled_l() {
         // For timelapse video recording, the timelapse video recording may
         // not send an input frame for a _long_ time. Do not use timeout
         // for video encoding.
+        int bTsp = 0;
+       mOutputFormat->findInt32('ctlp',&bTsp);
+       if((bTsp == 1) || (!mIsVideo)){
         return mBufferFilled.wait(mLock);
+        }
+       else {
+               status_t err = mBufferFilled.waitRelative(mLock, kEncBufferFilledEventTimeOutNs);
+                       if (err != OK) {
+                               CODEC_LOGE("Encoder Timed out waiting for output buffers: %d/%d",
+                                       countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
+                                       countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
+                               return ERROR_END_OF_STREAM;
+                       }
+                       return err;
+       }
+    }
+    status_t err;
+    if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){
+       err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNsForVideo);
+    } else{
+       err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
     }
-    status_t err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
 #ifdef QCOM_HARDWARE
     if ((err == -ETIMEDOUT) && (mPaused == true)){
         // When the audio playback is paused, the fill buffer maybe timed out
@@ -3820,6 +4269,11 @@ status_t OMXCodec::waitForBufferFilled_l() {
             countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
             countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
     }
+    if (0 == strcmp(mComponentName, "OMX.google.aac.decoder")) {
+         // don't take it as a serious error, let the caller to handle the buffers  
+         // and be more flexible
+         err = OK;
+    }
     return err;
 }
 
@@ -4357,6 +4811,42 @@ status_t OMXCodec::start(MetaData *meta) {
             startTimeUs = timeUs;
         }
         params->setInt64(kKeyTime, startTimeUs);
+    
+    if (mIsEncoder && mIsVideo)
+        {
+                OMX_INDEXTYPE index;
+                int bts = 0;
+          
+                meta->findInt32('tsMd',&bts);
+                if(bts == 1) {          
+                        status_t err_ext = mOMX->getExtensionIndex(mNode,"OMX.actions.index.tspacket",&index);
+                        if(err_ext == OK)
+                        {
+                                OMX_ACTIONS_Params actionsParam;
+                                actionsParam.nVersion.s.nVersionMajor = 1;
+                                actionsParam.nVersion.s.nVersionMinor = 1;
+                                actionsParam.nVersion.s.nRevision = 0;
+                                actionsParam.nVersion.s.nStep = 0;
+                                actionsParam.nPortIndex = kPortIndexOutput;
+                                actionsParam.bEnable = OMX_TRUE;
+                                actionsParam.nSize = sizeof(OMX_ACTIONS_Params);
+                                err_ext =mOMX->setParameter(mNode,index,&actionsParam,sizeof(OMX_ACTIONS_Params));      
+                                if(err_ext != OK){
+                                        ALOGE("Not Support TsPacket!!!");
+                                        return err_ext;
+                                }                                               
+                        }
+                }
+        }
+    }
+    //濮璇audio decode open跺ㄧ濮绌洪   
+    if(!strcmp(mComponentName, ACTIONS_AUDIO_DECODER) ) 
+    {
+         ALOGE("audio OMXCodec start init_buf");
+         sp < MetaData > srcFormat = mSource->getFormat();
+          void *init_buf = NULL;
+          srcFormat->findPointer(kKeyESDS, &init_buf);
+          addCodecSpecificData(&init_buf,sizeof(void *));
     }
 
     mCodecSpecificDataIndex = 0;
@@ -4560,12 +5050,21 @@ status_t OMXCodec::read(
             mPaused = false;
         }
 
-        drainInputBuffers();
-
-        if (mState == EXECUTING) {
-            // Otherwise mState == RECONFIGURING and this code will trigger
-            // after the output port is reenabled.
-            fillOutputBuffers();
+        if(mIsEncoder && mIsVideo){
+                ALOGE("Video Encoder status %x",mState);
+                if (mState == EXECUTING) {
+                        // Otherwise mState == RECONFIGURING and this code will trigger
+                        // after the output port is reenabled.
+                        fillOutputBuffers();
+                }
+                drainInputBuffers();
+        }else {
+                drainInputBuffers();
+                if (mState == EXECUTING) {
+                        // Otherwise mState == RECONFIGURING and this code will trigger
+                        // after the output port is reenabled.
+                        fillOutputBuffers();
+                }
         }
     }
 
@@ -4635,7 +5134,8 @@ status_t OMXCodec::read(
 
     while (mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
         if ((err = waitForBufferFilled_l()) != OK) {
-            return err;
+            // return err;
+            return ERROR_END_OF_STREAM;
         }
     }
 
@@ -5139,6 +5639,23 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 int32_t numChannels, sampleRate;
                 inputFormat->findInt32(kKeyChannelCount, &numChannels);
                 inputFormat->findInt32(kKeySampleRate, &sampleRate);
+                ALOGE("*****************************%s  numChannels=%d sampleRate=%d", __FUNCTION__,params.nChannels, params.nSamplingRate);
+                ALOGE("numChannels=%d sampleRate=%d",numChannels,sampleRate);
+                if(!strcmp(mComponentName, ACTIONS_AUDIO_DECODER) )//cz_20121213 瑙flash棰锛璁╂浠宸辫Вㄨ蛋杩
+                {
+                    
+                    if(numChannels>2) //澶т2澹伴蹇椤诲己琛逛负2澹伴
+                    {
+                        ALOGE("numChannels must small than 2 \n");
+                        numChannels=2;
+                    }
+                    params.nSamplingRate=sampleRate;
+                    params.nChannels=numChannels;
+                    err = mOMX->setParameter(
+                            mNode, OMX_IndexParamAudioPcm, &params, sizeof(params));
+                            
+                    ALOGE("ACTIONS_AUDIO_DECODER*****************************\n");                     
+                } 
 
                 if ((OMX_U32)numChannels != params.nChannels) {
                     ALOGV("Codec outputs a different number of channels than "
@@ -5195,13 +5712,15 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             } else if (audio_def->eEncoding == OMX_AUDIO_CodingAAC) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
-                int32_t numChannels, sampleRate, bitRate;
+                int32_t numChannels, sampleRate, bitRate, AACProfile;
                 inputFormat->findInt32(kKeyChannelCount, &numChannels);
                 inputFormat->findInt32(kKeySampleRate, &sampleRate);
                 inputFormat->findInt32(kKeyBitRate, &bitRate);
+                inputFormat->findInt32(kKeyAACProfile, &AACProfile);
                 mOutputFormat->setInt32(kKeyChannelCount, numChannels);
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
+                mOutputFormat->setInt32(kKeyAACProfile, AACProfile);
 #ifdef QCOM_HARDWARE
             } else if (audio_def->eEncoding == OMX_AUDIO_CodingQCELP13 ) {
                 mOutputFormat->setCString(
@@ -5282,32 +5801,40 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                         "video dimensions are %ld x %ld",
                         video_def->nFrameWidth, video_def->nFrameHeight);
 
-                if (err == OK) {
-                    CHECK_GE(rect.nLeft, 0);
-                    CHECK_GE(rect.nTop, 0);
-                    CHECK_GE(rect.nWidth, 0u);
-                    CHECK_GE(rect.nHeight, 0u);
-                    CHECK_LE(rect.nLeft + rect.nWidth - 1, video_def->nFrameWidth);
-                    CHECK_LE(rect.nTop + rect.nHeight - 1, video_def->nFrameHeight);
-
-                    mOutputFormat->setRect(
-                            kKeyCropRect,
-                            rect.nLeft,
-                            rect.nTop,
-                            rect.nLeft + rect.nWidth - 1,
-                            rect.nTop + rect.nHeight - 1);
-
-                    CODEC_LOGI(
-                            "Crop rect is %ld x %ld @ (%ld, %ld)",
-                            rect.nWidth, rect.nHeight, rect.nLeft, rect.nTop);
-                } else {
-                    mOutputFormat->setRect(
+                if(!strcmp(mComponentName, ACTIONS_VIDEO_DECODER)){                     
+                        mOutputFormat->setRect(
                             kKeyCropRect,
                             0, 0,
                             video_def->nFrameWidth - 1,
                             video_def->nFrameHeight - 1);
+                }else{
+                         if (err == OK){
+                                CHECK_GE(rect.nLeft, 0);
+                                CHECK_GE(rect.nTop, 0);
+                                CHECK_GE(rect.nWidth, 0u);
+                                CHECK_GE(rect.nHeight, 0u);
+                                CHECK_LE(rect.nLeft + rect.nWidth - 1, video_def->nFrameWidth);
+                                CHECK_LE(rect.nTop + rect.nHeight - 1, video_def->nFrameHeight);
+
+                               mOutputFormat->setRect(
+                                        kKeyCropRect,
+                                        rect.nLeft,
+                                        rect.nTop,
+                                        rect.nLeft + rect.nWidth - 1,
+                                        rect.nTop + rect.nHeight - 1);
+
+                             CODEC_LOGI(
+                                    "Crop rect is %ld x %ld @ (%ld, %ld)",
+                                    rect.nWidth, rect.nHeight, rect.nLeft, rect.nTop);
+                        }else{
+                                        mOutputFormat->setRect(
+                                            kKeyCropRect,
+                                            0, 0,
+                                            video_def->nFrameWidth - 1,
+                                            video_def->nFrameHeight - 1);
+                        }
                 }
-
+                
                 if (mNativeWindow != NULL) {
                      initNativeWindowCrop();
                 }
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index 510252a..65f877a 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -39,6 +39,7 @@ StagefrightMediaScanner::~StagefrightMediaScanner() {}
 
 static bool FileHasAcceptableExtension(const char *extension) {
     static const char *kValidExtensions[] = {
+#if 0
         ".mp3", ".mp4", ".m4a", ".3gp", ".3gpp", ".3g2", ".3gpp2",
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
@@ -49,6 +50,25 @@ static bool FileHasAcceptableExtension(const char *extension) {
 #else
         ".qcp", ".awb", ".ac3", ".dts", ".wmv"
 #endif
+#endif
+        //by 3307 2012.10.23
+        //audio
+        ".mp3",  ".mp2",  ".mp1", ".m4a", ".wav", ".amr", ".awb",
+        ".wma",  ".ogg",  ".oga", ".aac", ".mka", ".rm",  ".ram",
+        ".ra",   ".dts",  ".ac3", ".aa",  ".aax", ".flac",".ape", 
+        ".pcm",
+        ".mid",  ".midi", ".xmf", ".rtttl",".smf", ".imy",".rtx",
+        ".ota",  ".mxmf",
+        //video
+        ".mpeg", ".mpg",  ".mp4", ".m4v",  ".mov", ".3gp", ".3gpp", 
+        ".3g2",  ".3gpp2",".mkv", ".webm", ".avi", ".ts",  ".m2ts", 
+        ".mts",  ".tp",   ".f4v", ".flv",  ".rmvb",".rm",  ".dat", 
+        ".vob",  "evo",   ".wmv", ".asf",  ".divx", ".ogg", "ogm",
+               ".mpga",
+        //images
+        
+        //others
+        ".fl", ".ec3",   
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index a2f3f13..2745a8f 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -28,6 +28,14 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/OMXCodec.h>
 #include <media/stagefright/MediaDefs.h>
+#include <actal_posix_dev.h>
+
+/** add by kkli, if enable
+  * fix the multi-language display
+  *   1. detect the encoding
+  *   2. convert to utf-8
+  */
+//#define ACTIONS_ASCII_CONVERT
 
 namespace android {
 
@@ -144,6 +152,8 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
         int seekMode) {
 
     sp<MetaData> format = source->getFormat();
+	int64_t mVDuration;
+    format->setInt32(kKeyActCreateThumbnail,1);
 
     // XXX:
     // Once all vendors support OMX_COLOR_FormatYUV420Planar, we can
@@ -189,6 +199,10 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
                 || thumbNailTime < 0) {
             thumbNailTime = 0;
         }
+		if(thumbNailTime==0){
+			format->findInt64(kKeyDuration, &mVDuration);
+			thumbNailTime=mVDuration/2;
+		}
         options.setSeekTo(thumbNailTime, mode);
     } else {
         thumbNailTime = -1;
@@ -248,7 +262,8 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
     int32_t width, height;
     CHECK(meta->findInt32(kKeyWidth, &width));
     CHECK(meta->findInt32(kKeyHeight, &height));
-
+    width=(width+15)&(~15);
+    height=(height+15)&(~15);
     int32_t crop_left, crop_top, crop_right, crop_bottom;
     if (!meta->findRect(
                 kKeyCropRect,
@@ -281,6 +296,18 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
     }
 
     int32_t srcFormat;
+	  uint8_t* pfrm=(uint8_t*)buffer->data();
+
+    
+    if(pfrm==NULL){
+    	 buffer->release();
+       buffer = NULL;
+       decoder->stop();
+       delete frame;
+       frame = NULL;
+       return NULL;
+    }
+    actal_cache_flush(pfrm,width*height*3/2);
     CHECK(meta->findInt32(kKeyColorFormat, &srcFormat));
 
     ColorConverter converter(
@@ -288,7 +315,7 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
 
     if (converter.isValid()) {
         err = converter.convert(
-                (const uint8_t *)buffer->data() + buffer->range_offset(),
+        		(const uint8_t*)pfrm + buffer->range_offset(),
                 width, height,
                 crop_left, crop_top, crop_right, crop_bottom,
                 frame->mData,
@@ -382,9 +409,9 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
 
     VideoFrame *frame =
         extractVideoFrameWithCodecFlags(
-                &mClient, trackMeta, source, OMXCodec::kPreferSoftwareCodecs,
+                &mClient, trackMeta, source, 0/*OMXCodec::kPreferSoftwareCodecs*/,
                 timeUs, option);
-
+#if 0
     if (frame == NULL) {
         ALOGV("Software decoder failed to extract thumbnail, "
              "trying hardware decoder.");
@@ -392,7 +419,7 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
         frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
                         timeUs, option);
     }
-
+#endif
     return frame;
 }
 
@@ -433,7 +460,7 @@ const char *StagefrightMetadataRetriever::extractMetadata(int keyCode) {
         return NULL;
     }
 
-    return strdup(mMetaData.valueAt(index).string());
+    return mMetaData.valueAt(index).string();
 }
 
 void StagefrightMetadataRetriever::parseMetaData() {
@@ -470,7 +497,39 @@ void StagefrightMetadataRetriever::parseMetaData() {
     for (size_t i = 0; i < kNumMapEntries; ++i) {
         const char *value;
         if (meta->findCString(kMap[i].from, &value)) {
-            mMetaData.add(kMap[i].to, String8(value));
+#ifdef ACTIONS_ASCII_CONVERT
+			int inbuf_len = strlen(value);
+			if ((inbuf_len > strlen("")) && (actal_check_utf8(value, inbuf_len) < 0)) {
+				char from_charset[20];		
+				int ret = 0;
+				
+				ret = actal_encode_detect(value, from_charset);
+				if (ret < 0) {
+					ALOGV("parseMetaData: actal_encode_detect fail");
+					continue;
+				}
+				
+				int outbuf_len = 3 * inbuf_len;
+				char *outbuf = new char [outbuf_len];				
+				if (outbuf == NULL) {
+					ALOGV("parseMetaData: new outbuf fail, len=%d", outbuf_len);
+					continue;
+				}
+				
+				ret = actal_convert_ucnv(from_charset, 
+										(char *)"UTF-8", 
+										value, 
+										inbuf_len,
+										outbuf,
+										outbuf_len);
+				if (ret >= 0) {
+					mMetaData.add(kMap[i].to, String8(outbuf));
+				}
+				
+				delete outbuf;
+			}
+#endif
+			mMetaData.add(kMap[i].to, String8(value));	
         }
     }
 
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 3c002fc..57c422d 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -33,6 +33,11 @@
 
 #include <private/gui/ComposerService.h>
 
+
+#include <ui/GraphicBufferMapper.h>
+#include <ui/Rect.h>
+#include "video_mediadata.h"
+
 namespace android {
 
 SurfaceMediaSource::SurfaceMediaSource(uint32_t bufferWidth, uint32_t bufferHeight) :
@@ -271,7 +276,7 @@ static void passMetadataBuffer(MediaBuffer **buffer,
     ALOGV("handle = %p, , offset = %d, length = %d",
             bufferHandle, (*buffer)->range_length(), (*buffer)->range_offset());
 }
-
+const static int64_t kEncBufferTimeOutNs = 3000000000LL;
 status_t SurfaceMediaSource::read( MediaBuffer **buffer,
                                     const ReadOptions *options)
 {
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 7bd2032..afa9b8a 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -27,6 +27,7 @@
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
+#include <media/stagefright/MediaDefs.h>
 
 #ifdef QCOM_ENHANCED_AUDIO
 #include <QCMediaDefs.h>
@@ -88,6 +89,27 @@ status_t convertMetaDataToMessage(
     if (meta->findInt64(kKeyDuration, &durationUs)) {
         msg->setInt64("durationUs", durationUs);
     }
+   int actions_audio_flag=0;
+     actions_audio_flag=(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_MP3, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_AAC, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_WMASTD, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_WMALSL, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_WMAPRO, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_COOK, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_PCM, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_OGG, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_DTS, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_AC3, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_APE, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_FLAC, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_ACELP, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_MPC, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_AIFF, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_AMR, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_SAMPLE, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_ALAC, mime)) \
+                    ||(!strcasecmp(MEDIA_MIMETYPE_AUDIO_ACT_AWB, mime));
+     //ALOGE("===cz======%s convertMetaDataToMessage :actions_audio_flag=%d", __FUNCTION__,actions_audio_flag);
 
     if (!strncasecmp("video/", mime, 6)) {
         int32_t width, height;
@@ -96,6 +118,14 @@ status_t convertMetaDataToMessage(
 
         msg->setInt32("width", width);
         msg->setInt32("height", height);
+
+	 int64_t seekedListTimeBase=0;
+	 int64_t maxSegDuration=0ll;		
+	 meta->findInt64(kKeyActNuSeekedListTimeBase, &seekedListTimeBase);
+	 meta->findInt64(kKeyActMaxSegDuration, &maxSegDuration);
+	 msg->setInt64("nu-seeked-time", seekedListTimeBase);
+        msg->setInt64("max-seg-duration", maxSegDuration);
+			
     } else if (!strncasecmp("audio/", mime, 6)) {
         int32_t numChannels, sampleRate;
         CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
@@ -250,7 +280,9 @@ status_t convertMetaDataToMessage(
         buffer->meta()->setInt32("csd", true);
         buffer->meta()->setInt64("timeUs", 0);
         msg->setBuffer("csd-1", buffer);
-    } else if (meta->findData(kKeyESDS, &type, &data, &size)) {
+    } else if (meta->findData(kKeyESDS, &type, &data, &size)){
+	if(actions_audio_flag == 0)
+	{    
         ESDS esds((const char *)data, size);
         CHECK_EQ(esds.InitCheck(), (status_t)OK);
 
@@ -258,15 +290,30 @@ status_t convertMetaDataToMessage(
         size_t codec_specific_data_size;
         esds.getCodecSpecificInfo(
                 &codec_specific_data, &codec_specific_data_size);
-
-        sp<ABuffer> buffer = new ABuffer(codec_specific_data_size);
+       	sp<ABuffer> buffer = new ABuffer(codec_specific_data_size);
 
         memcpy(buffer->data(), codec_specific_data,
                codec_specific_data_size);
-
+      buffer->meta()->setInt32("csd", true);
+        buffer->meta()->setInt64("timeUs", 0);
+        msg->setBuffer("csd-0", buffer);
+      }
+#if 0 //net video use actaudio
+	else
+	{
+		sp<ABuffer> buffer = new ABuffer(size);
+		memcpy(buffer->data(), data,size);
+		ALOGD("----addr %x",(const char *)data);
+		ALOGD("----%x %x %x %x ",*(const char *)data,*(const char *)(data+1),*(const char *)(data+2),*(const char *)(data+3));
+		ALOGD("----%x",*(const int *)data);
+		int addr_tmp = (int)(*(const int *)data);
+		ALOGD("----%x %x %x",*(int *)addr_tmp,*(int *)(addr_tmp+4),*(int *)(addr_tmp+8));
+		
         buffer->meta()->setInt32("csd", true);
         buffer->meta()->setInt64("timeUs", 0);
         msg->setBuffer("csd-0", buffer);
+    }
+#endif        
     } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
         sp<ABuffer> buffer = new ABuffer(size);
         memcpy(buffer->data(), data, size);
diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index 2640319..1c9fa6a 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -405,8 +405,10 @@ status_t WAVSource::read(
         return err;
     }
 
+    // make sure that maxBytesToRead is multiple of 3, in 24-bit case
     size_t maxBytesToRead =
-        mBitsPerSample == 8 ? kMaxFrameSize / 2 : kMaxFrameSize;
+        mBitsPerSample == 8 ? kMaxFrameSize / 2 : 
+        (mBitsPerSample == 24 ? 3*(kMaxFrameSize/3): kMaxFrameSize);
 
     size_t maxBytesAvailable =
         (mCurrentPos - mOffset >= (off64_t)mSize)
@@ -429,7 +431,7 @@ status_t WAVSource::read(
 
     buffer->set_range(0, n);
 
-    if (mWaveFormat == WAVE_FORMAT_PCM) {
+    if (mWaveFormat == WAVE_FORMAT_PCM || mWaveFormat == WAVE_FORMAT_EXTENSIBLE) {
         if (mBitsPerSample == 8) {
             // Convert 8-bit unsigned samples to 16-bit signed.
 
diff --git a/media/libstagefright/avc_utils.cpp b/media/libstagefright/avc_utils.cpp
index 7bfa375..ae5152d 100644
--- a/media/libstagefright/avc_utils.cpp
+++ b/media/libstagefright/avc_utils.cpp
@@ -405,6 +405,78 @@ sp<MetaData> MakeAACCodecSpecificData(
 
     return meta;
 }
+//#define USE_ACTIONS_AUDIO
+sp<MetaData> MakeAACCodecSpecificData_1(void *init_buf,
+        unsigned profile, unsigned sampling_freq_index,
+        unsigned channel_configuration) {
+    sp<MetaData> meta = new MetaData;
+#ifdef USE_ACTIONS_AUDIO
+	meta->setCString(kKeyMIMEType, "audio/AAC");
+#else    
+    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AAC);
+#endif    
+
+    CHECK_LE(sampling_freq_index, 11u);
+    static const int32_t kSamplingFreq[] = {
+        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050,
+        16000, 12000, 11025, 8000
+    };
+
+#ifdef USE_ACTIONS_AUDIO
+	int32_t samplerate = kSamplingFreq[sampling_freq_index];
+    if (kSamplingFreq[sampling_freq_index] < 24*1024)
+    {
+		samplerate = kSamplingFreq[sampling_freq_index]*2;
+	}
+	meta->setInt32(kKeySampleRate,samplerate);
+#else
+    
+    meta->setInt32(kKeySampleRate, kSamplingFreq[sampling_freq_index]);
+#endif
+    meta->setInt32(kKeyChannelCount, channel_configuration);
+
+    static const uint8_t kStaticESDS[] = {
+        0x03, 22,
+        0x00, 0x00,     // ES_ID
+        0x00,           // streamDependenceFlag, URL_Flag, OCRstreamFlag
+
+        0x04, 17,
+        0x40,                       // Audio ISO/IEC 14496-3
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00,
+
+        0x05, 2,
+        // AudioSpecificInfo follows
+
+        // oooo offf fccc c000
+        // o - audioObjectType
+        // f - samplingFreqIndex
+        // c - channelConfig
+    };
+#ifdef USE_ACTIONS_AUDIO
+
+	sp<ABuffer> csd = new ABuffer(init_buf,12);
+	*((int32_t *)(init_buf)) = profile + 1;
+	*((int32_t *)(init_buf + 4)) = sampling_freq_index;
+	*((int32_t *)(init_buf + 8))  = channel_configuration;
+	ALOGD("csd->data() %x csd->data()[0] %x",csd->data(),csd->data()[0]);
+	ALOGD("profile %x,sampling_freq_index %x,channel_configuration %x",profile,sampling_freq_index,channel_configuration);
+	meta->setPointer(kKeyESDS, (void*)(csd->data()));
+#else
+    sp<ABuffer> csd = new ABuffer(sizeof(kStaticESDS) + 2);
+    memcpy(csd->data(), kStaticESDS, sizeof(kStaticESDS));
+
+    csd->data()[sizeof(kStaticESDS)] =
+        ((profile + 1) << 3) | (sampling_freq_index >> 1);
+
+    csd->data()[sizeof(kStaticESDS) + 1] =
+        ((sampling_freq_index << 7) & 0x80) | (channel_configuration << 3);
+
+    meta->setData(kKeyESDS, 0, csd->data(), csd->size());
+#endif
+    return meta;
+}
 
 bool ExtractDimensionsFromVOLHeader(
         const uint8_t *data, size_t size, int32_t *width, int32_t *height) {
diff --git a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
index 91ce175..34b3827 100644
--- a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
+++ b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
@@ -102,7 +102,17 @@ status_t ChromiumHTTPDataSource::connect_l(
     mDelegate->initiateConnection(mURI.c_str(), &mHeaders, offset);
 
     while (mState == CONNECTING || mState == DISCONNECTING) {
-        mCondition.wait(mLock);
+        //mCondition.wait(mLock);
+        int64_t time1, time2;
+		int timeout = 15;
+		time1 = systemTime() / 1000;
+		status_t err = mCondition.waitRelative(mLock, seconds(timeout));
+		time2 = systemTime() / 1000;
+		if (err == TIMED_OUT) {
+			disconnect_l();
+			ALOGW("connect_l timeout: %.2f( > %d) mState: %d", (time2-time1)/1E6, timeout, mState);
+			return ERROR_READ_TIME_OUT_SP;
+		}
     }
 
     return mState == CONNECTED ? OK : mIOResult;
@@ -149,7 +159,7 @@ void ChromiumHTTPDataSource::disconnect_l() {
 
     mDelegate->initiateDisconnect();
 
-    while (mState == DISCONNECTING) {
+    while (mState != DISCONNECTED) {
         mCondition.wait(mLock);
     }
 
@@ -199,7 +209,17 @@ ssize_t ChromiumHTTPDataSource::readAt(off64_t offset, void *data, size_t size)
     mDelegate->initiateRead(data, size);
 
     while (mState == READING) {
-        mCondition.wait(mLock);
+        //mCondition.wait(mLock);
+		int64_t time1, time2;
+		int timeout = size/(1024*10) + 15;
+		time1 = systemTime() / 1000;
+		status_t err = mCondition.waitRelative(mLock, seconds(timeout));
+		time2 = systemTime() / 1000;
+		if (err == TIMED_OUT) {
+			disconnect_l();
+			ALOGW("size: %d timeout: %.2f( > %d) mState: %d", size, (time2-time1)/1E6, timeout, mState);
+			return ERROR_READ_TIME_OUT_SP;
+		}
     }
 
     if (mIOResult < OK) {
@@ -308,6 +328,11 @@ String8 ChromiumHTTPDataSource::getUri() {
 
     return String8(mURI.c_str());
 }
+void ChromiumHTTPDataSource::setUri(AString url) {
+   Mutex::Autolock autoLock(mLock);
+   mURI = url;
+   //LOG_PRI(ANDROID_LOG_VERBOSE, LOG_TAG, "setUri: ----------- OK!!!");
+}
 
 String8 ChromiumHTTPDataSource::getMIMEType() const {
     Mutex::Autolock autoLock(mLock);
diff --git a/media/libstagefright/chromium_http/support.cpp b/media/libstagefright/chromium_http/support.cpp
index 13ae3df..a63eaaa 100644
--- a/media/libstagefright/chromium_http/support.cpp
+++ b/media/libstagefright/chromium_http/support.cpp
@@ -46,6 +46,7 @@ static Mutex gNetworkThreadLock;
 static base::Thread *gNetworkThread = NULL;
 static scoped_refptr<net::URLRequestContext> gReqContext;
 static scoped_ptr<net::NetworkChangeNotifier> gNetworkChangeNotifier;
+static bool mNeedIpadUserAgentFlag=true; //false;
 
 bool logMessageHandler(
         int severity,
@@ -157,8 +158,9 @@ net::NetLog::LogLevel SfNetLog::GetLogLevel() const {
 
 SfRequestContext::SfRequestContext() {
     AString ua;
+    AString tmp;
     ua.append("stagefright/1.2 (Linux;Android ");
-
+	tmp.append("AppleCoreMedia/1.0.0.8C148 (iPad; U; CPU OS 5_1 like Mac OS X; zh_cn");
 #if (PROPERTY_VALUE_MAX < 8)
 #error "PROPERTY_VALUE_MAX must be at least 8"
 #endif
@@ -167,9 +169,12 @@ SfRequestContext::SfRequestContext() {
     property_get("ro.build.version.release", value, "Unknown");
     ua.append(value);
     ua.append(")");
-
+	tmp.append(value);
+    tmp.append(")");
+    
+	mNeedIpadUserAgentFlag = true; //false;
     mUserAgent = ua.c_str();
-
+    mIpadUserAgent = tmp.c_str();
     set_net_log(new SfNetLog());
 
     set_host_resolver(
@@ -200,7 +205,14 @@ SfRequestContext::SfRequestContext() {
 }
 
 const std::string &SfRequestContext::GetUserAgent(const GURL &url) const {
-    return mUserAgent;
+	//MY_LOGI(StringPrintf("GetUserAgent: get url:  %s flag: %d", url.spec().c_str(), mNeedIpadUserAgentFlag).c_str());
+	if (mNeedIpadUserAgentFlag == false) {
+		//MY_LOGI(StringPrintf("GetUserAgent: mUserAgent: %s",mUserAgent.c_str()).c_str());
+    	return mUserAgent;
+   }else {
+		//MY_LOGI(StringPrintf("GetUserAgent: mIpadUserAgent: %s",mIpadUserAgent.c_str()).c_str());
+   		return mIpadUserAgent;
+   }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -224,6 +236,10 @@ SfDelegate::SfDelegate()
       mNumBytesTotal(0),
       mDataDestination(NULL),
       mAtEOS(false) {
+    mInUri = NULL;
+    mInOffset = 0ll;
+    mInHeaders = NULL;
+    mNeedIpadUserAgentFlag = true;
     InitializeNetworkThreadIfNecessary();
 }
 
@@ -246,6 +262,12 @@ bool SfDelegate::getUID(uid_t *uid) const {
 void SfDelegate::OnReceivedRedirect(
             net::URLRequest *request, const GURL &new_url, bool *defer_redirect) {
     MY_LOGV("OnReceivedRedirect");
+    
+    /*std::string headers;
+    request->GetAllResponseHeaders(&headers);
+    MY_LOGI(StringPrintf("OnReceivedRedirect: headers %s", headers.c_str()).c_str());*/
+	//MY_LOGI(StringPrintf("OnReceivedRedirect: new_url %s", new_url.spec().c_str()).c_str());
+    mOwner->setUri(new_url.spec().c_str());
 }
 
 void SfDelegate::OnAuthRequired(
@@ -282,42 +304,63 @@ void SfDelegate::OnSetCookie(
 }
 
 void SfDelegate::OnResponseStarted(net::URLRequest *request) {
+	bool meetErrorFlag=false;
     if (request->status().status() != net::URLRequestStatus::SUCCESS) {
         MY_LOGI(StringPrintf(
-                    "Request failed with status %d and os_error %d",
+                    "OnResponseStarted: Request failed with status %d and os_error %d",
                     request->status().status(),
                     request->status().os_error()).c_str());
 
         delete mURLRequest;
         mURLRequest = NULL;
 
-        mOwner->onConnectionFailed(ERROR_IO);
-        return;
+        meetErrorFlag = true;
+		if (mNeedIpadUserAgentFlag == false) {
+	    	mOwner->onConnectionFailed(ERROR_IO);
+	    	return;
+	    }
     } else if (mRangeRequested && request->GetResponseCode() != 206) {
         MY_LOGI(StringPrintf(
-                    "We requested a content range, but server didn't "
+                    "OnResponseStarted: We requested a content range, but server didn't "
                     "support that. (responded with %d)",
                     request->GetResponseCode()).c_str());
 
         delete mURLRequest;
         mURLRequest = NULL;
 
-        mOwner->onConnectionFailed(-EPIPE);
-        return;
+		meetErrorFlag = true;
+		if (mNeedIpadUserAgentFlag == false) {
+	    	mOwner->onConnectionFailed(-EPIPE);
+	    	return;
+	    }
     } else if ((request->GetResponseCode() / 100) != 2) {
-        MY_LOGI(StringPrintf(
-                    "Server responded with http status %d",
-                    request->GetResponseCode()).c_str());
-
+    	MY_LOGI(StringPrintf(
+			 "OnResponseStarted: Request failed with status: %d and os_error: %d respondedCode(%d)",
+			 request->status().status(),
+			 request->status().os_error(), request->GetResponseCode()).c_str());
+		 
         delete mURLRequest;
         mURLRequest = NULL;
 
-        mOwner->onConnectionFailed(ERROR_IO);
-        return;
+		meetErrorFlag = true;
+		if (mNeedIpadUserAgentFlag == false) {
+	    	mOwner->onConnectionFailed(ERROR_IO);
+	    	return;
+	    }
     }
 
-    MY_LOGV("OnResponseStarted");
+	// change userAgent one times when meet error
+	if (meetErrorFlag == true) {
+		mNeedIpadUserAgentFlag = false;
+
+		initiateConnection(mInUri, mInHeaders, mInOffset);
+		MY_LOGI(StringPrintf(
+			 "OnResponseAgain: repeatly Request Uri: %s Headers: %p Offset: %lld Flag: %d",
+			 mInUri, (void *)mInHeaders, mInOffset, mNeedIpadUserAgentFlag).c_str());
+		return;
+	}
 
+	
     std::string headers;
     request->GetAllResponseHeaders(&headers);
 
@@ -376,7 +419,7 @@ void SfDelegate::readMore(net::URLRequest *request) {
 
         int n;
         if (request->Read(mReadBuffer, copy, &n)) {
-            MY_LOGV(StringPrintf("Read %d bytes directly.", n).c_str());
+           // MY_LOGV(StringPrintf("readMore: Read %d bytes directly.", n).c_str());
 
             CHECK_LE((size_t)n, copy);
 
@@ -391,7 +434,7 @@ void SfDelegate::readMore(net::URLRequest *request) {
                 break;
             }
         } else {
-            MY_LOGV("readMore pending read");
+            //MY_LOGV("readMore: pending read");
 
             if (request->status().status() != net::URLRequestStatus::IO_PENDING) {
                 MY_LOGI(StringPrintf(
@@ -413,6 +456,12 @@ void SfDelegate::initiateConnection(
         const char *uri,
         const KeyedVector<String8, String8> *headers,
         off64_t offset) {
+    MY_LOGV("initiateConnection");
+    //MY_LOGI(StringPrintf("initiateConnection: uri: %s offset: %lld\n", (char *)uri, offset).c_str());
+    mInUri = uri;
+    mInOffset = offset;
+    mInHeaders = headers;
+    
     GURL url(uri);
 
     MessageLoop *loop = gNetworkThread->message_loop();
diff --git a/media/libstagefright/chromium_http/support.h b/media/libstagefright/chromium_http/support.h
index d2c5bc0..168dfcf 100644
--- a/media/libstagefright/chromium_http/support.h
+++ b/media/libstagefright/chromium_http/support.h
@@ -29,6 +29,7 @@
 #include <utils/KeyedVector.h>
 #include <utils/String8.h>
 
+#define MAX_READ_DATA_TIME_US	(2*60*1000000) //2min = 2*60s
 namespace android {
 
 struct SfNetLog : public net::NetLog {
@@ -57,7 +58,8 @@ struct SfRequestContext : public net::URLRequestContext {
 
 private:
     std::string mUserAgent;
-
+	std::string mIpadUserAgent;
+	
     DISALLOW_EVIL_CONSTRUCTORS(SfRequestContext);
 };
 
@@ -135,6 +137,9 @@ private:
     bool mRangeRequested;
     bool mAtEOS;
 
+	const char *mInUri;
+	const KeyedVector<String8, String8> *mInHeaders;
+	off64_t mInOffset;
     void readMore(net::URLRequest *request);
 
     static void OnInitiateConnectionWrapper(
diff --git a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
index 606a43d..c8eea60 100644
--- a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
+++ b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
@@ -407,8 +407,11 @@ void SoftAAC2::onQueueFilled(OMX_U32 portIndex) {
         }
 
         if (inHeader->nOffset == 0) {
-            mAnchorTimeUs = inHeader->nTimeStamp;
-            mNumSamplesOutput = 0;
+            if(inHeader->nTimeStamp!=0) //cz_20121012 bug fix tudou video
+            {
+                mAnchorTimeUs = inHeader->nTimeStamp;
+                mNumSamplesOutput = 0;
+            }
         }
 
         size_t adtsHeaderSize = 0;
diff --git a/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp b/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp
index c5f733b..4d4212f 100644
--- a/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp
+++ b/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp
@@ -154,7 +154,7 @@ OMX_ERRORTYPE SoftAMR::internalGetParameter(
 
             amrParams->nChannels = 1;
             amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;
-            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatConformance;
+            amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;
 
             if (!isConfigured()) {
                 amrParams->nBitRate = 0;
diff --git a/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp b/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp
index 8bc0275..bfaa91e 100644
--- a/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp
+++ b/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp
@@ -748,12 +748,13 @@ void SoftMPEG4Encoder::onQueueFilled(OMX_U32 portIndex) {
         outQueue.erase(outQueue.begin());
         CHECK(!mInputBufferInfoVec.empty());
         InputBufferInfo *inputBufInfo = mInputBufferInfoVec.begin();
-        mInputBufferInfoVec.erase(mInputBufferInfoVec.begin());
+        //mInputBufferInfoVec.erase(mInputBufferInfoVec.begin());
         outHeader->nTimeStamp = inputBufInfo->mTimeUs;
         outHeader->nFlags |= (inputBufInfo->mFlags | OMX_BUFFERFLAG_ENDOFFRAME);
         outHeader->nFilledLen = dataLength;
         outInfo->mOwnedByUs = false;
         notifyFillBufferDone(outHeader);
+        mInputBufferInfoVec.erase(mInputBufferInfoVec.begin());
     }
 }
 
diff --git a/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp b/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp
index 946e3d0..c6bde47 100644
--- a/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp
+++ b/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp
@@ -79,7 +79,7 @@ const static Int profile_level_max_packet_size[8] =
 
 const static Int profile_level_max_mbsPerSec[8] =
 {
-    1485, 1485, 5940, 11880, 5940, 23760, 23760, 23760
+    1485, 1485, 5940, 11880, 5940, 244800, 244800, 244800
 };
 
 const static Int profile_level_max_VBV_size[8] =
diff --git a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
index ac88107..fab0b0c 100644
--- a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
+++ b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
@@ -93,7 +93,7 @@ void SoftVorbis::initPorts() {
 
     def.format.audio.pNativeRender = NULL;
     def.format.audio.bFlagErrorConcealment = OMX_FALSE;
-    def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;
+    def.format.audio.eEncoding = OMX_AUDIO_CodingVORBIS;
 
     addPort(def);
 
diff --git a/media/libstagefright/httplive/LiveSession.cpp b/media/libstagefright/httplive/LiveSession.cpp
index 733753b..3b25308 100644
--- a/media/libstagefright/httplive/LiveSession.cpp
+++ b/media/libstagefright/httplive/LiveSession.cpp
@@ -58,9 +58,13 @@ LiveSession::LiveSession(uint32_t flags, bool uidValid, uid_t uid)
       mStartOfPlayback(true),
       mDurationUs(-1),
       mDurationFixed(false),
-      mSeekDone(false),
+      mMaxSegDuration(0ll),
+      mSeekedListTimeBase(0),
+      mSeekDone(true),
       mDisconnectPending(false),
       mMonitorQueueGeneration(0),
+      m_retrying(false),
+      seeking_count(10),
       mRefreshState(INITIAL_MINIMUM_RELOAD_DELAY) {
     if (mUIDValid) {
         mHTTPDataSource->setUID(mUID);
@@ -92,13 +96,16 @@ void LiveSession::disconnect() {
     Mutex::Autolock autoLock(mLock);
     mDisconnectPending = true;
 
-    mHTTPDataSource->disconnect();
 
     (new AMessage(kWhatDisconnect, id()))->post();
 }
 
 void LiveSession::seekTo(int64_t timeUs) {
     Mutex::Autolock autoLock(mLock);
+
+	if (m_retrying)
+		return;
+	
     mSeekDone = false;
 
     sp<AMessage> msg = new AMessage(kWhatSeek, id());
@@ -117,6 +124,7 @@ void LiveSession::onMessageReceived(const sp<AMessage> &msg) {
             break;
 
         case kWhatDisconnect:
+            mHTTPDataSource->disconnect();
             onDisconnect();
             break;
 
@@ -127,6 +135,7 @@ void LiveSession::onMessageReceived(const sp<AMessage> &msg) {
 
             if (generation != mMonitorQueueGeneration) {
                 // Stale event
+                ALOGW("LiveSession a Stale event");
                 break;
             }
 
@@ -158,18 +167,26 @@ int LiveSession::SortByBandwidth(const BandwidthItem *a, const BandwidthItem *b)
 void LiveSession::onConnect(const sp<AMessage> &msg) {
     AString url;
     CHECK(msg->findString("url", &url));
-
+    int retry;
     KeyedVector<String8, String8> *headers = NULL;
-    if (!msg->findPointer("headers", (void **)&headers)) {
-        mExtraHeaders.clear();
-    } else {
-        mExtraHeaders = *headers;
+	if (!msg->findInt32("retry", &retry)) {
+        if (!msg->findPointer("headers", (void **)&headers)) {
+            mExtraHeaders.clear();
+        } else {
+            mExtraHeaders = *headers;
 
-        delete headers;
-        headers = NULL;
-    }
+            delete headers;
+            headers = NULL;
+        }
+	} else {
+      ALOGW("retry to fetch master playlist");
+	}
 
-    ALOGI("onConnect <URL suppressed>");
+    if (!(mFlags & kFlagIncognito)) {
+        ALOGI("onConnect '%s'", url.c_str());
+    } else {
+        ALOGI("onConnect <URL suppressed>");
+    }
 
     mMasterURL = url;
 
@@ -178,9 +195,14 @@ void LiveSession::onConnect(const sp<AMessage> &msg) {
 
     if (playlist == NULL) {
         ALOGE("unable to fetch master playlist '%s'.", url.c_str());
-
-        mDataSource->queueEOS(ERROR_IO);
-        return;
+		mMainPlaylist = NULL;
+		m_retrying = true;
+		msg->setInt32("retry",1);
+		msg->post(3000000ll);
+		return;
+    } else {
+	    m_retrying = false;
+        mMainPlaylist = playlist;
     }
 
     if (playlist->isVariantPlaylist()) {
@@ -263,7 +285,7 @@ status_t LiveSession::fetchFile(
 
     sp<ABuffer> buffer = new ABuffer(size);
     buffer->setRange(0, 0);
-
+    ALOGW("read m3u8");
     for (;;) {
         size_t bufferRemaining = buffer->capacity() - buffer->size();
 
@@ -313,13 +335,12 @@ status_t LiveSession::fetchFile(
 }
 
 sp<M3UParser> LiveSession::fetchPlaylist(const char *url, bool *unchanged) {
-    ALOGV("fetchPlaylist '%s'", url);
-
     *unchanged = false;
 
     sp<ABuffer> buffer;
+    ALOGW("start fetchPlaylist");
     status_t err = fetchFile(url, &buffer);
-
+    ALOGW("end fetchPlaylist");
     if (err != OK) {
         return NULL;
     }
@@ -355,6 +376,12 @@ sp<M3UParser> LiveSession::fetchPlaylist(const char *url, bool *unchanged) {
 
     mRefreshState = INITIAL_MINIMUM_RELOAD_DELAY;
 #endif
+    String8 sUrl;
+    if (mHTTPDataSource != NULL && strstr(url,"56.com")){
+        sUrl = mHTTPDataSource->getUri();
+        url = sUrl.string() ? sUrl.string() : url;
+        ALOGW("playlist url %s",url);
+    }
 
     sp<M3UParser> playlist =
         new M3UParser(url, buffer->data(), buffer->size());
@@ -531,9 +558,41 @@ bool LiveSession::timeToRefreshPlaylist(int64_t nowUs) const {
     return mLastPlaylistFetchTimeUs + minPlaylistAgeUs <= nowUs;
 }
 
+
+#define TIMER_START {int64_t start_count;int64_t end_count; start_count = ALooper::GetNowUs();
+#define TIMER_END(x,y) end_count = ALooper::GetNowUs(); \
+	   ((void)ALOG(LOG_WARN, "ChromiumHTTPDataSourceSupport",#x"%d %lld",y,end_count -start_count));}
+
+void LiveSession::retry(int time)
+{
+    ALOGW("retry livesession %d",time);
+	postMonitorQueue(1000000);
+
+	if (time == 1) {
+		if (mSeekTimeUs >= 0) {
+		Mutex::Autolock autoLock(mLock);				
+		mSeekDone = true;
+		mCondition.broadcast();
+		}
+	}
+	if (time == 2) {
+		m_retrying = true;	
+        mLastPlaylistFetchTimeUs = -1;
+	}
+	
+	if (time == 3) {
+		m_retrying = true;	
+	}
+	 if(m_retrying)
+		mDataSource->reset();
+}
+
 void LiveSession::onDownloadNext() {
     size_t bandwidthIndex = getBandwidthIndex();
-
+    int repeated = 0;
+try_again:
+	repeated ++;	
+	ALOGV("onDownloadNext %d",repeated);
 rinse_repeat:
     int64_t nowUs = ALooper::GetNowUs();
 
@@ -547,6 +606,8 @@ rinse_repeat:
             url = mMasterURL;
         }
 
+        bool firstTime = (mPlaylist == NULL);
+
         if ((ssize_t)bandwidthIndex != mPrevBandwidthIndex) {
             // If we switch bandwidths, do not pay any heed to whether
             // playlists changed since the last time...
@@ -554,20 +615,29 @@ rinse_repeat:
         }
 
         bool unchanged;
-        sp<M3UParser> playlist = fetchPlaylist(url.c_str(), &unchanged);
+        sp<M3UParser> playlist;
+        if (firstTime && mBandwidthItems.size() == 0 && mMainPlaylist!=NULL) {
+			ALOGW("playlist use main playlist");
+			playlist = mMainPlaylist ;
+        } else {
+            TIMER_START;
+		    playlist = fetchPlaylist(url.c_str(), &unchanged);
+			TIMER_END(M3u_ReadCompletedHacker,0);
+		}
         if (playlist == NULL) {
             if (unchanged) {
                 // We succeeded in fetching the playlist, but it was
                 // unchanged from the last time we tried.
             } else {
                 ALOGE("failed to load playlist at url '%s'", url.c_str());
-                mDataSource->queueEOS(ERROR_IO);
+				retry(1);
                 return;
             }
         } else {
             mPlaylist = playlist;
         }
-
+        
+        //if (firstTime) {
         if (!mDurationFixed) {
             Mutex::Autolock autoLock(mLock);
 
@@ -583,15 +653,34 @@ rinse_repeat:
 
                     int64_t itemDurationUs;
                     CHECK(itemMeta->findInt64("durationUs", &itemDurationUs));
-
+					  
+						if (itemDurationUs > mMaxSegDuration) {
+							mMaxSegDuration = itemDurationUs;
+						}
                     mDurationUs += itemDurationUs;
                 }
-
                 mDurationFixed = mPlaylist->isComplete();
             }
         }
 
         mLastPlaylistFetchTimeUs = ALooper::GetNowUs();
+    }else {
+      if (!mPlaylist->isComplete() && !mPlaylist->isEvent()) {
+              mDurationUs = -1;
+      } else {
+		mDurationUs = 0;
+		for (size_t i = 0; i < mPlaylist->size(); ++i) {
+			sp<AMessage> itemMeta;
+			CHECK(mPlaylist->itemAt(i, NULL /* uri */, &itemMeta));
+
+			int64_t itemDurationUs;
+			CHECK(itemMeta->findInt64("durationUs", &itemDurationUs));
+			if (itemDurationUs > mMaxSegDuration) {
+				mMaxSegDuration = itemDurationUs;
+			}
+			mDurationUs += itemDurationUs;
+		}
+      }
     }
 
     int32_t firstSeqNumberInPlaylist;
@@ -605,7 +694,9 @@ rinse_repeat:
     bool bandwidthChanged = false;
 
     if (mSeekTimeUs >= 0) {
-        if (mPlaylist->isComplete() || mPlaylist->isEvent()) {
+        //if (mPlaylist->isComplete()) {
+        if (1) {
+        //if (mPlaylist->isComplete() || mPlaylist->isEvent()) {
             size_t index = 0;
             int64_t segmentStartUs = 0;
             while (index < mPlaylist->size()) {
@@ -617,17 +708,20 @@ rinse_repeat:
                 CHECK(itemMeta->findInt64("durationUs", &itemDurationUs));
 
                 if (mSeekTimeUs < segmentStartUs + itemDurationUs) {
+                	  mSeekedListTimeBase = segmentStartUs;
                     break;
                 }
 
                 segmentStartUs += itemDurationUs;
                 ++index;
             }
-
+            ALOGW("mSeekedListTimeBase based %lld in livesession",mSeekedListTimeBase);
+            m_retrying = true;
             if (index < mPlaylist->size()) {
                 int32_t newSeqNumber = firstSeqNumberInPlaylist + index;
 
-                if (newSeqNumber != mSeqNumber) {
+                //if (newSeqNumber != mSeqNumber) {
+                if (1) {
                     ALOGI("seeking to seq no %d", newSeqNumber);
 
                     mSeqNumber = newSeqNumber;
@@ -647,16 +741,19 @@ rinse_repeat:
         }
 
         mSeekTimeUs = -1;
+		seekDiscontinuity = true;
 
         Mutex::Autolock autoLock(mLock);
         mSeekDone = true;
+		seeking_count = 10;
         mCondition.broadcast();
     }
-
+    
     const int32_t lastSeqNumberInPlaylist =
         firstSeqNumberInPlaylist + (int32_t)mPlaylist->size() - 1;
 
     if (mSeqNumber < 0) {
+        //mSeqNumber = firstSeqNumberInPlaylist;
         if (mPlaylist->isComplete()) {
             mSeqNumber = firstSeqNumberInPlaylist;
         } else {
@@ -668,6 +765,9 @@ rinse_repeat:
         }
     }
 
+//    int32_t lastSeqNumberInPlaylist =
+//        firstSeqNumberInPlaylist + (int32_t)mPlaylist->size() - 1;
+
     if (mSeqNumber < firstSeqNumberInPlaylist
             || mSeqNumber > lastSeqNumberInPlaylist) {
         if (mPrevBandwidthIndex != (ssize_t)bandwidthIndex) {
@@ -729,29 +829,85 @@ rinse_repeat:
         range_offset = 0;
         range_length = -1;
     }
+    sp<ABuffer> buffer;
+	int first_buffer;
+    int offset;
+	first_buffer = 1;
+	offset = 0;
+redownload:	
+	 sp<DataSource> source;
+	 const char * url = uri.c_str();
+	 ALOGW("download files:%s",url);
+     TIMER_START;
+    if (!strncasecmp(url, "file://", 7)) {
+        source = new FileSource(url + 7);
+    } else if (strncasecmp(url, "http://", 7)
+            && strncasecmp(url, "https://", 8)) {
+        mDataSource->queueEOS(ERROR_UNSUPPORTED);
+        return;
+    } else {
+        {
+            Mutex::Autolock autoLock(mLock);
 
-    ALOGV("fetching segment %d from (%d .. %d)",
-          mSeqNumber, firstSeqNumberInPlaylist, lastSeqNumberInPlaylist);
+        if (mDisconnectPending) {
+        mDataSource->queueEOS(ERROR_IO);
+        return;
+            }
+        }
 
-    sp<ABuffer> buffer;
-    status_t err = fetchFile(uri.c_str(), &buffer, range_offset, range_length);
+        KeyedVector<String8, String8> headers = mExtraHeaders;
+        if (range_offset > 0 || range_length >= 0) {
+            headers.add(
+                    String8("Range"),
+                    String8(
+                        StringPrintf(
+                            "bytes=%lld-%s",
+                            range_offset,
+                            range_length < 0
+                                ? "" : StringPrintf("%lld", range_offset + range_length - 1).c_str()).c_str()));
+        }
+        status_t err = mHTTPDataSource->connect(url, &headers);
+
+        if (err != OK) {
+			ALOGW("httpdatasource connect error");
+			retry(2);
+			return;
+        }
+
+        source = mHTTPDataSource;
+    }
+	TIMER_END(OnResponse Successed,0);
+	while(1) {
+	status_t err;
+	TIMER_START;
+    err = fetchFile2(source,offset, &buffer);
+	TIMER_END(readMore,buffer!=NULL?buffer->size()/1000:0);
     if (err != OK) {
-        ALOGE("failed to fetch .ts segment at url '%s'", uri.c_str());
-        mDataSource->queueEOS(err);
-        return;
+        ALOGE("failed to fetch .ts segment at url '%s' offset %d ", uri.c_str(),offset);
+		retry(3);
+		return;
     }
-
+    if (buffer == NULL) {
+		ALOGV("down load file end in offset %d",offset/1024);
+		++mSeqNumber;
+		postMonitorQueue();		
+		return ;
+    }
+    ALOGV("wifi %d",buffer->size()/10000);
+	offset += buffer->size();
     CHECK(buffer != NULL);
-
     err = decryptBuffer(mSeqNumber - firstSeqNumberInPlaylist, buffer);
 
     if (err != OK) {
-        ALOGE("decryptBuffer failed w/ error %d", err);
+       ALOGE("decryptBuffer failed w/ error %d", err);
 
         mDataSource->queueEOS(err);
         return;
     }
 
+    if(first_buffer == 1) 
+    {
+    ALOGW("check for first_buffer");
     if (buffer->size() == 0 || buffer->data()[0] != 0x47) {
         // Not a transport stream???
 
@@ -783,23 +939,27 @@ rinse_repeat:
         // playback.
         bandwidthChanged = false;
     }
-
+    
     if (mStartOfPlayback) {
         seekDiscontinuity = true;
         mStartOfPlayback = false;
     }
 
-    if (seekDiscontinuity || explicitDiscontinuity || bandwidthChanged) {
+    if (seekDiscontinuity || explicitDiscontinuity || bandwidthChanged || m_retrying) {
         // Signal discontinuity.
 
-        ALOGI("queueing discontinuity (seek=%d, explicit=%d, bandwidthChanged=%d)",
-             seekDiscontinuity, explicitDiscontinuity, bandwidthChanged);
+        ALOGI("queueing discontinuity (seek=%d, explicit=%d, bandwidthChanged=%d retry=%d)",
+             seekDiscontinuity, explicitDiscontinuity, bandwidthChanged,m_retrying);
+
 
         sp<ABuffer> tmp = new ABuffer(188);
         memset(tmp->data(), 0, tmp->size());
 
         // signal a 'hard' discontinuity for explicit or bandwidthChanged.
-        uint8_t type = (explicitDiscontinuity || bandwidthChanged) ? 1 : 0;
+        //tmp->data()[1] = (explicitDiscontinuity || bandwidthChanged || m_retrying) ? 1 : 0;
+        
+        //uint8_t type = (explicitDiscontinuity || bandwidthChanged) ? 1 : 0;
+        uint8_t type = (explicitDiscontinuity || bandwidthChanged || m_retrying) ? 1 : 0;
 
         if (mPlaylist->isComplete() || mPlaylist->isEvent()) {
             // If this was a live event this made no sense since
@@ -814,19 +974,77 @@ rinse_repeat:
         tmp->data()[1] = type;
 
         mDataSource->queueBuffer(tmp);
+		m_retrying = false;
+    }	
+    mPrevBandwidthIndex = bandwidthIndex; 
+	first_buffer = 0;
     }
-
     mDataSource->queueBuffer(buffer);
+	}
+}
 
-    mPrevBandwidthIndex = bandwidthIndex;
-    ++mSeqNumber;
 
-    postMonitorQueue();
+status_t LiveSession::fetchFile2(sp<DataSource> source, int offset, sp<ABuffer> *out) {
+    *out = NULL;
+
+    off64_t size;
+    status_t err = source->getSize(&size);
+    if (err == OK && offset == size){
+	   return OK;
+	}
+
+    if ((mSeekDone == false) && (offset != 0) && (offset % 188 == 0)){
+		
+		ALOGW("mSeekDone");
+	   return OK;
+	}	
+    if(seeking_count > 6){
+		size = 128 * 1024;
+		seeking_count --;
+	} else if (seeking_count > 2) {
+		size = 256 * 1024;
+		seeking_count--;
+	} else {
+ 	    size = 512*1024;
+	}
+
+    if(mSeekDone == false)
+		size = 1880;	
+
+
+    sp<ABuffer> buffer = new ABuffer(size);
+    buffer->setRange(0, 0);
+
+    if (1) {
+        size_t bufferRemaining = buffer->capacity() - buffer->size();
+
+        ssize_t n = source->readAt(
+                buffer->size() + offset, buffer->data() + buffer->size(),
+                bufferRemaining);
+        if (n < 0) {			
+            return n;
+        } 
+        if (n ==  0) {
+            return OK;
+        }
+
+		if ((mSeekDone == false) && (n > 188)){
+		    buffer->setRange(0, (n + offset) /188 * 188 - offset);
+			
+	     } else {
+          buffer->setRange(0, buffer->size() + (size_t)n);
+	  	}
+      }
+
+    *out = buffer;
+
+    return OK;
 }
 
 void LiveSession::onMonitorQueue() {
     if (mSeekTimeUs >= 0
             || mDataSource->countQueuedBuffers() < kMaxNumQueuedFragments) {
+         ALOGW("onDownloadNext");
         onDownloadNext();
     } else {
         postMonitorQueue(1000000ll);
@@ -977,6 +1195,8 @@ void LiveSession::postMonitorQueue(int64_t delayUs) {
     sp<AMessage> msg = new AMessage(kWhatMonitorQueue, id());
     msg->setInt32("generation", ++mMonitorQueueGeneration);
     msg->post(delayUs);
+    //ALOGW("postMonitorQueue %lld",delayUs);
+
 }
 
 void LiveSession::onSeek(const sp<AMessage> &msg) {
@@ -994,6 +1214,19 @@ status_t LiveSession::getDuration(int64_t *durationUs) const {
     return OK;
 }
 
+status_t LiveSession::getSeekedListTimeBase(int64_t *seekedListTimeBase) {
+    Mutex::Autolock autoLock(mLock);
+    *seekedListTimeBase = mSeekedListTimeBase;
+    return OK;
+}
+
+status_t LiveSession::getMaxSegDuration(int64_t *maxSegDuration) {
+    Mutex::Autolock autoLock(mLock);
+    *maxSegDuration = mMaxSegDuration;
+    return OK;
+}
+
+
 bool LiveSession::isSeekable() const {
     int64_t durationUs;
     return getDuration(&durationUs) == OK && durationUs >= 0;
diff --git a/media/libstagefright/httplive/M3UParser.cpp b/media/libstagefright/httplive/M3UParser.cpp
index 44e03dc..3645b84 100644
--- a/media/libstagefright/httplive/M3UParser.cpp
+++ b/media/libstagefright/httplive/M3UParser.cpp
@@ -163,9 +163,6 @@ status_t M3UParser::parse(const void *_data, size_t size) {
         while (offsetLF < size && data[offsetLF] != '\n') {
             ++offsetLF;
         }
-        if (offsetLF >= size) {
-            break;
-        }
 
         AString line;
         if (offsetLF > offset && data[offsetLF - 1] == '\r') {
@@ -320,7 +317,7 @@ status_t M3UParser::parseMetaDataDuration(
     if (meta->get() == NULL) {
         *meta = new AMessage;
     }
-    (*meta)->setInt64(key, (int64_t)x * 1E6);
+    (*meta)->setInt64(key, (int64_t)(x * 1E6));
 
     return OK;
 }
diff --git a/media/libstagefright/include/ActAudioDecoder.h b/media/libstagefright/include/ActAudioDecoder.h
new file mode 100755
index 0000000..aa756aa
--- /dev/null
+++ b/media/libstagefright/include/ActAudioDecoder.h
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AMP_DECODER_H_
+
+#define AMP_DECODER_H_
+
+#include <media/stagefright/MediaSource.h>
+#include "audio_decoder_lib_dev.h"
+#include "ActAudioDownMix.h"
+
+typedef int8_t int8;
+typedef uint8_t uint8;
+typedef int16_t int16;
+typedef uint16_t uint16;
+typedef int32_t int32;
+typedef uint32_t uint32;
+typedef int64_t int64;
+typedef uint64_t uint64;
+typedef int32_t Int32;
+
+typedef struct
+#ifdef __cplusplus
+tActAudioDecoderExternal
+#endif
+{
+	/*
+	 * INPUT:
+	 * Pointer to the input buffer that contains the encoded bistream data.
+	 * The data is filled in such that the first bit transmitted is
+	 * the most-significant bit (MSB) of the first array element.
+	 * The buffer is accessed in a linear fashion for speed, and the number of
+	 * bytes consumed varies frame to frame.
+	 * The calling environment can change what is pointed to between calls to
+	 * the decode function, library, as long as the inputBufferCurrentLength,
+	 * and inputBufferUsedLength are updated too. Also, any remaining bits in
+	 * the old buffer must be put at the beginning of the new buffer.
+	 */
+	uint8 *pInputBuffer;
+
+	/*
+	 * INPUT:
+	 * Number of valid bytes in the input buffer, set by the calling
+	 * function. After decoding the bitstream the library checks to
+	 * see if it when past this value; it would be to prohibitive to
+	 * check after every read operation.
+	 */
+	int32 inputBufferCurrentLength;
+
+	/*
+	 * INPUT/OUTPUT:
+	 * Number of elements used by the library, initially set to zero by
+	 * the functionresetDecoder(), and modified by each
+	 * call to framedecoder().
+	 */
+	int32 inputBufferUsedLength;
+
+	/*
+	 * OUTPUT:
+	 * The number of channels decoded from the bitstream.
+	 */
+	int16 num_channels;
+
+	/*
+	 * OUTPUT:
+	 * The number of channels decoded from the bitstream.
+	 */
+	int16 version;
+
+	/*
+	 * OUTPUT:
+	 * The sampling rate decoded from the bitstream, in units of
+	 * samples/second.
+	 */
+	int32 samplingRate;
+
+	/*
+	 * OUTPUT:
+	 * This value is the bitrate in units of bits/second. IT
+	 * is calculated using the number of bits consumed for the current frame,
+	 * and then multiplying by the sampling_rate, divided by points in a frame.
+	 * This value can changes frame to frame.
+	 */
+	int32 bitRate;
+
+	/*
+	 * INPUT/OUTPUT:
+	 * In: Inform decoder how much more room is available in the output buffer in int16 samples
+	 * Out: Size of the output frame in 16-bit words, This value depends on the mp3 version
+	 */
+	int32 outputFrameSize;
+
+	/*
+	 * INPUT:
+	 * Flag to enable/disable crc error checking
+	 */
+	int32 crcEnabled;
+
+	/*
+	 * OUTPUT:
+	 * This value is used to accumulate bit processed and compute an estimate of the
+	 * bitrate. For debugging purposes only, as it will overflow for very long clips
+	 */
+	uint32 totalNumberOfBitsUsed;
+
+	/*
+	 * INPUT: (but what is pointed to is an output)
+	 * Pointer to the output buffer to hold the 16-bit PCM audio samples.
+	 * If the output is stereo, both left and right channels will be stored
+	 * in this one buffer.
+	 */
+
+	int16 *pOutputBuffer;
+	int32 total_time;
+	int32_t fadeFlag;
+    int32_t fadeStep;
+    int32_t fadeNum;
+    int32_t fadeCur;
+    int32_t videoflag;
+    int32_t muteNum;
+} tActAudioDecoderExternal;    
+
+namespace android {
+
+struct MediaBufferGroup;
+
+struct ActAudioDecoder: public MediaSource {
+	ActAudioDecoder(const sp<MediaSource> &source);
+
+	virtual status_t start(MetaData *params);
+	virtual status_t stop();
+
+	virtual sp<MetaData> getFormat();
+
+	virtual status_t read(MediaBuffer **buffer, const ReadOptions *options);
+
+protected:
+	virtual ~ActAudioDecoder();
+
+private:
+	sp<MediaSource> mSource;
+	sp<MetaData> mMeta;
+
+	void *mLib_handle;
+	audiodec_plugin_t *mPlugin_info; /* 解码插件信息 */
+	void *mPlugin_handle;
+
+	downmix_state* mDownMix;
+	bool mStarted;
+
+	MediaBufferGroup *mBufferGroup;
+	tActAudioDecoderExternal *mConfig;
+	int64_t mAnchorTimeUs;
+	int64_t mNumFramesOutput;
+    int64_t mNumOffsetOutput;
+    
+	MediaBuffer *mInputBuffer;
+
+	void init();
+
+	ActAudioDecoder(const ActAudioDecoder &);
+	ActAudioDecoder &operator=(const ActAudioDecoder &);
+};
+
+} // namespace android
+
+
+#endif  // AMP_DECODER_H_
diff --git a/media/libstagefright/include/ActAudioDownMix.h b/media/libstagefright/include/ActAudioDownMix.h
new file mode 100755
index 0000000..cdf86af
--- /dev/null
+++ b/media/libstagefright/include/ActAudioDownMix.h
@@ -0,0 +1,138 @@
+/*	File: ActAudioDownmix.h		$Revision:   1.0 $	*/
+
+/****************************************************************************
+ ;	File:	downmix_cz.h
+ ;	by chenzhan
+ ;
+ ;	History:
+ ;		2009/03/20		Created
+ ;***************************************************************************/
+#ifndef ACTAUDIODOWNMIX_H
+#define ACTAUDIODOWNMIX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "actal_posix_dev.h"
+
+#define DOWNMIX_BIT32
+//#define DOWNMIX_BIT24
+//#define DOWNMIX_BIT16
+
+//#define  DOWNMIX_GNRNG
+
+
+#define 	DOWNMIX_NACMOD			9			/* # audio coding modes */
+/**** General system equates ****/
+#define		DOWNMIX_NCHANS			6			/* max # channels */
+//#define		DOWNMIX_NFCHANS			5			/* max # full bw channels */
+#define		DOWNMIX_NPCMCHANS		6			/* max # output channels */
+
+/**** Filter bank equates ****/
+#define		DOWNMIX_N				2048			/* block size */
+
+/**** DSP type definitions ****/
+typedef short downmix_int16; /* DSP integer */
+typedef unsigned short downmix_uint16; /* DSP unsigned integer */
+
+#ifdef DOWNMIX_BIT16
+#define   DOWNMIX_BitNum_word     16
+#define 	DOWNMIX_UNITY			0x7fff
+#define 	DOWNMIX_M3DB			23170
+#define 	DOWNMIX_M6DB			16384
+
+typedef short downmix_int32; /* DSP fixed-point fractional */
+typedef int downmix_int64;
+
+#endif
+
+#ifdef DOWNMIX_BIT24
+#define   DOWNMIX_BitNum_word     24
+#define 	DOWNMIX_UNITY			0x7fffff
+#define 	DOWNMIX_M3DB			5931642
+#define 	DOWNMIX_M6DB			4194304
+
+typedef int downmix_int32; /* DSP fixed-point fractional */
+typedef __int64 downmix_int64;
+
+#endif
+
+#ifdef DOWNMIX_BIT32
+#define   DOWNMIX_BitNum_word     32
+#define 	DOWNMIX_UNITY			0x7fffffff
+#define 	DOWNMIX_M3DB			1518500352
+#define 	DOWNMIX_M6DB			1073741824
+
+typedef int downmix_int32; /* DSP fixed-point fractional */
+#ifdef _WIN32
+typedef __int64 downmix_int64;
+#else
+typedef long long downmix_int64;
+#endif
+
+#endif
+
+/**** Enumerations ****/
+enum {
+	DOWNMIX_MODE11,
+	DOWNMIX_MODE10,
+	DOWNMIX_MODE20,
+	DOWNMIX_MODE30, /* audio coding mode */
+	DOWNMIX_MODE21,
+	DOWNMIX_MODE31,
+	DOWNMIX_MODE22,
+	DOWNMIX_MODE32,
+	DOWNMIX_MODE32ACT
+};
+enum {
+	DOWNMIX_DUAL_STEREO, DOWNMIX_DUAL_LEFTMONO, /* dual mono downmix mode */
+	DOWNMIX_DUAL_RGHTMONO, DOWNMIX_DUAL_MIXMONO
+};
+
+/****  channel ordering equates ****/
+#define	DOWNMIX_LEFT				0		/* DOWNMIX_LEFT channel */
+#define	DOWNMIX_CNTR				1		/* center channel */
+#define	DOWNMIX_RGHT				2		/* right channel */
+#define	DOWNMIX_LSUR				3		/* DOWNMIX_LEFT surround channel */
+#define	DOWNMIX_RSUR				4		/* right surround channel */
+#define	DOWNMIX_LFE					5		/* low frequency effects channel */
+#define	DOWNMIX_MSUR				3		/* mono surround channel */
+#define	DOWNMIX_NONE				-1		/* channel not in use */
+
+#define DOWNMIX_MYLIMIT(a,b) (downmix_int32)((((downmix_int64)(a) + (downmix_int64)(b))>DOWNMIX_UNITY)?DOWNMIX_UNITY:((((downmix_int64)(a) + (downmix_int64)(b))<(-DOWNMIX_UNITY-1))?(-DOWNMIX_UNITY-1):((downmix_int64)(a) + (downmix_int64)(b))))
+#define downmix_abs(a)		(((a)>=0)?(a):(-(a)))	/* absolute value */
+
+#define downmix_malloc     actal_malloc
+#define downmix_memset     actal_memset
+#define downmix_free(p)    { if(p) { actal_free((p)); (p)=NULL; } }
+
+typedef struct {
+	downmix_int16 acmod; //输入编码模式0-8
+	downmix_int16 outmod; //输出PCM模式0-8
+
+	downmix_int16 cmixlev; //center声道系数level
+	downmix_int16 surmixlev; //环绕声道系数level
+	downmix_int16 lfeon; //输入是否有低音声道
+	downmix_int16 outlfe; //输出是否有低音声道
+	downmix_int16 dualmod; //双声道输出模式 	dual mono downmix mode  4种模式
+
+	downmix_int32 *downmix_buf[DOWNMIX_NCHANS]; //运行domix后存放的数据buf,所有声道完后需要搬走
+
+} downmix_state;
+
+downmix_state *downmix_open(void);
+
+downmix_int32 downmix_set(downmix_state *dommix_str,
+		downmix_int32 *downmix_buf_left, downmix_int32 *downmix_buf_right);
+
+downmix_int32 downmix_run(downmix_state *dommix_str, downmix_int32 *tcbuf,
+		downmix_int32 frame_len, downmix_int32 channum);
+
+downmix_int32 downmix_close(downmix_state *dommix_str);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/media/libstagefright/include/ActAudioEncoder.h b/media/libstagefright/include/ActAudioEncoder.h
new file mode 100755
index 0000000..ff625c1
--- /dev/null
+++ b/media/libstagefright/include/ActAudioEncoder.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ACTAUDIO_ENCODER_H
+#define ACTAUDIO_ENCODER_H
+
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+
+#include "audio_encoder_lib_dev.h"
+
+namespace android {
+
+struct MediaBufferGroup;
+
+class ActAudioEncoder: public MediaSource {
+public:
+	ActAudioEncoder(const sp<MediaSource> &source, const sp<MetaData> &meta);
+
+	virtual status_t start(MetaData *params);
+	virtual status_t stop();
+	virtual sp<MetaData> getFormat();
+	virtual status_t read(MediaBuffer **buffer, const ReadOptions *options);
+
+protected:
+	virtual ~ActAudioEncoder();
+
+private:
+	sp<MediaSource> mSource;
+	sp<MetaData> mMeta;
+	bool mStarted;
+	MediaBufferGroup *mBufferGroup;
+	MediaBuffer *mInputBuffer;
+	status_t mInitCheck;
+	int32_t mSampleRate;
+	int32_t mChannels;
+	int32_t mBitRate;
+	int32_t mFrameCount;
+	int64_t mAnchorTimeUs;
+	int32_t mNumInputSamples;
+
+	int32_t mNumSamplesPerFrame;
+
+	audioin_pcm_t mInput;
+	void * mLib_handle;
+	audioenc_plugin_t *mPlugin_info; /* 解码插件信息 */
+	void *mPlugin_handle; /* 解码库open函数返回的操作指针 */
+
+	status_t initCheck();
+
+	ActAudioEncoder& operator=(const ActAudioEncoder &rhs);
+	ActAudioEncoder(const ActAudioEncoder& copy);
+
+};
+
+}
+
+#endif  //#ifndef ACTAUDIO_ENCODER_H
diff --git a/media/libstagefright/include/ActAudioExtractor.h b/media/libstagefright/include/ActAudioExtractor.h
new file mode 100755
index 0000000..f953c8e
--- /dev/null
+++ b/media/libstagefright/include/ActAudioExtractor.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ActAudio_EXTRACTOR_H_
+#define ActAudio_EXTRACTOR_H_
+
+#include <media/stagefright/MediaExtractor.h>
+#include "actal_posix_dev.h"
+#include "format_dev.h"
+#include "id3parse.h"
+#include "ActDataSource.h"
+#include "music_parser_lib_dev.h"
+
+namespace android {
+
+struct AMessage;
+class String8;
+
+class ActAudioExtractor : public MediaExtractor {
+public:
+    ActAudioExtractor(const sp<DataSource>& source, const char *mime);
+
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+protected:
+    virtual ~ActAudioExtractor();
+
+private:
+    friend class ActAudioSource;
+
+    sp<DataSource> mDataSource;
+    sp<MetaData> mMeta;
+    status_t mInitCheck;
+    size_t mFrameSize;
+
+    void * mLib_handle;
+    void * mPlugin_handle;
+    storage_io_t  *mInput;
+    music_parser_plugin_t *mPlugin_info; /* 解码插件信息 */
+	music_info_t m_ai;
+
+    ActAudioExtractor(const ActAudioExtractor &);
+    ActAudioExtractor &operator=(const ActAudioExtractor &);
+};
+
+//bool SniffActAudio(
+//        const sp<DataSource> &source, String8 *mimeType, float *confidence,
+//        sp<AMessage> *);
+}  // namespace android
+
+#endif  // AMR_EXTRACTOR_H_
diff --git a/media/libstagefright/include/ActVideoExtractor.h b/media/libstagefright/include/ActVideoExtractor.h
new file mode 100755
index 0000000..7db244d
--- /dev/null
+++ b/media/libstagefright/include/ActVideoExtractor.h
@@ -0,0 +1,224 @@
+/*
+ * Nothing here 2...
+ */
+
+#ifndef ACTVIDEO_EXTRACTOR_H_
+
+#define ACTVIDEO_EXTRACTOR_H_
+
+#include <media/stagefright/MediaExtractor.h>
+#include <utils/Vector.h>
+#include <utils/List.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <actal_posix_dev.h>
+#include <ALdec_plugin.h>
+#define TURN_ON_ADD_VIDEO_DECODE_FLAG		1 // Mainly include vp6/vp8/rvg2
+#define TURN_ON_STREAM_BUFFER_MANAGE_FLAG	0 // can print stream_buffer manage log
+namespace android {
+
+//struct AMessage;
+//class String8;
+
+//struct ActVideoSource;
+//
+//typedef packet_header_t _key;
+//
+//List<short> m_strfifo; /* stream fifo */
+
+enum EVENT_T {
+	EXTRACTOR_SUBMIT_SUB_BUF = 0,
+};
+
+typedef struct {
+	size_t a;
+	size_t v;
+	size_t s;
+} track_index_t;
+
+typedef struct {
+    size_t a;
+    size_t v;
+    size_t s;
+} packet_max_size_t;
+
+typedef struct {
+	uint8_t* a;
+	uint8_t* b;
+} region_t;
+
+typedef struct {
+	uint8_t* start;
+	uint8_t* start_phyaddr;
+  	size_t size;
+ 	size_t real_size;
+	region_t empty;
+} stream_buf_t;
+
+typedef enum {
+	CODEC_CODA,
+	CODEC_ACTIONS,
+	CODEC_SOFTWARE,
+	CODEC_UNKNOWN
+} CODEC_TYPE;
+
+typedef struct ExtToMime {
+	const char *ext;
+	const char *mime;
+	CODEC_TYPE ct;
+} ExtToMime_t;
+
+typedef struct aExtToMime{
+	const char * ext;
+	const char * mime;
+	uint32_t len;
+}aExtToMime_t;
+
+#define MMM_SUBTITLE_NUM 30
+#define MMM_SUBTITLE_DATA_LEN 15360
+
+struct ActVideoExtractor : public MediaExtractor {
+	ActVideoExtractor(const sp<DataSource> &source, const char* mime, void* cookie = NULL);
+
+	virtual size_t countTracks();
+
+	virtual sp<MediaSource> getTrack(size_t index);
+
+	virtual sp<MetaData> getTrackMetaData(
+	        size_t index, uint32_t flags);
+
+	virtual sp<MetaData> getMetaData();
+	virtual status_t setAudioTrack(int index, int64_t cur_playing_time);
+	virtual const char* setSubTrack(int index, int64_t cur_playing_time);
+
+	#ifdef MMM_ENABLE_SUBTITLE  
+	   virtual int64_t getsubtitle();
+	   virtual int putsubtitle();
+		virtual int waitsubtitle();
+		virtual int dropsubtitle();
+	#endif
+
+    virtual uint32_t flags() const;
+
+protected:
+    virtual ~ActVideoExtractor();
+
+	private:
+	friend struct ActVideoSource;
+
+	struct TrackInfo {
+	    unsigned long mTrackNum;
+	    sp<MetaData> mMeta;
+	};
+	Vector<TrackInfo> mTracks;
+
+	ActVideoExtractor(const ActVideoExtractor &);
+	ActVideoExtractor &operator=(const ActVideoExtractor &);
+
+	/* demuxer handle, demuxer function */
+	void* m_dh;
+	demux_plugin_t *m_dp;
+	media_info_t m_mi;
+	void* mLib_handle;
+
+	/* main functions */
+	bool test();
+	bool input_mi_init();
+	bool open_plugin(const char *ext);
+	void addTracks();
+    status_t getPacket(av_buf_t* av_buf, packet_type_t t);
+    bool seekable();
+	status_t seek(int64_t seekTimeUs);
+    uint32_t getFirstAudioTime();
+	packet_type_t matchPacketType(size_t track_idx);
+
+	/* stream input */
+	stream_input_t *m_input;
+	char m_ext[24];
+	bool m_exist_location;
+
+
+	/* now playing track index */
+	track_index_t m_ti_playing;
+
+    /* for seek */
+    time_stuct_t m_ts;
+    /* Normally, demuxer's packet size should NOT excced this size */
+    packet_max_size_t m_pkt_maxs;
+	/* stream buffer assosiated */
+	stream_buf_t m_ap;
+	stream_buf_t m_vp;
+	bool mIsSetTrack;
+	//stream_buf_t m_sp;g
+	bool stream_buf_destroy();
+    void stream_buf_reset();
+    bool stream_buf_init();
+    bool stream_buf_prepare(av_buf_t* ao_buf, av_buf_t* vo_buf);
+    bool stream_buf_empty_area_update(av_buf_t *av_buf, bool enlarge);
+    bool stream_buf_assign(packet_type_t type, av_buf_t* av_buf);
+    bool stream_buf_check_overflow(av_buf_t *av_buf);
+    void stream_buf_status_dump(stream_buf_t* t);
+    void stream_buf_quelst(packet_type_t type);
+    mutable Mutex mLock;
+    Mutex mMiscStateLock;
+
+	/* stream fifo assosiated */
+	List<av_buf_t> mQueue;
+	stream_buf_t m_vp_spare;
+	stream_buf_t m_ap_spare;
+	bool mUsingSpare;
+	bool mVpUsingSpare;
+	bool mApUsingSpare;
+	uint8_t *mVpSpareData;
+	uint8_t *mApSpareData;
+
+	av_buf_t m_ao_buf;
+	av_buf_t m_vo_buf;
+    void avbufItemAdd(av_buf_t* av_buf);
+    bool avbufItemPick(packet_type_t t, av_buf_t* av_buf);
+    bool avbufItemCheck();
+
+	/* notify event to Owner */
+	void* m_cookie;
+	status_t notifyEvent(EVENT_T msg, int ext1, int ext2);
+
+	/* demuxer plugin status */
+	plugin_err_no_t m_pstatus;
+	bool m_fstatus;
+	int32_t mCounter;
+
+	uint32_t mExtractorFlags;
+	const ExtToMime_t *mEtm;
+	const aExtToMime_t *mAEtm;
+	/* when video seek failed, set this flag == 1, and audio seek won't work. */
+	int mSeekFailed;
+	int mAlwaysDropAudio;
+	int mVideoAlreadySeek;
+
+	#ifdef MMM_ENABLE_SUBTITLE  
+	unsigned char subtitle_data[MMM_SUBTITLE_NUM][MMM_SUBTITLE_DATA_LEN];	
+	int subtitle_buf_No_0;
+	int subtitle_buf_No_1;
+	int subtitle_get_flag;
+	int pkt_prv_ts;
+	packet_header_t *packet_header_tmp;
+	packet_header_t *packet_header_org;
+	int addr_oft;	
+	int reserved_count;
+	int put_subtitle_packet_flag;
+	int need_subtitle;
+	#endif
+	int64_t mADuration;
+	int64_t mVDuration;
+	int64_t mVLastPktTime;
+	int64_t mALastPktTime;
+
+	bool mNotPlayVideo;
+	bool mNotPlayAudio;
+	uint32_t mUnsupportAudioTrackNum;
+	bool mUsingPhyContBuffer;
+
+};
+
+}  // namespace android
+
+#endif  // ACTVIDEO_EXTRACTOR_H_
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index b77cc86..8ad0e63 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -98,6 +98,7 @@ struct AwesomePlayer {
 
     // This is a mask of MediaExtractor::Flags.
     uint32_t flags() const;
+	  bool getStreamingFlag();
 
     void postAudioEOS(int64_t delayUs = 0ll);
     void postAudioSeekComplete();
@@ -160,6 +161,7 @@ private:
     TimeSource *mTimeSource;
 
     String8 mUri;
+		String8 mNewUri;//SH
     KeyedVector<String8, String8> mUriHeaders;
 
     sp<DataSource> mFileSource;
@@ -184,8 +186,10 @@ private:
     uint32_t mExtractorFlags;
     uint32_t mSinceLastDropped;
 
+    int64_t mLastSetAudioTrackTimeUs;
     int64_t mTimeSourceDeltaUs;
     int64_t mVideoTimeUs;
+	int32_t mIsStreamingFlag;//SH
 
     enum SeekType {
         NO_SEEK,
@@ -221,6 +225,7 @@ private:
     bool mIsAsyncPrepare;
     status_t mPrepareResult;
     status_t mStreamDoneStatus;
+	bool mUsingMidwareAudioDecFlag;//SH
 
     void postVideoEvent_l(int64_t delayUs = -1);
     void postBufferingEvent_l();
diff --git a/media/libstagefright/include/ChromiumHTTPDataSource.h b/media/libstagefright/include/ChromiumHTTPDataSource.h
index 82e08fd..460020e 100644
--- a/media/libstagefright/include/ChromiumHTTPDataSource.h
+++ b/media/libstagefright/include/ChromiumHTTPDataSource.h
@@ -49,6 +49,8 @@ struct ChromiumHTTPDataSource : public HTTPBase {
 
     virtual String8 getUri();
 
+	virtual void setUri(AString url) ;
+
     virtual String8 getMIMEType() const;
 
     virtual status_t reconnectAtOffset(off64_t offset);
diff --git a/media/libstagefright/include/LiveSession.h b/media/libstagefright/include/LiveSession.h
index f329cc9..7ba49ad 100644
--- a/media/libstagefright/include/LiveSession.h
+++ b/media/libstagefright/include/LiveSession.h
@@ -44,15 +44,16 @@ struct LiveSession : public AHandler {
             const KeyedVector<String8, String8> *headers = NULL);
 
     void disconnect();
-
+    void retry(int);
     // Blocks until seek is complete.
     void seekTo(int64_t timeUs);
 
     status_t getDuration(int64_t *durationUs) const;
-
+	status_t getSeekedListTimeBase(int64_t *seekedListTimeBase);
+	status_t getMaxSegDuration(int64_t *maxSegDuration);
     bool isSeekable() const;
     bool hasDynamicDuration() const;
-
+   void flushSourceQueueBuffers();
 protected:
     virtual ~LiveSession();
 
@@ -60,7 +61,7 @@ protected:
 
 private:
     enum {
-        kMaxNumQueuedFragments = 3,
+        kMaxNumQueuedFragments = 16, //old: 3 new: 16
         kMaxNumRetries         = 5,
     };
 
@@ -94,6 +95,7 @@ private:
     ssize_t mPrevBandwidthIndex;
     int64_t mLastPlaylistFetchTimeUs;
     sp<M3UParser> mPlaylist;
+    sp<M3UParser> mMainPlaylist;
     int32_t mSeqNumber;
     int64_t mSeekTimeUs;
     int32_t mNumRetries;
@@ -105,9 +107,12 @@ private:
     bool mDurationFixed;  // Duration has been determined once and for all.
     bool mSeekDone;
     bool mDisconnectPending;
+    bool m_retrying;
+    int32_t seeking_count;
 
     int32_t mMonitorQueueGeneration;
-
+	int64_t mSeekedListTimeBase;
+	int64_t mMaxSegDuration;
     enum RefreshState {
         INITIAL_MINIMUM_RELOAD_DELAY,
         FIRST_UNCHANGED_RELOAD_ATTEMPT,
@@ -127,8 +132,9 @@ private:
     status_t fetchFile(
             const char *url, sp<ABuffer> *out,
             int64_t range_offset = 0, int64_t range_length = -1);
-
+	status_t fetchFile2(sp<DataSource> source, int offset, sp<ABuffer> *out);
     sp<M3UParser> fetchPlaylist(const char *url, bool *unchanged);
+
     size_t getBandwidthIndex();
 
     status_t decryptBuffer(
diff --git a/media/libstagefright/include/avc_utils.h b/media/libstagefright/include/avc_utils.h
index d385bc1..bf9a586 100644
--- a/media/libstagefright/include/avc_utils.h
+++ b/media/libstagefright/include/avc_utils.h
@@ -58,6 +58,9 @@ sp<MetaData> MakeAACCodecSpecificData(
         unsigned profile, unsigned sampling_freq_index,
         unsigned channel_configuration);
 
+sp<MetaData> MakeAACCodecSpecificData_1(void *init_buf,
+        unsigned profile, unsigned sampling_freq_index,
+        unsigned channel_configuration);
 // Given an MPEG4 video VOL-header chunk (starting with 0x00 0x00 0x01 0x2?)
 // parse it and fill in dimensions, returns true iff successful.
 bool ExtractDimensionsFromVOLHeader(
diff --git a/media/libstagefright/mp4/FragmentedMP4Parser.cpp b/media/libstagefright/mp4/FragmentedMP4Parser.cpp
index 7fe4e63..451c837 100644
--- a/media/libstagefright/mp4/FragmentedMP4Parser.cpp
+++ b/media/libstagefright/mp4/FragmentedMP4Parser.cpp
@@ -132,6 +132,10 @@ struct FileSource : public FragmentedMP4Parser::Source {
             CHECK(mFile != NULL);
         }
 
+    virtual ~FileSource() {
+        fclose(mFile);
+    }
+
     virtual ssize_t readAt(off64_t offset, void *data, size_t size) {
         fseek(mFile, offset, SEEK_SET);
         return fread(data, 1, size, mFile);
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 4f6c4b2..660a507 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -438,9 +438,12 @@ int64_t ATSParser::Program::convertPTSToTimestamp(uint64_t PTS) {
         if (!mFirstPTSValid) {
             mFirstPTSValid = true;
             mFirstPTS = PTS;
-            PTS = 0;
+            PTS = 0;            
+            ALOGD("--0mFirstPTS %lld",mFirstPTS);
         } else if (PTS < mFirstPTS) {
+            mFirstPTS = PTS;
             PTS = 0;
+            ALOGD("--1mFirstPTS %lld",mFirstPTS);
         } else {
             PTS -= mFirstPTS;
         }
@@ -526,6 +529,7 @@ status_t ATSParser::Stream::parse(
         return OK;
     }
 
+#if 0
     if (mExpectedContinuityCounter >= 0
             && (unsigned)mExpectedContinuityCounter != continuity_counter) {
         ALOGI("discontinuity on stream pid 0x%04x", mElementaryPID);
@@ -538,6 +542,7 @@ status_t ATSParser::Stream::parse(
     }
 
     mExpectedContinuityCounter = (continuity_counter + 1) & 0x0f;
+#endif
 
     if (payload_unit_start_indicator) {
         if (mPayloadStarted) {
@@ -856,7 +861,14 @@ void ATSParser::Stream::onPayloadData(
 
     int64_t timeUs = 0ll;  // no presentation timestamp available.
     if (PTS_DTS_flags == 2 || PTS_DTS_flags == 3) {
-        timeUs = mProgram->convertPTSToTimestamp(PTS);
+    	if(mStreamType == STREAMTYPE_H264 && DTS != 0)
+    	{
+	    	timeUs = mProgram->convertPTSToTimestamp(DTS);
+	    }
+    	else
+    	{
+	        timeUs = mProgram->convertPTSToTimestamp(PTS);
+	    }
     }
 
     status_t err = mQueue->appendData(data, size, timeUs);
diff --git a/media/libstagefright/mpeg2ts/Android.mk b/media/libstagefright/mpeg2ts/Android.mk
index c1a7a9d..ead91eb 100644
--- a/media/libstagefright/mpeg2ts/Android.mk
+++ b/media/libstagefright/mpeg2ts/Android.mk
@@ -10,6 +10,8 @@ LOCAL_SRC_FILES:=                 \
         MPEG2TSExtractor.cpp      \
 
 LOCAL_C_INCLUDES:= \
+        $(TOP)/frameworks/av/include/alsp/inc \
+        $(TOP)/system/core/include/ion \
 	$(TOP)/frameworks/av/media/libstagefright \
 	$(TOP)/frameworks/native/include/media/openmax
 
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index 82fb637..859d826 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -30,7 +30,7 @@
 #include <media/stagefright/Utils.h>
 
 #include "include/avc_utils.h"
-
+#include "actal_posix_dev.h"
 #include <netinet/in.h>
 
 namespace android {
@@ -38,6 +38,7 @@ namespace android {
 ElementaryStreamQueue::ElementaryStreamQueue(Mode mode, uint32_t flags)
     : mMode(mode),
       mFlags(flags) {
+	  	init_buf = (int8_t *)actal_malloc(12);
 }
 
 sp<MetaData> ElementaryStreamQueue::getFormat() {
@@ -54,6 +55,12 @@ void ElementaryStreamQueue::clear(bool clearFormat) {
     if (clearFormat) {
         mFormat.clear();
     }
+    if(init_buf != NULL)
+    {
+	    actal_free(init_buf);
+	    //fixme:when use actaudio,init_buf should not be here
+	    init_buf = NULL;
+	}
 }
 
 static bool IsSeeminglyValidADTSHeader(const uint8_t *ptr, size_t size) {
@@ -415,7 +422,7 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAAC() {
             CHECK_NE(channel_configuration, 0u);
             bits.skipBits(2);  // original_copy, home
 
-            mFormat = MakeAACCodecSpecificData(
+            mFormat = MakeAACCodecSpecificData_1(init_buf,
                     profile, sampling_freq_index, channel_configuration);
 
             mFormat->setInt32(kKeyIsADTS, true);
@@ -476,6 +483,11 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAAC() {
             mBuffer->size() - offset);
     mBuffer->setRange(0, mBuffer->size() - offset);
 
+	if(timeUs == 0ll)
+	{
+		ALOGD("tsa %lld",timeUs);
+		timeUs = 10;
+	}
     accessUnit->meta()->setInt64("timeUs", timeUs);
 
     return accessUnit;
@@ -609,7 +621,10 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitH264() {
 
             int64_t timeUs = fetchTimestamp(nextScan);
             CHECK_GE(timeUs, 0ll);
-
+			if(timeUs == 0ll)
+			{
+				ALOGD("tsv %lld",timeUs);
+			}
             accessUnit->meta()->setInt64("timeUs", timeUs);
 
             if (mFormat == NULL) {
diff --git a/media/libstagefright/mpeg2ts/ESQueue.h b/media/libstagefright/mpeg2ts/ESQueue.h
index 66a8087..4764fc9 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.h
+++ b/media/libstagefright/mpeg2ts/ESQueue.h
@@ -64,6 +64,7 @@ private:
     List<RangeInfo> mRangeInfos;
 
     sp<MetaData> mFormat;
+    int8_t *init_buf;
 
     sp<ABuffer> dequeueAccessUnitH264();
     sp<ABuffer> dequeueAccessUnitAAC();
diff --git a/media/libstagefright/rtsp/ARTPConnection.cpp b/media/libstagefright/rtsp/ARTPConnection.cpp
index 501a970..af369b5 100644
--- a/media/libstagefright/rtsp/ARTPConnection.cpp
+++ b/media/libstagefright/rtsp/ARTPConnection.cpp
@@ -117,7 +117,8 @@ void ARTPConnection::MakePortPair(
 
     bumpSocketBufferSize(*rtcpSocket);
 
-    unsigned start = (rand() * 1000)/ RAND_MAX + 15550;
+    /* rand() * 1000 may overflow int type, use long long */
+    unsigned start = (unsigned)((rand()* 1000ll)/RAND_MAX) + 15550;
     start &= ~1;
 
     for (unsigned port = start; port < 65536; port += 2) {
diff --git a/media/libstagefright/rtsp/MyHandler.h b/media/libstagefright/rtsp/MyHandler.h
index deee30f..88b3e82 100644
--- a/media/libstagefright/rtsp/MyHandler.h
+++ b/media/libstagefright/rtsp/MyHandler.h
@@ -135,7 +135,8 @@ struct MyHandler : public AHandler {
           mReceivedFirstRTPPacket(false),
           mSeekable(false),
           mKeepAliveTimeoutUs(kDefaultKeepAliveTimeoutUs),
-          mKeepAliveGeneration(0) {
+          mKeepAliveGeneration(0),
+          mPlayResponseParsed(false) {
         mNetLooper->setName("rtsp net");
         mNetLooper->start(false /* runOnCallingThread */,
                           false /* canCallJava */,
@@ -422,6 +423,9 @@ struct MyHandler : public AHandler {
 
                     if (response->mStatusCode != 200) {
                         result = UNKNOWN_ERROR;
+                    } else if (response->mContent == NULL) {
+                        result = ERROR_MALFORMED;
+                        ALOGE("The response has no content.");
                     } else {
                         mSessionDesc = new ASessionDescription;
 
@@ -1090,7 +1094,12 @@ struct MyHandler : public AHandler {
     }
 
     void parsePlayResponse(const sp<ARTSPResponse> &response) {
+        mPlayResponseParsed = true;
         mSeekable = false;
+        if (mTracks.size() == 0) {
+            ALOGV("parsePlayResponse: late packets ignored.");
+            return;
+        }
 
         ssize_t i = response->mHeaders.indexOfKey("range");
         if (i < 0) {
@@ -1237,6 +1246,8 @@ private:
 
     Vector<TrackInfo> mTracks;
 
+    bool mPlayResponseParsed;
+
     void setupTrack(size_t index) {
         sp<APacketSource> source =
             new APacketSource(mSessionDesc, index);
@@ -1408,6 +1419,13 @@ private:
             int32_t trackIndex, const sp<ABuffer> &accessUnit) {
         ALOGV("onAccessUnitComplete track %d", trackIndex);
 
+        if(!mPlayResponseParsed){
+            ALOGI("play response is not parsed, storing accessunit");
+            TrackInfo *track = &mTracks.editItemAt(trackIndex);
+            track->mPackets.push_back(accessUnit);
+            return;
+        }
+
         if (mFirstAccessUnit) {
             sp<AMessage> msg = mNotify->dup();
             msg->setInt32("what", kWhatConnected);
diff --git a/media/libstagefright/vendor/Android.mk b/media/libstagefright/vendor/Android.mk
new file mode 100755
index 0000000..2e43120
--- /dev/null
+++ b/media/libstagefright/vendor/Android.mk
@@ -0,0 +1,4 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/media/libstagefright/vendor/ID3parser/Android.mk b/media/libstagefright/vendor/ID3parser/Android.mk
new file mode 100755
index 0000000..8ad4a96
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/Android.mk
@@ -0,0 +1,21 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    id3_helper.cpp                \
+    ape_id3parse.cpp              \
+    mp3_id3parse.cpp              \
+    ogg_id3parse.cpp              \
+    wma_id3parse.cpp              \
+    id3fileIO.cpp                 \
+    flac_id3parse.cpp             \
+    
+LOCAL_C_INCLUDES := \
+        $(LOCAL_PATH)/include \
+        $(TOP)/external/icu4c/common \
+        $(call include-path-for, alsp) \
+        $(TOP)/frameworks/av/include/alsp/inc \
+        $(TOP)/system/core/include/ion
+        
+LOCAL_MODULE:= libid3parser
+include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/vendor/ID3parser/Android.mk.bak b/media/libstagefright/vendor/ID3parser/Android.mk.bak
new file mode 100755
index 0000000..583abd5
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/Android.mk.bak
@@ -0,0 +1,19 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    id3_helper.cpp                \
+    ape_id3parse.cpp              \
+    mp3_id3parse.cpp              \
+    ogg_id3parse.cpp              \
+    wma_id3parse.cpp              \
+    id3fileIO.cpp                 \
+    flac_id3parse.cpp             \
+    
+LOCAL_C_INCLUDES := \
+        $(LOCAL_PATH)/include \
+        $(TOP)/external/icu4c/common \
+        $(call include-path-for, alsp)
+        
+LOCAL_MODULE:= libid3parser
+include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/vendor/ID3parser/ape_id3parse.cpp b/media/libstagefright/vendor/ID3parser/ape_id3parse.cpp
new file mode 100755
index 0000000..1b42649
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/ape_id3parse.cpp
@@ -0,0 +1,292 @@
+#include "id3parse.h"
+namespace android {
+int check_ape_item(char *buffer, int point, int version, int item_len)
+{
+    int check;
+
+    if (buffer[point + item_len] == 0)
+    {
+
+        if (version == 1000)
+        {
+            memcpy(&check, buffer + (point - 4), 4);
+            //printf("%s %d __1.0_check:%d_\n", __FILE__, __LINE__, check);
+            if (check == 0)
+            {
+                return 0;
+            }
+            else
+            {
+                return -1;
+            }
+        }
+        else
+        {
+            return 0;
+        }
+    }
+    else
+    {
+        return -1;
+    }
+}
+
+
+void parse_Ape(void *fp, char *buffer, id3_info_t* Tag)
+{
+    char *buffer1;
+    int i, j;
+    unsigned int tag_len, value_len;
+    int number;
+    id3_item_info_t *ptmpItem;
+    int version;
+    int check;
+    int offset, data;
+
+    //ape version   1000 = Version 1.000 (old);  2000 = Version 2.000 (new)
+    memcpy(&version, buffer + 104, 4);
+
+    memcpy(&tag_len, buffer + 108, 4);
+    ID3_fseek(fp, -((int)tag_len), SEEK_END);
+    tag_len = tag_len - 32;
+
+    buffer1 = (char *) malloc((unsigned int) tag_len);
+    if (NULL == buffer1)
+    {
+        return;
+    }
+    ID3_fread(buffer1, sizeof(char), (unsigned int) tag_len, fp);
+
+    i = 0;
+    number = 0;
+    while (((unsigned int)i < tag_len) && (number < 5))
+    {
+        j = 0;
+        ptmpItem = NULL;
+        //不获取comment字段，应用中一直未用
+        if ((UPPER(buffer1[i]) == 'A') || (UPPER(buffer1[i]) == 'T') || (UPPER(buffer1[i]) == 'G') 
+            || (UPPER(buffer1[i]) == 'Y'))
+        {
+            if ((strncmp(buffer1 + i, "AlbumArtist", 11) == 0) || (strncmp(buffer1 + i, "ArtistAlbum", 11) == 0))
+            {
+                i = i + 11;
+                continue;
+            }
+
+            offset = i + 1;
+            data = (int)UPPER(buffer1[i]);
+            data = (data << 8) + UPPER(buffer1[offset]);
+            offset++;
+            data = (data << 8) + UPPER(buffer1[offset]);
+            offset++;
+            data = (data << 8) + UPPER(buffer1[offset]);
+            //printf("APE data:0x%x\n", data);
+            switch (data)
+            {
+            case 0x41525449://ARTIST
+                if ((UPPER(buffer1[offset + 1]) != 'S') || (UPPER(buffer1[offset + 2]) != 'T'))
+                {
+                    break;
+                }
+                if ((check_ape_item(buffer1, i, version, 6) == 0) &&(Tag->author.length == 0))
+                {
+                    ptmpItem = &Tag->author;
+                    j = 6;
+                }
+                break;
+            case 0x414C4255://ALBUM
+                if ((UPPER(buffer1[offset + 1]) != 'M'))
+                {
+                    break;
+                }
+                if ((check_ape_item(buffer1, i, version, 5) == 0)&&(Tag->album.length == 0))
+                {
+                    ptmpItem = &Tag->album;
+                    j = 5;
+                }
+                break;
+            case 0x5449544C://TITLE
+                if ((UPPER(buffer1[offset + 1]) != 'E'))
+                {
+                    break;
+                }
+                if ((check_ape_item(buffer1, i, version, 5) == 0) && (0 == Tag->title.length))
+                {
+                    ptmpItem = &Tag->title;
+                    j = 5;
+                }
+                break;
+            case 0x47454E52://GENRE
+                if ((UPPER(buffer1[offset + 1]) != 'E'))
+                {
+                    break;
+                }
+                if ((check_ape_item(buffer1, i, version, 5) == 0) && (0 == Tag->genre.length))
+                {
+                    ptmpItem = &Tag->genre;
+                    j = 5;
+                }
+                break;
+            case 0x59454152: //YEAR
+                if ((check_ape_item(buffer1, i, version, 4) == 0) &&(0 == Tag->year.length))
+                {
+                    ptmpItem = &Tag->year;
+                    j = 4;
+                }
+                break;
+            default:
+                ptmpItem = NULL;
+                break;
+            }
+
+            if (ptmpItem != NULL)
+            {
+                memcpy(&value_len, (buffer1 + i) - 8, 4);
+                //确保获取的id3长度小于整个tag记录的长度
+                if (value_len < tag_len)
+                {
+                    ptmpItem->length = (int)value_len;
+                    ptmpItem->content = (char *) malloc((unsigned int) (value_len + 1));
+                    if (ptmpItem->content == NULL)
+                    {
+                        ptmpItem->length = 0;
+                        free(buffer1);
+                        return;
+                    }
+                    ptmpItem->encoding = ENCODING_UTF8;
+                    if (ptmpItem->content != NULL)
+                    {
+                        memcpy(ptmpItem->content, buffer1 + i + j + 1, (unsigned int)value_len);
+                        ptmpItem->content[value_len] = '\0';
+                        i = i + (int)value_len + j;
+                        number++;
+                    }
+                }
+            }
+        }
+
+        i++;
+    }
+    free(buffer1);
+}
+
+//***********************************************************************
+//description:峰浠剁title,artist,album,genre,year,comment瀹,灞у瀹圭0x09寮
+//argument : fileinfo--浠跺缁瀵硅矾寰
+//return    : title,artist,album,genre,year,comment瀹
+//notes    : 璋get_ape_item()
+//***********************************************************************
+
+void get_apetag(void *fp, id3_info_total* info)
+{
+
+    char buffer[128];
+    ID3_fseek(fp, -128, SEEK_END);
+    ID3_fread(buffer, sizeof(char), 128, fp);
+
+    //printf("enter get_apetag:name \n");
+    if ((buffer[0] == 'T') && (buffer[1] == 'A') && (buffer[2] == 'G'))
+    {
+        parse_id3V1(fp, info);
+    }
+    else if (memcmp(buffer + 96, "APETAGEX", 8) == 0)
+    {
+        parse_Ape(fp, buffer, &info->tag);
+    }
+    else
+    {
+        ID3_fseek(fp, 0, SEEK_SET);
+        ID3_fread(buffer, sizeof(char), 4, fp);
+        if ((buffer[0] == 'I') && (buffer[1] == 'D') && (buffer[2] == '3')) {
+            parse_id3V2_3(fp, info);
+        } else {
+        	memset(&info->tag, 0, sizeof(id3_info_t));
+        }
+    }
+
+    //printf("left get_apetag:name \n");
+    /*
+     Item_UTF8_To_UTF16(&Tag->title);
+     Item_UTF8_To_UTF16(&Tag->author);
+     Item_UTF8_To_UTF16(&Tag->album);
+     Item_UTF8_To_UTF16(&Tag->genre);
+     Item_UTF8_To_UTF16(&Tag->year);
+     */
+    //Item_UTF8_To_UTF16(&Tag->comment);
+}
+#if 0
+void get_ape_extra_info(void *fp, id3_ext_info* extra_tag)
+{
+    char head[4];
+    char version[2];
+    char buffer[128];
+    int ver;
+    int total_frames = 0;
+    int final_frame_block = 0;
+    int total_samples = 0;
+    int blocks_per_frame = 0;
+    unsigned int file_len = 0;
+    int descrip_len = 0;
+    extra_tag->bitrate = 0;
+    extra_tag->sample_rate = 0;
+    extra_tag->total_time = 0;
+    extra_tag->channel = 0;
+    ID3_fseek(fp, 0, SEEK_SET);
+    ID3_fread(buffer, sizeof(char), 128, fp);
+    if ((buffer[0] == 'M') && (buffer[1] == 'A') && (buffer[2] == 'C') && (buffer[3] == ' '))
+    {
+        ver = ((unsigned char) buffer[4]) + (((unsigned char) buffer[5]) * 0x100); //version
+        if (ver >= 3980)
+        {
+            //             printf("\nthis a new version for ape file");
+            memcpy(&descrip_len, buffer + 8, 4);
+            if (descrip_len > 50)
+            {
+                memcpy(&blocks_per_frame, buffer + 56, 4);
+                memcpy(&final_frame_block, buffer + 60, 4);
+                memcpy(&total_frames, buffer + 64, 4);
+                memcpy(&extra_tag->sample_rate, buffer + 72, 4);
+                total_samples = (total_frames * blocks_per_frame) + final_frame_block;
+                extra_tag->total_time = (unsigned int) ((unsigned int) total_samples / extra_tag->sample_rate);
+                ID3_fseek(fp, 0, SEEK_END);
+                file_len = (unsigned int) ftell(fp);
+                extra_tag->bitrate = file_len / extra_tag->total_time;
+
+                extra_tag->channel = (unsigned int) (((unsigned char) buffer[70]) + (((unsigned char) buffer[71])
+                        * 0x100));
+
+            }
+
+        }
+        else if (ver >= 3950)
+        {
+            //             printf("\nthis a old version fou ape file");
+            memcpy(&extra_tag->sample_rate, buffer + 12, 4);
+            memcpy(&total_frames, buffer + 24, 4);
+            memcpy(&final_frame_block, buffer + 28, 4);
+            total_samples = (total_frames * 0x48000) + final_frame_block;
+            extra_tag->total_time = (unsigned int) ((unsigned int) total_samples / extra_tag->sample_rate);
+            ID3_fseek(fp, 0, SEEK_END);
+            file_len = (unsigned int) ftell(fp);
+            extra_tag->bitrate = file_len / extra_tag->total_time;
+
+            extra_tag->channel = (unsigned int) ((unsigned char) buffer[10] + (((unsigned char) buffer[11]) * 0x100));
+
+        }
+        else
+        {
+            printf("\nthis version of ape file have not supported with us!");
+        }
+    }
+}
+#endif
+
+void get_ape_audio_info(void *fp, id3_info_total* info)
+{
+    memset(info, 0, sizeof(id3_info_total));
+    get_apetag(fp, info);
+    //get_ape_extra_info(fp,&info->extra_info);
+}
+
+}
+    
\ No newline at end of file
diff --git a/media/libstagefright/vendor/ID3parser/flac_id3parse.cpp b/media/libstagefright/vendor/ID3parser/flac_id3parse.cpp
new file mode 100755
index 0000000..48bc0f1
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/flac_id3parse.cpp
@@ -0,0 +1,231 @@
+#include "flac_id3parse.h"
+namespace android {
+int get_metadata_block_addr(void *fp, char blocktype)
+{
+    unsigned int addr = 4;
+    unsigned int length;
+    int result;
+    char endFlag = 0;
+    unsigned char tmp[4];
+    const unsigned char endBitMask = 0x80;
+    const unsigned char typeMask = 0x7F;
+    while (endFlag == 0)
+    {
+        result = ID3_fseek(fp, (long)addr, SEEK_SET);
+        if (result < 0)
+        {
+            endFlag = 1;
+            break;
+        }
+        result = (int)ID3_fread(tmp, sizeof(char), 4, fp);
+        if (result != 4)
+        {
+            endFlag = 1;
+        }
+        addr += 4;
+        if ((tmp[0] & typeMask) == blocktype)
+        {
+            break;
+        }
+        endFlag = (char)(tmp[0] & endBitMask);
+        length = (unsigned int)( (tmp[1] * 0x10000) + (tmp[2] * 0x100) + tmp[3]);
+        addr += length;
+    }
+    if (endFlag != 0)
+    {
+        addr = -1;
+    }
+    return addr;
+}
+
+
+void get_flac_item(void *fd, const char *string, int addr, id3_item_info_t* it_info)
+{
+    int i;
+    int j;
+    int k = 0;
+    int len;
+    char * tmp;
+    int tempval;
+
+    if ((addr <= 0) || (string == NULL))
+    {
+        return;
+    }
+    len = (int) strlen(string);
+    tmp = (char *) malloc(ID3_SECTORSIZE);
+    if (tmp == NULL)
+    {
+        return;
+    }
+    for (i = 0; i < (8 - (addr / ID3_SECTORSIZE)); i++)
+    {
+        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE), SEEK_SET);
+        ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fd);
+
+        for (j = 0; j < ID3_SECTORSIZE; j++)
+        {
+            if (UPPER(tmp[j]) != string[k])
+            {
+                k = 0;
+            }
+            else
+            {
+                k++;
+                if (k >= len)
+                {
+                    tempval = j - len - 4;
+                    if (tempval >= 0)
+                    {
+                        memcpy(&(it_info->length), tmp + tempval + 1, 4);
+                    }
+                    else
+                    {
+                        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE) + (j - len - 4) + 1, SEEK_SET);
+                        ID3_fread(&(it_info->length), sizeof(char), 4, fd);
+                    }
+                    it_info->length -= len;
+                    if ((it_info->length <= 0) || (it_info->length > 0xC000))
+                    {
+                        k = 0;
+                        it_info->length = 0;
+                        continue;
+                    }
+                    it_info->content = (char*) malloc((unsigned int) (it_info->length + 1));
+                    if (NULL == it_info->content)
+                    {
+                        free(tmp);
+                        return;
+                    }
+
+                    if (j < (ID3_SECTORSIZE - it_info->length))
+                    {
+                        memcpy(it_info->content, tmp + j + 1, (unsigned int) it_info->length);
+                    }
+                    else
+                    {
+                        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE) + j + 1, SEEK_SET);
+                        ID3_fread(it_info->content, sizeof(char), (unsigned int) it_info->length, fd);
+                    }
+                    it_info->content[it_info->length] = '\0';
+                    it_info->encoding = ENCODING_UTF8;
+                    free(tmp);
+                    return;
+                }
+            }
+        }
+    }
+    free(tmp);
+    return;
+}
+
+
+void get_flactag(void *fp, id3_info_t* Tag)
+{
+    int blockAddr;
+    blockAddr = get_metadata_block_addr(fp, FLAC_VORBIS_COMMENT);
+    if (blockAddr <= 0)
+    {
+        return;
+    }
+    get_flac_item(fp, "TITLE=", blockAddr, &Tag->title);
+    get_flac_item(fp, "ARTIST=", blockAddr, &Tag->author);
+    get_flac_item(fp, "ALBUM=", blockAddr, &Tag->album);
+    get_flac_item(fp, "GENRE=", blockAddr, &Tag->genre);
+    get_flac_item(fp, "DATE=", blockAddr, &Tag->year);
+    get_flac_item(fp, "COMMENT=", blockAddr, &Tag->comment);
+
+}
+
+void get_flac_image(void *fp, id3_image_t *imageInfo)
+{
+    char mineType[31];
+    char *imageType;
+    unsigned char *tmpBuffer;
+    int offset = 0;
+    int blockAddr;
+    int length;
+    memset(imageInfo, 0, sizeof(id3_image_t));
+    memset(mineType, 0, 31);
+
+    blockAddr = get_metadata_block_addr(fp, FLAC_PICTURE);
+    if (blockAddr <= 0)
+    {
+        return;
+    }
+
+    if (ID3_fseek(fp, blockAddr, SEEK_SET) != 0)
+    {
+        return;
+    }
+    tmpBuffer = (unsigned char *) malloc(ID3_SECTORSIZE);
+    if(NULL == tmpBuffer)
+    {
+        return;
+    }
+    if (ID3_SECTORSIZE != ID3_fread(tmpBuffer, sizeof(char), ID3_SECTORSIZE, fp))
+    {
+        free(tmpBuffer);
+        return;
+    }
+    /*MIME type string */
+    length = (tmpBuffer[4] * 0x1000000) + (tmpBuffer[5] * 0x10000) + (tmpBuffer[6] * 0x100) + tmpBuffer[7];
+    if (length > 30)
+    {
+        free(tmpBuffer);
+        return;
+    }
+    memcpy(mineType, tmpBuffer + 8, (unsigned int)length);
+
+    /*the description string */
+    offset = length + 8;
+    length = (tmpBuffer[offset] * 0x1000000) + (tmpBuffer[offset + 1] * 0x10000) + (tmpBuffer[offset + 2] * 0x100)
+            + tmpBuffer[offset + 3];
+    offset += length + 4;
+
+    /*The width of the picture in pixels :32bits*/
+    /*The height of the picture in pixels: 32bits*/
+    /*The color depth of the picture in bits-per-pixel:32bits*/
+    /*For indexed-color pictures (e.g. GIF), the number of colors used, or 0 for non-indexed pictures:32bits*/
+    offset += 16;
+
+    /*The length of the picture data in bytes:32bits*/
+    imageInfo->offset = blockAddr + offset + 4;
+    if ((offset + 4) > ID3_SECTORSIZE)
+    {
+        if (ID3_fseek(fp, blockAddr + offset, SEEK_SET) != 0)
+        {
+            free(tmpBuffer);
+            return;
+        }
+        if (4 != ID3_fread(tmpBuffer, sizeof(char), 4, fp))
+        {
+            free(tmpBuffer);
+            return;
+        }
+        offset = 0;
+    }
+    imageInfo->length = (tmpBuffer[offset] * 0x1000000) + (tmpBuffer[offset + 1] * 0x10000) + 
+                  (tmpBuffer[offset + 2] * 0x100)+ tmpBuffer[offset + 3];
+    mineType[30] = '\0';
+    imageType = strrchr(mineType, '/');
+    if (imageType != NULL)
+    {
+        //strcpy(imageInfo->imageType, imageType + 1);
+        strncpy(imageInfo->imageType, imageType + 1, 8);
+    }
+
+    free(tmpBuffer);
+    return;
+}
+
+void get_flac_audio_info(void *fd, id3_info_total* info)
+{
+    memset(info, 0, sizeof(id3_info_total));
+
+    get_flactag(fd, &info->tag);
+    //get_ogg_extra_info(fp,&info->extra_info);
+    get_flac_image(fd, &info->tag.imageInfo);
+}
+
+}
\ No newline at end of file
diff --git a/media/libstagefright/vendor/ID3parser/flac_id3parse.h b/media/libstagefright/vendor/ID3parser/flac_id3parse.h
new file mode 100755
index 0000000..fa360ff
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/flac_id3parse.h
@@ -0,0 +1,26 @@
+#ifndef _FLAC_ID3PARSE_H_
+#define _FLAC_ID3PARSE_H_
+
+#include "id3parse.h"
+namespace android {
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum
+{
+    FLAC_STREAMINFO = 0,
+    FLAC_PADDING = 1,
+    FLAC_APPLICATION = 2,
+    FLAC_SEEKTABLE = 3,
+    FLAC_VORBIS_COMMENT = 4,
+    FLAC_CUESHEET = 5,
+    FLAC_PICTURE = 6
+};
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+} // namespace android
+
+#endif
diff --git a/media/libstagefright/vendor/ID3parser/id3_helper.cpp b/media/libstagefright/vendor/ID3parser/id3_helper.cpp
new file mode 100755
index 0000000..caf9bac
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/id3_helper.cpp
@@ -0,0 +1,785 @@
+#include "id3parse.h"
+#include "music_parser_lib_dev.h"
+#include "unicode/ucnv.h"
+#include "unicode/ustring.h"
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "ID3parser"
+#include <utils/Log.h>
+
+namespace android
+{
+
+#define EXT_LEN   10
+void Item_UTF8_To_UTF16(id3_item_info_t *pItemInfo);
+void change_ext_standard(char *min, char *cap);
+static void ensure_info(id3_item_info_t *info);
+
+
+
+
+/*
+ * out:     0         ----    转换失败
+ *            not 0    ----    实际转换的字节数
+ */
+
+
+size_t codec_convert( char *from_charset,
+                    char *to_charset,
+                    char *inbuf,
+                    size_t inlen,
+                    char *outbuf,
+                    size_t outlen )
+{
+
+    size_t length = outlen;
+    char *pin = inbuf;
+    char *pout = outbuf;
+    UErrorCode status = U_ZERO_ERROR;
+
+    UConverter *conv = ucnv_open(from_charset, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("could not create UConverter for %s\n", from_charset);
+        return -1;
+    }
+    UConverter *destConv = ucnv_open(to_charset, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("could not create UConverter for  for %s\n", to_charset);
+        ucnv_close(conv);
+        return -1;
+    }
+    ucnv_convertEx(destConv, conv, &pout, pout + outlen,
+            (const char **)&pin, (const char *)pin + inlen, NULL, NULL, NULL, NULL, TRUE, TRUE, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("ucnv_convertEx failed: %d\n", status);
+    } else {
+    // zero terminate
+        *pout = 0;
+    }
+    ucnv_close(conv);
+    ucnv_close(destConv);
+    return 0;
+}
+
+void getgenre(char c, id3_item_info_t* temp)
+{
+//    const char* genre_tab[] =
+//        {
+//            "Blues", "ClassicRock", "Country", "Dance", "Disco", "Funk", "Grunge", "Hip-Hop", "Jazz", "Metal", "NewAge",
+//            "Oldies", "Other", "Pop", "R&B", "Rap", "Reggae", "Rock", "Techno", "Industrial", "Alternative", "Ska",
+//            "DeathMetal", "Pranks", "Soundtrack", "Euro-Techno", "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk", "Fusion",
+//            "Trance", "Classical", "Instrumental", "Acid", "House", "Game", "SoundClip", "Gospel", "Noise",
+//            "AlternRock", "Bass", "Soul", "Punk", "Space", "Meditative", "InstrumentalPop", "InstrumentalRock",
+//            "Ethnic", "Gothic", "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream",
+//            "SouthernRock", "Comedy", "Cult", "Gangsta", "Top40", "ChristianRap", "Pop/Funk", "Jungle",
+//            "NativeAmerican", "Cabaret", "NewWave", "Psychadelic", "Rave", "Showtunes", "Trailer", "Lo-Fi", "Tribal",
+//            "AcidPunk", "AcidJazz", "Polka", "Retro", "Musical", "Rock&Roll", "HardRock", "Folk", "Folk-Rock",
+//            "NationalFolk", "Swing", "FastFusion", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde",
+//            "GothicRock", "ProgessiveRock", "PsychedelicRock", "SymphonicRock", "SlowRock", "BigBand", "Chorus",
+//            "EasyListening", "Acoustic", "Humour", "Speech", "Chanson", "Opera", "ChamberMusic", "Sonata", "Symphony",
+//            "BootyBass", "Primus", "PornGroove", "Satire", "SlowJam", "Club", "Tango", "Samba", "Folklore", "Ballad",
+//            "PowerBallad", "RhythmicSoul", "Freestyle", "Duet", "PunkRock", "DrumSolo", "Acapella", "Euro-House",
+//            "DanceHall", "Goa", "Drum&Bass"
+//            "Club-House", "Hardcore", "Terror", "Indie", "BritPop", "Negerpunk", "PolskPunk", "Beat",
+//            "ChristianGangstaRap", "HeavyMetal", "BlackMetal", "Crossover", "ContemporaryChristian", "ChristianRock",
+//            "Merengue", "Salsa", "TrashMetal", "Anime", "JPop", "Synthpop"
+//        };
+
+    int i;
+    i = c & 0xff;
+//    if ( i >= (int)(sizeof(genre_tab) / sizeof(genre_tab[0])))
+//    {
+//        temp->length = 0;
+//        temp->content = NULL;
+//            if(NULL == temp->content)
+//          	{
+//          	    return;
+//          	}
+//            strcpy(temp->content, "unknown");
+//        return;
+//    }
+
+//    temp->length = (int) strlen(genre_tab[i]);
+    temp->content = (char*) malloc(16);
+//    if (NULL == temp->content)
+//    {
+//        return;
+//    }
+    sprintf(temp->content, "%d", i);
+    temp->length = 16;
+    //strncpy(temp->content, genre_tab[i], (unsigned int)(temp->length+1));
+//("%s\n", temp->content);
+}
+
+void freeItem(id3_item_info_t *item)
+{
+    if (item->content != NULL)
+    {
+        free(item->content);
+    }
+    memset(item, 0, sizeof(id3_item_info_t));
+}
+
+void freeallmemory(id3_info_total *info)
+{
+    freeItem(&info->tag.author);
+    freeItem(&info->tag.composer);
+    freeItem(&info->tag.album);
+    freeItem(&info->tag.genre);
+    freeItem(&info->tag.year);
+    freeItem(&info->tag.title);
+    freeItem(&info->tag.comment);
+    freeItem(&info->tag.autoLoop);
+#if __TRACK_NUM__ > 0
+
+    freeItem(&info->tag.track);
+#endif
+}
+
+/*!
+ * 转换大端数据为小端数据
+ *
+ * \par  Description:
+ *    以2byte为长度转换buffer中的大端数据为小端数据
+ * \param[in]   char *  待转换的数据
+ * \param[in]   int  buffer长度
+ * \ingroup     IRVPlaylist
+ *
+ */
+void TransToLittleEnd(char *buffer, int bufferLen)
+{
+    int i;
+    char tmp;
+    if (buffer == NULL)
+    {
+        return;
+    }
+    for (i = 0; i < bufferLen; i += 2)
+    {
+        tmp = buffer[i];
+        buffer[i] = buffer[i + 1];
+        buffer[i + 1] = tmp;
+    }
+    return;
+}
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  将item中的信息由整型转换为字符串.
+ * \param[in]   pitem:  待转化的item
+ * \param[out]  pitem: 转化后的item
+ * \return      void
+ *******************************************************************************/
+void item_itoa(id3_item_info_t *pitem)
+{
+    int num;
+    char buffer[10];
+    int offset;
+    if (pitem == NULL)
+    {
+        return;
+    }
+    if (pitem->length != 4)
+    {
+        return;
+    }
+
+    memcpy(&num, pitem->content, 4);
+    num = num % 10000;
+    if (num > 1000)
+    {
+        offset = 0;
+    }
+    else if (num > 100)
+    {
+        offset = 1;
+    }
+    else if (num > 10)
+    {
+        offset = 2;
+    }
+    else
+    {
+        offset = 3;
+    }
+
+    memset(buffer, 0, 10);
+    buffer[0] = (char) ((num / 1000) + 0x30);
+    num = num % 1000;
+    buffer[1] = (char) ((num / 100) + 0x30);
+    num = num % 100;
+    buffer[2] = (char) ((num / 10) + 0x30);
+    buffer[3] = (char) ((num % 10) + 0x30);
+
+    /*去除前面无效的0*/
+    buffer[0] = buffer[offset];
+    buffer[1] = buffer[offset + 1];
+    buffer[2] = buffer[offset + 2];
+    buffer[3] = buffer[offset + 3];
+
+    freeItem(pitem);
+    assert(strlen(buffer) < 10);
+    pitem->length = (int) strlen(buffer);
+    pitem->encoding = ENCODING_NORMAL;
+    pitem->content = (char *)malloc((unsigned int) (pitem->length + 1));
+    if (NULL == pitem->content)
+    {
+        return;
+    }
+    memset(pitem->content, 0, (unsigned int) (pitem->length + 1));
+    memcpy(pitem->content, buffer, (unsigned int) pitem->length);
+
+}
+/*    将unicode字符串转化为内码字符串(根据参数指定的语言的codepage) */
+/*    只在wma 时 才会调用 Unicode2Char  */
+//int mlang_unicode_to_mbcs(unsigned char *src_ucs, unsigned char *dst_mbcs,
+//                          int src_len, int *dst_len, int nation_id)
+//{
+//    int ret = 0, i;
+//#if 1
+//    codec_convert("UCS-2LE", "GBK", (char *)src_ucs, src_len, (char *)dst_mbcs, *dst_len );
+//#else   
+//    for( i = 0; i < src_len; i++ )
+//        dst_mbcs[i] = (unsigned char)(src_ucs[i] &0xff);
+//    dst_mbcs[i] = 0;
+//
+//    *dst_len = src_len;
+//#endif
+//    return ret;
+//}
+
+/*  内码字符串转换到utf8编码字符串 */
+int mlang_unicode_to_utf8 (unsigned short *unicode, int unicode_len, char *utf8, int *putf8_len)
+{
+    int i = 0;
+    int outsize = 0;
+    int charscount = 0;
+    char *tmp = utf8;
+#if 0
+    codec_convert("unicode", "UTF-8", (char *)unicode, unicode_len, (char *)utf8, *putf8_len );
+#else 
+    charscount = unicode_len / sizeof(uint16_t);
+    unsigned short unicode_tmp;
+    for (i = 0; i < charscount; i++)
+    {
+        unicode_tmp = unicode[i];
+        if (unicode_tmp >= 0x0000 && unicode_tmp <= 0x007f)
+        {
+            *tmp = (uint8_t)unicode_tmp;
+            tmp += 1;
+            outsize += 1;
+        } 
+        else if (unicode_tmp >= 0x0080 && unicode_tmp <= 0x07ff)
+        {
+            *tmp = 0xc0 | (unicode_tmp >> 6);
+            tmp += 1;
+            *tmp = 0x80 | (unicode_tmp & 0x003f);
+            tmp += 1;
+            outsize += 2;
+        }
+        else if (unicode_tmp >= 0x0800 && unicode_tmp <= 0xffff)
+        {
+            *tmp = 0xe0 | (unicode_tmp >> 12);
+            tmp += 1;
+            *tmp = 0x80 | ((unicode_tmp >> 6) & 0x003f);
+            tmp += 1;
+            *tmp = 0x80 | (unicode_tmp & 0x003f);
+            tmp += 1;
+            outsize += 3;
+        }
+
+    }
+
+    *tmp = '\0';
+    *putf8_len = outsize;
+#endif    
+    return 0;
+}
+
+//
+//int mlang_mbcs_to_utf8 (unsigned char *mbcs, int mbcs_len, char *utf8, int *putf8_len, int language)
+//{
+//    int ret = 0;
+//#if 1
+//    codec_convert( "GBK", "UTF-8",  (char *)mbcs, mbcs_len,  (char *)utf8, *putf8_len );
+//#else
+//    int utf8len = 0;
+//    for (size_t i = 0; i < mbcs_len; ++i) {
+//        if (mbcs[i] == '\0') {
+//            mbcs_len = i;
+//            break;
+//        } else if (mbcs[i] < 0x80) {
+//            ++utf8len;
+//        } else {
+//            utf8len += 2;
+//        }
+//    }
+//    *putf8_len = utf8len;
+//    if (utf8len == mbcs_len) {
+//        // Only ASCII characters present.
+//        memcpy(utf8, mbcs, mbcs_len);
+//        return ret;
+//    }
+//
+//    char *ptr = utf8;
+//    for (size_t i = 0; i < mbcs_len; ++i) {
+//        if (mbcs[i] == '\0') {
+//            break;
+//        } else if (mbcs[i] < 0x80) {
+//            *ptr++ = mbcs[i];
+//        } else if (mbcs[i] < 0xc0) {
+//            *ptr++ = 0xc2;
+//            *ptr++ = mbcs[i];
+//        } else {
+//            *ptr++ = 0xc3;
+//            *ptr++ = mbcs[i] - 64;
+//        }
+//    }
+//#endif
+//
+//    return ret;
+//}
+///*
+//    first we need to untangle the utf8 and convert it back to the original bytes
+//    since we are reducing the length of the string, we can do this in place*/
+//int mlang_mbcs_to_mbcs (unsigned char *mbcs, int mbcs_len, char *dest, int *pdest_len, int language)
+//{
+//    int ret = 0;
+//    ALOGD("mlang_mbcs_to_mbcs %s",mbcs);
+//    int len = mbcs_len;
+//    uint8_t uch;
+//    while ((uch = *mbcs++)) {
+//    if (uch & 0x80)
+//       *dest++ = ((uch << 6) & 0xC0) | (*mbcs++ & 0x3F);
+//    else
+//       *dest++ = uch;
+//    }
+//    *dest = 0;
+//    *pdest_len = mbcs_len;
+//    return ret;
+//}
+/********************************************************************************
+ 函数说明 :获取以00 00 为结束标志的字符串长度(unicode)
+ 
+ 输入参数:
+ buffer:存放buffer
+ bufferLen: buffer长度
+ 
+ 返回值:
+ 长度
+ 
+ 注意:
+ ********************************************************************************/
+int wstrlen(char *buffer, int bufferLen)
+{
+    int retVal;
+    short *wchar;
+    int i;
+    int len = bufferLen / 2;
+    wchar = (short *) buffer;
+    for (i = 0; i < len; i++)
+    {
+        if (*wchar == 0)
+        {
+            break;
+        }
+        wchar++;
+    }
+    if (i <= len)
+    {
+        retVal = i * 2;
+    }
+    else
+    {
+        retVal = 0;
+    }
+    return retVal;
+}
+
+int Unicode2utf8(char *str, int length)
+{
+    char * temp;
+    int stringlen;
+    int dst_len;
+    int retVal;
+
+    if ((str == NULL) || (length < 0))
+    {
+        return -1;
+    }
+
+    temp = (char *) malloc(512);
+    if (NULL == temp)
+    {
+        return -1;
+    }
+    dst_len = 512;
+    retVal = mlang_unicode_to_utf8((unsigned short *)str, length, temp, &dst_len);
+    if (retVal < 0)
+    {
+        free(temp);
+        return -1;
+    }
+
+    memcpy(str, (const char*)temp, (size_t)(dst_len+1));
+    free(temp);
+    return 0;
+}
+//        } 
+//        */              
+//    }
+//    pdst[num] = 0;
+//    return num;
+//}
+
+/*
+ * test modifiy utf8
+ * phchen.2011.10.26
+ */
+int is_modifiy_utf8 (char *utf8, int length)
+{
+    int i = 0;
+    unsigned char chr;
+    char *pt = utf8;
+
+    while ( i < length ) 
+    {
+        chr = *(pt++);
+        i++;
+        // Switch on the high four bits.
+        switch (chr >> 4) 
+        {
+            case 0x00:
+            case 0x01:
+            case 0x02:
+            case 0x03:
+            case 0x04:
+            case 0x05:
+            case 0x06:
+            case 0x07: 
+            {
+                // Bit pattern 0xxx. No need for any extra bytes.
+                break;
+            }
+            case 0x08:
+            case 0x09:
+            case 0x0a:
+            case 0x0b:
+            case 0x0f:
+            {
+                /*
+                 * Bit pattern 10xx or 1111, which are illegal start bytes.
+                 * 
+                 */
+                 return -1;
+            }
+
+            case 0x0e: 
+            {
+                // Bit pattern 1110, so there are two additional bytes.
+                chr = *(pt++);
+                i++;
+                if ((chr & 0xc0) != 0x80) 
+                {
+                    return -1;
+                }
+            }
+            case 0x0c:
+            case 0x0d: 
+            {
+                // Bit pattern 110x, so there is one additional byte.
+                chr = *(pt++);
+                i++;
+                if ((chr & 0xc0) != 0x80) 
+                {
+                    return -1;
+                }
+                break;
+            }
+        }
+    }
+    return 0;
+}
+
+//所有编码目标编码为utf8
+void transItemEncoding(id3_item_info_t *targetItem, id3_item_info_t *sourceItem, char encoding)
+{
+    int length;
+    int ret = 0;
+
+    if ((NULL == sourceItem) || (NULL == targetItem) || (sourceItem->length <= 0))
+    {
+        return;
+    }
+    memset(targetItem, 0, sizeof(id3_item_info_t));
+
+    length = ID3_SECTORSIZE * 3;
+    targetItem->content = (char *) malloc((unsigned int) length);
+    if (NULL == targetItem->content)
+    {
+        return;
+    }
+    memset(targetItem->content, 0, (unsigned int) length);
+
+    if (ENCODING_UTF8 == sourceItem->encoding)
+    {
+        /*
+        if(sourceItem->length > length)
+        {
+            sourceItem->length = length-1;
+        }
+        memcpy(targetItem->content, sourceItem->content, (unsigned int) sourceItem->length);
+        targetItem->length = sourceItem->length;
+        */
+        if (sourceItem->content == NULL)
+        {
+            targetItem->length = 0;
+            free(targetItem->content);
+            targetItem->content = NULL;
+            return;
+        }
+        
+        ret = is_modifiy_utf8((char *)sourceItem->content, sourceItem->length);
+        if (ret != 0)
+        {
+            char *pt =  targetItem->content;
+            targetItem->length = sourceItem->length + 2;
+            *pt    = 0xcf;
+            pt++;
+            *pt    = 0xcf;
+            pt++;
+            memcpy(pt, sourceItem->content, (unsigned int) sourceItem->length);
+            pt[sourceItem->length] = 0;
+        }
+        else
+        {
+            memcpy(targetItem->content, sourceItem->content, (unsigned int) sourceItem->length);
+            targetItem->length = sourceItem->length;
+        }    
+           /*     
+        ret = mlang_utf8_to_android_utf8((char *)sourceItem->content, sourceItem->length, targetItem->content, &length);
+        if (ret <= 0)
+        {
+            targetItem->length = 0;
+            free(targetItem->content);
+            targetItem->content = NULL;
+            ALOGV("target content NULL, ENCODING_UTF8\n");
+            return;
+        }
+        targetItem->length = ret;
+        */
+        ALOGV("ENCODING_UTF8 (%s)(%s)\n", sourceItem->content, targetItem->content);
+        
+    }
+    else if (ENCODING_NORMAL == sourceItem->encoding)
+    {
+        /*
+        ret = mlang_mbcs_to_utf8((unsigned char *)sourceItem->content, sourceItem->length, targetItem->content, &length, -1);
+        if ((ret < 0) || (length < 0))
+        {
+            targetItem->length = 0;
+            free(targetItem->content);
+            targetItem->content = NULL;
+            return;
+        }
+        targetItem->length = (int) strlen(targetItem->content);
+        */
+        
+        // make something flag to point that it is mbcs,
+        // phchen 2011.10.26
+        char *pt = sourceItem->content;
+        ALOGV("ENCODING_NORMAL begin (%s)\n", sourceItem->content);
+        ret = 0;
+        for (int i = 0; i < sourceItem->length; i++,pt++)
+        {
+            // Is the string all assic,
+            if ((*pt >= 0x80) || (*pt < 0))
+            {
+                ret = -1;
+                break;
+            }
+        } 
+        pt =  targetItem->content;
+        targetItem->length = sourceItem->length;
+        if (ret < 0)
+        {
+            // these are not only inclue ASSIC.
+            targetItem->length = sourceItem->length + 2;
+            *pt    = 0xcf;
+            pt++;
+            *pt    = 0xcf;
+            pt++;
+        }
+        memcpy(pt, sourceItem->content, (unsigned int) sourceItem->length);
+        pt[sourceItem->length] = 0;
+        ALOGV("ENCODING_NORMAL end (%s)\n", pt);
+    }
+    else if (ENCODING_UNICODE == sourceItem->encoding)
+    {
+        ret = mlang_unicode_to_utf8((unsigned short *)sourceItem->content, sourceItem->length, targetItem->content, &targetItem->length);
+        if ((ret < 0) || (length < 0))
+        {
+            targetItem->length = 0;
+            free(targetItem->content);
+            targetItem->content = NULL;
+            ALOGV("target content NULL, ENCODING_UNICODE\n");
+            return;
+        }
+        ALOGV("ENCODING_UNICODE (%s)(%s)\n", sourceItem->content, targetItem->content);
+    }
+    else
+    {
+        ALOGD("unknown ENCODING\n");
+        return;
+    }
+
+}
+
+void transItem(id3_item_info_t *pitem, char encoding)
+{
+    id3_item_info_t tmpItem;
+
+    memset(&tmpItem, 0, sizeof(tmpItem));
+    /*
+    if (pitem->encoding == encoding)
+    {
+        return;
+    }
+    */
+    transItemEncoding(&tmpItem, pitem, encoding);
+    freeItem(pitem);
+    memcpy(pitem, &tmpItem, sizeof(tmpItem));
+}
+
+/*获取音乐文件的id3信息*/
+//int get_audio_id3_info(const char* fileinfo, id3_info_total* info)
+int get_audio_id3_info(ID3file_t* fp, char *fileinfo, id3_info_total* info)
+{
+    id3_item_info_t *id3tag;
+    int i;
+    int value = 0;
+    int length;
+    void * source = (void *)fp;
+
+    if((strcmp(fileinfo, PARSER_EXT_MP3) == 0) ||(strcmp(fileinfo, "audio/mpeg") == 0))
+    {
+        get_mp3_audio_info(source, info);
+    }
+    else if(( strcmp(fileinfo, PARSER_EXT_WMA) == 0) ||(strcmp(fileinfo, "audio/x-ms-wma") == 0))
+    {
+        get_wma_audio_info(source, info);
+    }
+    else if(( strcmp(fileinfo, PARSER_EXT_OGG) == 0)||(strcmp(fileinfo, "audio/ogg") == 0))
+    {
+        get_ogg_audio_info(source, info);
+    }    
+    else if(( strcmp(fileinfo, PARSER_EXT_FLAC) == 0)||(strcmp(fileinfo, "audio/x-flac") == 0))
+    {
+        get_flac_audio_info(source, info);
+    }
+    else
+    {
+        get_ape_audio_info(source, info);
+    }
+
+    id3tag = &info->tag.author;
+    
+/*   由于字符串转换没有实现，可能会导致死机，暂时注释掉 by yyd 2011-5-25 15:58*/ 
+#if 1
+    for (i = 0; i < 8; i++)
+    {
+    //将所有id3信息转换为utf8格式
+        ensure_info(id3tag);
+        transItem(id3tag, ENCODING_UTF8);
+        id3tag++;
+    }
+#endif    
+    return 0;
+}
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	将文件后缀转为大写方式
+ * \param[in]    char *min 待转换字符
+ * \param[out]   char *cap 转换后的字符
+ * \return
+ * \retval
+ * \ingroup      drv fileselector api
+ **\attention
+ *******************************************************************************/
+void change_ext_standard(char *min, char *cap)
+{
+    unsigned int i;
+    char c;
+
+    if ((NULL == min) || (NULL == cap))
+    {
+        return;
+    }
+
+    for (i = 0, c = *min; (c != 0)&&(i < (EXT_LEN-1)); min++, c = *min)
+    {
+        if ((c > 0x60) && (c < 0x7b))
+        {
+            cap[i] = c - 32;
+        }
+        else
+        {
+            cap[i] = c;
+        }
+        i++;
+    }
+    cap[i] = '\0';
+}
+
+/*!
+ * 确保item内容
+ *
+ * \par  Description:
+ *   确保item内容，去除多余空格并添加结束符
+ * \param[in]    item_info_t *info : 需要确认的item
+ * \return   void
+ */
+static void ensure_info(id3_item_info_t *info)
+{
+    char * tmp;
+    int i;
+
+    if (info == NULL)
+    {
+        return;
+    }
+    if (info->content == NULL)
+    {
+        memset(info, 0, sizeof(id3_item_info_t));
+        return;
+    }
+
+    /*去除空格*/
+    if ((info->encoding == ENCODING_NORMAL) || (info->encoding == ENCODING_UTF8))
+    {
+        info->length = (int)strlen(info->content);
+        i = info->length - 1;
+        while (i >= 0)
+        {
+            if (info->content[i] != 0x20)
+            {
+                break;
+            }
+            i--;
+        }
+        if (i < 0)
+        {
+            freeItem(info);
+            return;
+        }
+        info->content[i + 1] = '\0';
+        info->length = (int)strlen(info->content);
+    }
+
+    return;
+}
+
+} // namespace android
diff --git a/media/libstagefright/vendor/ID3parser/id3fileIO.cpp b/media/libstagefright/vendor/ID3parser/id3fileIO.cpp
new file mode 100755
index 0000000..6251b51
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/id3fileIO.cpp
@@ -0,0 +1,35 @@
+#include "id3parse.h"
+
+namespace android {
+int ID3_fread(void *buffer, size_t size, size_t count, void* stream )
+{   
+    ID3file_t* source = (ID3file_t*)stream;
+    mmm_off_t offset = (mmm_off_t)source->mOffset;
+    size_t n = source->mSource->readAt64(offset, (void*)buffer, (size_t)size * count);
+    if (n > 0)
+    {
+        source->mOffset += n;
+    }
+    return n;
+    
+}
+
+int ID3_fseek(void *stream, long offset, int whence)
+{
+    ID3file_t* source = (ID3file_t*)stream;
+    if (whence == SEEK_CUR) {
+        source->mOffset += offset;
+    } else if (whence == SEEK_SET) {
+        source->mOffset = offset;
+    } else {
+        source->mOffset = source->mFileSize + offset;
+    }
+    return 0;
+}
+
+int ID3_getfilelength(void *stream)
+{
+    ID3file_t* source = (ID3file_t*)stream;
+    return (int)source->mFileSize;
+}
+}
diff --git a/media/libstagefright/vendor/ID3parser/mp3_id3parse.cpp b/media/libstagefright/vendor/ID3parser/mp3_id3parse.cpp
new file mode 100755
index 0000000..2e050f1
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/mp3_id3parse.cpp
@@ -0,0 +1,1090 @@
+#include "id3parse.h"
+
+namespace android {
+#define ID3_BUFFER_SIZE  4096
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  解析mp3文件id3v1格式标签的id3信息
+ * \param[in]   pfile : mp3文件文件句柄
+ * \param[out]  pid3Info: mp3文件的id3信息
+ * \return      the result
+ * \retval      >=0  sucess
+ * \retval      <0  文件无id3v1格式标签
+ *******************************************************************************/
+int parse_id3V1(void *fp, id3_info_total* pid3Info)
+{
+    char tmpBuffer[128];
+    char genre;
+
+    memset(pid3Info, 0, sizeof(id3_info_total));
+    memset(tmpBuffer, 0, 128);
+    ID3_fseek(fp, -128, SEEK_END);
+    ID3_fread(tmpBuffer, sizeof(char), 128, fp);
+    if (memcmp(tmpBuffer, "TAG", 3) != 0)
+    {
+        return -1;
+    }
+
+    /*title*/
+    pid3Info->tag.title.content = (char *) malloc(31);
+    if (NULL == pid3Info->tag.title.content)
+    {
+        return -1;
+    }
+    pid3Info->tag.title.length = 31;
+    pid3Info->tag.title.encoding = ENCODING_NORMAL;
+    memset(pid3Info->tag.title.content, 0, 31);
+    memcpy(pid3Info->tag.title.content, tmpBuffer + 3, 30);
+
+    /*auther*/
+    pid3Info->tag.author.content = (char *) malloc(31);
+    if (NULL == pid3Info->tag.author.content)
+    {
+        return -1;
+    }
+    pid3Info->tag.author.length = 31;
+    pid3Info->tag.author.encoding = ENCODING_NORMAL;
+    memset(pid3Info->tag.author.content, 0, 31);
+    memcpy(pid3Info->tag.author.content, tmpBuffer + 33, 30);
+
+    /*album*/
+    pid3Info->tag.album.content = (char *) malloc(31);
+    if (NULL == pid3Info->tag.album.content)
+    {
+        return -1;
+    }
+    pid3Info->tag.album.length = 31;
+    pid3Info->tag.album.encoding = ENCODING_NORMAL;
+    memset(pid3Info->tag.album.content, 0, 31);
+    memcpy(pid3Info->tag.album.content, tmpBuffer + 63, 30);
+
+    /*year*/
+    pid3Info->tag.year.content = (char *) malloc(5);
+    if (NULL == pid3Info->tag.year.content)
+    {
+        return -1;
+    }
+    pid3Info->tag.year.length = 5;
+    pid3Info->tag.year.encoding = ENCODING_NORMAL;
+    memset(pid3Info->tag.year.content, 0, 5);
+    memcpy(pid3Info->tag.year.content, tmpBuffer + 93, 4);
+
+    /*COMM*/
+    pid3Info->tag.comment.content = (char *) malloc(31);
+    if (NULL == pid3Info->tag.comment.content)
+    {
+        return -1;
+    }
+    pid3Info->tag.comment.length = 31;
+    pid3Info->tag.comment.encoding = ENCODING_NORMAL;
+    memset(pid3Info->tag.comment.content, 0, 31);
+    memcpy(pid3Info->tag.comment.content, tmpBuffer + 97, 30);
+
+    /*genre*/
+    genre = tmpBuffer[127];
+    getgenre(genre, &pid3Info->tag.genre);
+
+    return 1;
+}
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  解析mp3文件id3v2格式APIC frame
+ * \param[in]   pfile : mp3文件文件句柄
+ * \param[in]   picAddr: APIC frame地址
+ * \param[in]   picSize : APIC frame大小
+ * \param[out]  imageInfo: APIC frame信息
+ * \return      void
+ *******************************************************************************/
+void get_mp3_image(void *pFile, int picAddr, int picSize, id3_image_t *imageInfo, int version)
+{
+    char mineType[31];
+    char *imageType;
+    char *tmpBuffer;
+    short data;
+    char textEncoding;
+    char endStringTimes = 0;
+    int picDataOffset = 0;
+    int i = 0, j, ret;
+
+    memset(mineType, 0, 31);
+    memset(imageInfo, 0, sizeof(id3_image_t));
+    if ((pFile == 0) || (picSize <= 0))
+    {
+        return;
+    }
+    tmpBuffer = (char *) malloc(ID3_BUFFER_SIZE);
+    if (NULL == tmpBuffer)
+    {
+        return;
+    }
+    memset(tmpBuffer, 0, ID3_BUFFER_SIZE);
+    ID3_fseek(pFile, picAddr, SEEK_SET);
+    ret = (int) ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, pFile);
+
+    textEncoding = tmpBuffer[0];
+    
+    if (version == 2)
+    {
+        memcpy(imageInfo->imageType, tmpBuffer + 1, 3);
+        imageInfo->imageType[3] = '\0';
+
+        i = 5;
+        while (i < (ret - 1))
+        {
+            /*找到一个字符串结束符*/
+            if (tmpBuffer[i] == 0)
+            {
+                /*unicode编码为双字节0表示结束*/
+                if (textEncoding == 1)
+                {
+                    if (tmpBuffer[i + 1] != 0)
+                    {
+                        continue;
+                    }
+                    i++;
+                }
+                break;
+            }
+            if (i >= (ret - 2))
+            {
+                picDataOffset += ID3_BUFFER_SIZE - 1;
+                ID3_fseek(pFile, picAddr + picDataOffset, SEEK_SET);
+                ret = (int) ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, pFile);
+                if (ret <= 0)
+                {
+                    free(tmpBuffer);
+                    return;
+                }
+                i = 0;
+            }
+        }
+
+        picDataOffset += i + 1;
+        imageInfo->offset = picAddr + picDataOffset;
+        imageInfo->length = picSize - picDataOffset;
+        free(tmpBuffer);
+        return;
+
+    }
+    i = 1;
+    do
+    {
+        if (tmpBuffer[i] == 0)
+        {
+            memcpy(mineType, tmpBuffer + 1, 30);
+            i += 2;
+            break;
+        }
+        if (i >= (ID3_BUFFER_SIZE - 2))
+        {
+            picDataOffset += ID3_BUFFER_SIZE - 1;
+            ID3_fseek(pFile, picAddr + picDataOffset, SEEK_SET);
+            ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, pFile);
+            i = 0;
+        }
+        i++;
+    } while (1);
+    do
+    {
+        if (i >= (ID3_BUFFER_SIZE - 2))
+        {
+            picDataOffset += ID3_BUFFER_SIZE - 1;
+            ID3_fseek(pFile, picAddr + picDataOffset, SEEK_SET);
+            ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, pFile);
+            i = 0;
+        }
+        /*找到一个字符串结束符*/
+        if (textEncoding == 0)
+        {
+            if (tmpBuffer[i] == 0)
+            {
+                break;
+            }
+        }
+        else /*unicode编码为双字节0表示结束*/
+        {
+            //pbuf =(short *)(tmpBuffer+i);
+            memcpy(&data, tmpBuffer + i, sizeof(short));
+            i++;/*unicode是双字节*/
+            if (data == 0)
+            {
+                break;
+            }
+        }
+        i++;
+    } while (1);
+    picDataOffset += i + 1;
+    mineType[30] = '\0';
+    imageType = strrchr(mineType, '/');
+    if (imageType != NULL)
+    {
+        strncpy(imageInfo->imageType, imageType + 1, 8);
+        imageInfo->offset = picAddr + picDataOffset;
+        imageInfo->length = picSize - picDataOffset;
+    }
+    exit: free(tmpBuffer);
+    return;
+}
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  解析mp3文件id3v2 frame
+ * \param[in]   fp : mp3文件文件句柄
+ * \param[in]   buffer : buffer
+ * \param[in]   bufferLen : buffer 长度
+ * \param[in]   pfileOffset : frame在文件中的offset
+ * \param[in]   pbufferOffset : frame在buffser 中的offset
+ * \param[out]  pframeInfo: frame信息
+ * \return      void
+ *******************************************************************************/
+void parse_id3V2_frame(void *fp, char *buffer, int bufferLen, int *pfileOffset, int *pbufferOffset,
+        id3_item_info_t *pframeInfo, int vesion)
+{
+    int frameLen;
+    int bufferOffset;
+    int fileOffset;
+
+    memset(pframeInfo, 0, sizeof(id3_item_info_t));
+    bufferOffset = *pbufferOffset;
+    fileOffset = *pfileOffset;
+    if (vesion >= 3)
+    {
+        frameLen = ((unsigned char) buffer[bufferOffset] * 0x1000000) + ((unsigned char) buffer[bufferOffset + 1]
+                * 0x10000) + ((unsigned char) buffer[bufferOffset + 2] * 0x100) + (unsigned char) buffer[bufferOffset
+                + 3];
+        bufferOffset += 6; /*frame length 4bytes + flag 2bytes*/
+        fileOffset += 6;
+    }
+    else if (vesion == 2)
+    {
+        frameLen = ((unsigned char) buffer[bufferOffset] * 0x10000)
+                + ((unsigned char) buffer[bufferOffset + 1] * 0x100) + ((unsigned char) buffer[bufferOffset + 2]);
+        bufferOffset += 3; /*frame length 4bytes + flag 2bytes*/
+        fileOffset += 3;
+    }
+    else
+    {
+        return;
+    }
+    if (frameLen > ID3_SECTORSIZE)
+    {
+        frameLen = ID3_SECTORSIZE;
+    }
+
+    if ((bufferOffset + frameLen) > bufferLen)
+    {
+        ID3_fseek(fp, fileOffset, SEEK_SET);
+        ID3_fread(buffer, sizeof(char), (unsigned int) bufferLen, fp);
+        bufferOffset = 0;
+    }
+
+    /*编码方式:0, 内码; 1:unicode*/
+    pframeInfo->encoding = buffer[bufferOffset];
+
+    //printf("%s__%d__pframeInfo->encoding:%d\n", __FILE__,__LINE__, pframeInfo->encoding);
+    bufferOffset++;
+    fileOffset++;
+    switch (pframeInfo->encoding)
+    {
+    case 0:
+        pframeInfo->length = frameLen - 1;
+        pframeInfo->encoding = ENCODING_NORMAL;
+        break;
+    case 1:
+        pframeInfo->length = frameLen - 1;
+        if ((pframeInfo->length % 2) != 0)
+        {
+            pframeInfo->length--;
+        }
+        /*unicode 签名(BOM):为0xFF FE 或者0xFE FF */
+        if ((buffer[bufferOffset] == (char) 0x0fe) && (buffer[bufferOffset + 1] == (char) 0x0ff))
+        {
+            pframeInfo->length -= 2;
+            TransToLittleEnd(buffer + bufferOffset + 2, pframeInfo->length);
+            bufferOffset += 2;
+            fileOffset += 2;
+        }
+        else if ((buffer[bufferOffset] == (char) 0x0ff) && (buffer[bufferOffset + 1] == (char) 0x0fe))
+        {
+            pframeInfo->length -= 2;
+            bufferOffset += 2;
+            fileOffset += 2;
+        }
+        else
+        {
+            ;//可能不包含头字节，此处容错处理 //
+        }
+        //dump(buffer + bufferOffset + 2, pframeInfo->length);
+
+        pframeInfo->encoding = ENCODING_UNICODE;
+        break;
+    case 2:
+        pframeInfo->encoding = ENCODING_UNICODE;
+        pframeInfo->length = frameLen - 1;
+        break;
+    case 3:
+        pframeInfo->encoding = ENCODING_UTF8;
+        pframeInfo->length = frameLen - 1;
+        break;
+    default:
+        return ;
+    }
+
+    if (pframeInfo->length > 0)
+    {
+        pframeInfo->content = (char*) malloc((unsigned int) (pframeInfo->length + 2));
+        if (NULL != pframeInfo->content)
+        {
+            memset(pframeInfo->content, 0, (unsigned int) (pframeInfo->length + 2));
+            memcpy(pframeInfo->content, buffer + bufferOffset, (unsigned int) pframeInfo->length);
+        }
+    }
+
+    bufferOffset += pframeInfo->length;
+    fileOffset += pframeInfo->length;
+
+    *pbufferOffset = bufferOffset;
+    *pfileOffset = fileOffset;
+}
+
+int parse_id3V2_2(void *fp, int headsize, char * buffer, id3_info_total* pid3Info)
+{
+    int keysize = 0;
+    int fileOffset;
+    int bufferOffset;
+    int number;
+    id3_item_info_t *ptmpItem;
+    int picAddr;
+    int picSize;
+    int data, offset, j = 0;
+    unsigned int ret;
+    unsigned int bufoff_tmp = 0, fileoff_tmp = 0;
+
+    number = 0;
+#if __TRACK_NUM__ <= 0
+    number++;
+#endif
+    picAddr = 0;
+    picSize = 0;
+    fileOffset = 10;
+    bufferOffset = 10;
+    while ((fileOffset < headsize) && (number < 7) && (j < 20))
+    {
+        j++;
+        if (bufferOffset >= (ID3_BUFFER_SIZE - 8))
+        {
+            ID3_fseek(fp, fileOffset, SEEK_SET);
+            ret = ID3_fread(buffer, sizeof(char), ID3_BUFFER_SIZE, fp);
+            if (ret <= 0)
+            {
+                return -1;
+            }
+            bufferOffset = 0;
+        }
+
+        if ((UPPER(buffer[bufferOffset]) == 'T'))
+        {
+            offset = bufferOffset + 1;
+            data = (int) UPPER(buffer[bufferOffset]);
+            data = (data << 8) + UPPER(buffer[offset]);
+            offset++;
+            data = (data << 8) + UPPER(buffer[offset]);
+            ptmpItem = NULL;
+            switch (data)
+            {
+                case 0x545432: // TT2
+                {
+                    if (pid3Info->tag.title.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.title;
+                    }
+                    break;
+                }
+    
+                case 0x545031: // TP1
+                {
+                    if (pid3Info->tag.author.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.author;
+                    }
+                    break;
+                }
+    
+                case 0x54414c: // TAL
+                {
+                    if (pid3Info->tag.album.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.album;
+                    }
+                    break;
+                }
+    
+                case 0x545945: // TYE
+                {
+                    if (pid3Info->tag.year.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.year;
+                    }
+                    break;
+                }
+    
+                case 0x54434f: // TCO
+                {
+                    if (pid3Info->tag.genre.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.genre;
+                    }
+                    break;
+                }
+    
+#if __TRACK_NUM__ > 0
+                case 0x54524b: // TRK
+                {
+                    if(pid3Info->tag.track.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.track;
+                    }
+                    break;
+                }
+#endif
+                default:
+                {
+                    ptmpItem = NULL;
+                    break;
+                }
+            }
+
+            if (ptmpItem != NULL)
+            {
+                bufoff_tmp = (unsigned int) (bufferOffset + 3);
+                fileoff_tmp = (unsigned int) (fileOffset + 3);
+                parse_id3V2_frame(fp, buffer, ID3_BUFFER_SIZE, (int*)&fileoff_tmp, (int*)&bufoff_tmp, ptmpItem, 2);
+                number++;
+            }
+        }
+
+        //else
+        {
+            keysize = ((unsigned char) buffer[bufferOffset + 3] * 0x10000) + ((unsigned char) buffer[bufferOffset + 4]
+                    * 0x100) + ((unsigned char) buffer[bufferOffset + 5]);
+            if (strncmp(buffer + bufferOffset, "PIC", 3) == 0)
+            {
+                if ((picAddr == 0) && (keysize > 128))
+                {
+                    picAddr = fileOffset + 6;
+                    picSize = keysize;
+                    number++;
+                }
+            }
+            if (keysize == 0)
+            {
+                j++;
+            }
+            else
+            {
+                j = 0;
+            }
+
+            bufferOffset += 6 + keysize;
+            fileOffset += 6 + keysize;
+        }
+    }
+    if (picSize > 0)
+    {
+        get_mp3_image(fp, picAddr, picSize, &(pid3Info->tag.imageInfo), 2);
+    }
+    return number;
+
+}
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  解析mp3文件id3v2格式标签的id3信息
+ * \param[in]   pfile : mp3文件文件句柄
+ * \param[out]  pid3Info: mp3文件的id3信息
+ * \return      the result
+ * \retval      >=0  sucess
+ * \retval      <0  文件无id3v1格式标签
+ *******************************************************************************/
+int parse_id3V2_3(void *fp, id3_info_total* pid3Info)
+{
+    char tmpBuffer[ID3_BUFFER_SIZE];
+    unsigned int fileOffset, tagSize;
+    unsigned int bufferOffset;
+    unsigned int bufoff_tmp = 0, fileoff_tmp = 0;
+    int number;
+    id3_item_info_t *ptmpItem;
+    int picAddr;
+    int picSize;
+    int data, offset, j = 0, keysize = 0;
+    unsigned int ret;
+    int version;
+
+    memset(tmpBuffer, 0, ID3_BUFFER_SIZE);
+    memset(pid3Info, 0, sizeof(id3_info_total));
+    ID3_fseek(fp, 0, SEEK_SET);
+    ret = ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, fp);
+    if (ret <= 0)
+    {
+        return -1;
+    }
+    if ((memcmp(tmpBuffer, "ID3", 3) == 0) && (tmpBuffer[3] >= 2))
+    {
+        tagSize = (unsigned int) ((tmpBuffer[6] & 0x7F) * 0x200000 + ((tmpBuffer[7] & 0x7F) * 0x4000) + ((tmpBuffer[8]
+                & 0x7F) * 0x80) + (tmpBuffer[9] & 0x7F));
+    }
+    else
+    {
+        return -1;
+    }
+    /* 版本说明 version 值：2，mp3 2.0；3/4，mp3 2.3，2.4 */
+    version = (int) tmpBuffer[3];
+
+    bufferOffset = 10;
+    number = 0;
+#if __TRACK_NUM__ <= 0
+    number++;
+#endif
+    picAddr = 0;
+    picSize = 0;
+
+    if (version == 2)//2.2版本
+    {
+        return parse_id3V2_2(fp, (int) tagSize, tmpBuffer, pid3Info);
+    }
+    //for (fileOffset = 10; (fileOffset < tagSize) && (number < 7); fileOffset++)
+    fileOffset = 10;
+    while ((fileOffset < tagSize) && (number < 7) && (j < 20))
+    {
+        j++;
+        if (bufferOffset >= (ID3_BUFFER_SIZE - 8))
+        {
+            ID3_fseek(fp, (int) fileOffset, SEEK_SET);
+            ret = ID3_fread(tmpBuffer, sizeof(char), ID3_BUFFER_SIZE, fp);
+            if (ret <= 0)
+            {
+                return -1;
+            }
+            bufferOffset = 0;
+        }
+        if ((UPPER(tmpBuffer[bufferOffset]) == 'T'))
+        {
+            offset = (int) (bufferOffset + 1);
+            data = (int) UPPER(tmpBuffer[bufferOffset]);
+            data = (data << 8) + UPPER(tmpBuffer[offset]);
+            offset++;
+            data = (data << 8) + UPPER(tmpBuffer[offset]);
+            offset++;
+            data = (data << 8) + UPPER(tmpBuffer[offset]);
+            ptmpItem = NULL;
+            switch (data)
+            {
+                case 0x54495432: // TIT2
+                {
+                    if (pid3Info->tag.title.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.title;
+                    }
+                    break;
+                }
+    
+                case 0x54504531: // TPE1
+                {
+                    if (pid3Info->tag.author.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.author;
+                    }
+                    break;
+                }
+    
+                case 0x54414c42: // TALB
+                {
+                    if (pid3Info->tag.album.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.album;
+                    }
+                    break;
+                }
+    
+                case 0x54594552: // TYER
+                {
+                    if (pid3Info->tag.year.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.year;
+                    }
+                    break;
+                }
+    
+                case 0x54434f4e: // TCON
+                {
+                    if (pid3Info->tag.genre.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.genre;
+                    }
+                    break;
+                }
+    
+#if __TRACK_NUM__ > 0
+                case 0x5452434b: // TRCK
+
+                {
+                    if(pid3Info->tag.track.length == 0)
+                    {
+                        ptmpItem = &pid3Info->tag.track;
+                    }
+                    break;
+                }
+#endif
+                default:
+                {
+                    ptmpItem = NULL;
+                    break;
+                }
+            }
+
+            //不在parse_id3V2_frame中计算关键字跳转，避免大于512被裁断，跳转失效 //
+            if (ptmpItem != NULL)
+            {
+                bufoff_tmp = bufferOffset + 4;
+                fileoff_tmp = fileOffset + 4;
+                parse_id3V2_frame(fp, tmpBuffer, ID3_BUFFER_SIZE, (int*)&fileoff_tmp, (int*)&bufoff_tmp, ptmpItem, version);
+                number++;
+                //continue;
+            }
+        }
+        //else
+        {
+            keysize = ((unsigned char) tmpBuffer[bufferOffset + 4] * 0x1000000)
+                    + ((unsigned char) tmpBuffer[bufferOffset + 5] * 0x10000) + ((unsigned char) tmpBuffer[bufferOffset
+                    + 6] * 0x100) + (unsigned char) tmpBuffer[bufferOffset + 7];
+            if (strncmp(tmpBuffer + bufferOffset, "APIC", 4) == 0)
+            {
+                if ((picAddr == 0) && (keysize > 128))
+                {
+                    picAddr = (int) (fileOffset + 10);
+                    picSize = keysize;
+                    number++;
+                }
+            }
+            if (keysize == 0)
+            {
+                j++;
+            }
+            else
+            {
+                j = 0;
+            }
+
+            bufferOffset += 10 + (unsigned int) keysize;
+            fileOffset += 10 + (unsigned int) keysize;
+        }
+
+    }
+    if (picSize > 0)
+    {
+        get_mp3_image(fp, picAddr, picSize, &(pid3Info->tag.imageInfo), version);
+    }
+    return number;
+}
+
+#if 0
+void get_mp3_extra_info(void *fp,id3_info_total* info)
+{
+    plDEBUG("calling");
+    char vor_flag[4] =
+    {   0x58,0x69,0x6E,0x67};
+    char vori_flag[4] =
+    {   0x56,0x42,0x52,0x49};
+    char Head[10];
+    int i;
+    int id3v2_len=0;
+    int frame_start_addr = 0;
+    id3_ext_info* extra_tag = &info->extra_info;
+    char *buffer=(char *)malloc(2*ID3_SECTORSIZE);
+    ID3_fseek(fp,0,SEEK_SET);
+    ID3_fread(Head,sizeof(char),10,fp);
+    if( Head[0] == 'I' && Head[1] == 'D' && Head[2] == '3' )
+    {
+        id3v2_len =((int)(Head[6]&0x7F))*0x200000+((int)(Head[7]&0x7F))*0x4000+(int)((Head[8]&0x7F))*0x80+(int)(Head[9]&0x7F);
+        frame_start_addr = id3v2_len;
+    }
+    ID3_fseek(fp,frame_start_addr,SEEK_SET);
+    S_FS_FRead(buffer,sizeof(char),1024,fp);
+    for( i = 0; i < 1024; i++)
+    {
+        if( (buffer[i] == vor_flag[0]) && (buffer[i+1] == vor_flag[1]) && (buffer[i+2] == vor_flag[2]) && (buffer[i+3] == vor_flag[3]) )
+        {
+            plDEBUG("this is a vbr file!\n");
+            int addr = i+4;
+            get_vor_extra_info(buffer,addr,extra_tag);
+            break;
+        }
+        else if( (buffer[i] == vori_flag[0]) && (buffer[i+1] == vori_flag[1]) && (buffer[i+2] == vori_flag[2]) && (buffer[i+3] == vori_flag[3]) )
+        {
+            plDEBUG("this is a vbri file!\n");
+            int addr = i+4;
+            get_vori_extra_info(buffer,addr,extra_tag);
+            break;
+        }
+        else if( i == 1021)
+        {
+            plDEBUG("this file is a noamal mp3 file!\n");
+            int addr = 0;
+            get_normal_extra_info(buffer,addr,info);
+            if(extra_tag->bitrate != 0)
+            {
+                int file_len;
+                int data_len;
+
+                ID3_fseek(fp, 0, SEEK_END);
+                file_len=ftell(fp);
+                data_len = file_len - id3v2_len;
+                //printf("%s__%s__%d:data_len=%d\n",__FILE__,__FUNCTION__,__LINE__,data_len);
+                extra_tag->total_time = data_len*8/(extra_tag->bitrate);
+                //printf("%s__%s__%d:extra_tag->total_time=%d\n",__FILE__,__FUNCTION__,__LINE__,extra_tag->total_time);
+            }
+            break;
+        }
+    }
+    //    fsel_free(buffer);
+    //    free(buffer1);
+    free(buffer);
+}
+
+void get_vor_extra_info(char* buffer,int addr,id3_ext_info* extra_tag)
+{
+    plDEBUG("calling");
+    int i;
+    int sample_rate_flag;
+    char total_frame[4];
+    int total_frame_num;
+    extra_tag->sample_rate = 0;
+    extra_tag->bitrate = 0;
+    extra_tag->channel = 0;
+    extra_tag->total_time = 0;
+    for ( i = 0; i < 1024; i++)
+    {
+        if( ((buffer[i]&0xff) == 0xff) && (((buffer[i+1]>>5)&0x07)) == 0x07 )
+        {
+            if( (((buffer[i+3]>>6)&0x03) == 0x00) ||(((buffer[i+3]>>6)&0x03) == 0x01) || ( ((buffer[i+3]>>6)&0x03) == 0x02))
+            extra_tag->channel = 2;
+            else if( ((buffer[i+3]>>6)&0x03) == 0x03)
+            extra_tag->channel = 1;
+
+            if( (((buffer[i+1]<<3)>>6)&0x03) == 0x03 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 44100;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 48000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 32000;
+                }
+                break;
+
+            }
+            else if( (((buffer[i+1]<<3)>>6)&0x03) == 0x02 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 22050;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 24000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 16000;
+                }
+                break;
+            }
+        }
+    }
+    total_frame[0] = buffer[addr+4];
+    total_frame[1] = buffer[addr+5];
+    total_frame[2] = buffer[addr+6];
+    total_frame[3] = buffer[addr+7];
+    total_frame_num = (unsigned char)(total_frame[0])*0x1000000 + (unsigned char)total_frame[1]*0x10000 + (unsigned char)total_frame[2]*0x100 + (unsigned char)total_frame[3];
+    if ( extra_tag->sample_rate >= 32000)
+    extra_tag->total_time = total_frame_num * 1152 /extra_tag->sample_rate;
+    else if(extra_tag->sample_rate> 0)
+    extra_tag->total_time = total_frame_num * 576 /extra_tag->sample_rate;
+}
+
+void get_vori_extra_info(char* buffer,int addr,id3_ext_info* extra_tag)
+{
+    int i;
+    int sample_rate_flag;
+    char total_frame[4];
+    int total_frame_num;
+    extra_tag->sample_rate = 0;
+    extra_tag->bitrate = 0;
+    extra_tag->channel = 0;
+    extra_tag->total_time = 0;
+    for ( i = 0; i < 1024; i++)
+    {
+        if( ((buffer[i]&0xff) == 0xff) && (((buffer[i+1]>>5)&0x07)) == 0x07 )
+        {
+            if( (((buffer[i+3]>>6)&0x03) == 0x00) ||(((buffer[i+3]>>6)&0x03) == 0x01) || ( ((buffer[i+3]>>6)&0x03) == 0x02))
+            extra_tag->channel = 2;
+            else if( ((buffer[i+3]>>6)&0x03) == 0x03)
+            extra_tag->channel = 1;
+
+            if( (((buffer[i+1]<<3)>>6)&0x03) == 0x03 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 44100;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 48000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 32000;
+                }
+                break;
+
+            }
+            else if( (((buffer[i+1]<<3)>>6)&0x03) == 0x02 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 22050;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 24000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 16000;
+                }
+                break;
+            }
+        }
+    }
+    total_frame[0] = buffer[addr+10];
+    total_frame[1] = buffer[addr+11];
+    total_frame[2] = buffer[addr+12];
+    total_frame[3] = buffer[addr+13];
+    total_frame_num = ((unsigned char)total_frame[0])*0x1000000 + ((unsigned char)total_frame[1])*0x10000 + ((unsigned char)total_frame[2])*0x100 + ((unsigned char)total_frame[3]);
+    if ( extra_tag->sample_rate >= 32000)
+    extra_tag->total_time = total_frame_num * 1152 /extra_tag->sample_rate;
+    else if(extra_tag->sample_rate> 0)
+    extra_tag->total_time = total_frame_num * 576 /extra_tag->sample_rate;
+
+}
+
+void get_normal_extra_info(char* buffer,int addr,id3_info_total* info)
+{
+    int i;
+    int sample_rate_flag;
+    int bitrate_flag;
+    id3_ext_info* extra_tag = &info->extra_info;
+    extra_tag->sample_rate = 0;
+    extra_tag->bitrate = 0;
+    extra_tag->channel = 0;
+    extra_tag->total_time = 0;
+    for ( i = 0; i < 1024; i++)
+    {
+        if( ((buffer[i]&0xff) == 0xff) && (((buffer[i+1]>>5)&0x07)) == 0x07 )
+        {
+            if( (((buffer[i+3]>>6)&0x03) == 0x00) ||(((buffer[i+3]>>6)&0x03) == 0x01) || ( ((buffer[i+3]>>6)&0x03) == 0x02))
+            extra_tag->channel = 2;
+            else if( ((buffer[i+3]>>6)&0x03) == 0x03)
+            extra_tag->channel = 1;
+
+            if( (((buffer[i+1]<<3)>>6)&0x03) == 0x03 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 44100;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 48000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 32000;
+                }
+                bitrate_flag = (buffer[i+2]>>4)&0x0f;
+                if(bitrate_flag == 0x01)
+                extra_tag->bitrate = 32000;
+                else if(bitrate_flag == 0x02)
+                extra_tag->bitrate = 40000;
+                else if(bitrate_flag == 0x03)
+                extra_tag->bitrate = 48000;
+                else if(bitrate_flag == 0x04)
+                extra_tag->bitrate = 56000;
+                else if(bitrate_flag == 0x05)
+                extra_tag->bitrate = 64000;
+                else if(bitrate_flag == 0x06)
+                extra_tag->bitrate = 80000;
+                else if(bitrate_flag == 0x07)
+                extra_tag->bitrate = 96000;
+                else if(bitrate_flag == 0x08)
+                extra_tag->bitrate = 112000;
+                else if(bitrate_flag == 0x09)
+                extra_tag->bitrate = 128000;
+                else if(bitrate_flag == 0x0a)
+                extra_tag->bitrate = 160000;
+                else if(bitrate_flag == 0x0b)
+                extra_tag->bitrate = 192000;
+                else if(bitrate_flag == 0x0c)
+                extra_tag->bitrate = 224000;
+                else if(bitrate_flag == 0x0d)
+                extra_tag->bitrate = 256000;
+                else if(bitrate_flag == 0x0e)
+                extra_tag->bitrate = 320000;
+                //printf("%s__%s__%d:bitrate=%d\n",__FILE__,__FUNCTION__,__LINE__,extra_tag->bitrate);
+                break;
+            }
+            else if( (((buffer[i+1]<<3)>>6)&0x03) == 0x02 )
+            {
+                sample_rate_flag = ((buffer[i+2]<<4)>>6)&0x03;
+                if ( sample_rate_flag == 0x00 )
+                {
+                    extra_tag->sample_rate = 22050;
+                }
+                else if ( sample_rate_flag == 0x01 )
+                {
+                    extra_tag->sample_rate = 24000;
+                }
+                else if ( sample_rate_flag == 0x02 )
+                {
+                    extra_tag->sample_rate = 16000;
+                }
+                //printf("%s__%s__%d:sample_rate=%d\n",__FILE__,__FUNCTION__,__LINE__,extra_tag->sample_rate);
+                bitrate_flag = (buffer[i+2]>>4)&0x0f;
+                if(bitrate_flag == 0x01)
+                extra_tag->bitrate = 32000;
+                else if(bitrate_flag == 0x02)
+                extra_tag->bitrate = 40000;
+                else if(bitrate_flag == 0x03)
+                extra_tag->bitrate = 48000;
+                else if(bitrate_flag == 0x04)
+                extra_tag->bitrate = 56000;
+                else if(bitrate_flag == 0x05)
+                extra_tag->bitrate = 64000;
+                else if(bitrate_flag == 0x06)
+                extra_tag->bitrate = 80000;
+                else if(bitrate_flag == 0x07)
+                extra_tag->bitrate = 96000;
+                else if(bitrate_flag == 0x08)
+                extra_tag->bitrate = 112000;
+                else if(bitrate_flag == 0x09)
+                extra_tag->bitrate = 128000;
+                else if(bitrate_flag == 0x0a)
+                extra_tag->bitrate = 160000;
+                else if(bitrate_flag == 0x0b)
+                extra_tag->bitrate = 192000;
+                else if(bitrate_flag == 0x0c)
+                extra_tag->bitrate = 224000;
+                else if(bitrate_flag == 0x0d)
+                extra_tag->bitrate = 256000;
+                else if(bitrate_flag == 0x0e)
+                extra_tag->bitrate = 320000;
+                //printf("%s__%s__%d:bitrate=%d\n",__FILE__,__FUNCTION__,__LINE__,extra_tag->bitrate);
+                break;
+            }
+        }
+    }
+
+}
+#endif
+
+/******************************************************************************/
+/*!
+ * \par  Description:
+ *	  解析mp3格式文件id3信息
+ * \param[in]   pfile : mp3文件文件句柄
+ * \param[out]  pid3Info: mp3文件的id3信息
+ * \return     void
+ *******************************************************************************/
+void get_mp3_audio_info(void *pfile, id3_info_total* pid3Info)
+{
+    int err;
+    char i;
+    char j = 0;
+    unsigned short * pstring = NULL;
+
+    memset(pid3Info, 0, sizeof(id3_info_total));
+    err = parse_id3V2_3(pfile, pid3Info);
+    if (err <= 0)
+    {
+
+        parse_id3V1(pfile, pid3Info);
+        return;
+    }
+
+    if ((pid3Info->tag.genre.content == NULL) || (pid3Info->tag.genre.length <= 0))
+    {
+        return;
+    }
+    /*防止unicode编码时，数字未转化成对应流派*/
+    if (pid3Info->tag.genre.encoding == ENCODING_UNICODE)
+    {
+        pstring = (unsigned short *) pid3Info->tag.genre.content;
+        if (pstring[0] != '(')
+        {
+            return;
+        }
+
+        i = 1;
+        while ((pstring[i] >= '0') && (pstring[i] <= '9'))
+        {
+            j = j * 10;
+            j += (char)(pstring[i] - '0');
+            i++;
+        }
+
+        if (pid3Info->tag.genre.content[i] != ')')
+        {
+            return;
+        }
+        freeItem(&pid3Info->tag.genre);
+        getgenre(j, &pid3Info->tag.genre);
+        return;
+
+    }
+
+    if (pid3Info->tag.genre.content[0] != '(')
+    {
+        return;
+    }
+
+    i = 1;
+    while ((pid3Info->tag.genre.content[i] >= '0') && (pid3Info->tag.genre.content[i] <= '9'))
+    {
+        j = j * 10;
+        j += pid3Info->tag.genre.content[i] - '0';
+        i++;
+    }
+    if (pid3Info->tag.genre.content[i] != ')')
+    {
+        return;
+    }
+    freeItem(&pid3Info->tag.genre);
+    getgenre(j, &pid3Info->tag.genre);
+}
+}
+
diff --git a/media/libstagefright/vendor/ID3parser/ogg_id3parse.cpp b/media/libstagefright/vendor/ID3parser/ogg_id3parse.cpp
new file mode 100755
index 0000000..d06b225
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/ogg_id3parse.cpp
@@ -0,0 +1,282 @@
+#include "id3parse.h"
+
+//***************************************************************************
+// Description :buffer涓惧oggTabInfo,濡惧拌truevorbis_address璁板oggTabInfo浣缃;
+//              杩false *
+// Arguments   :buffer--寰ユ炬扮锛buffer_len--buffer垮害锛                                        *
+// Returns     :涓虹惰true;杩false                                                         *
+// Notes       :                                                                                  *
+//*****************************************************************************
+
+namespace android {
+
+//int get_total_time(FILE *fd, unsigned int sample_rate);
+int find_ogg_Tag(void *fp, char * ogg_TagInfo, int length)
+{
+    int i;
+    int j = 0;
+    int k = 0;
+    int vorbis_address = 0;
+    int len;
+    char * tmp = (char *) malloc(ID3_SECTORSIZE);
+    if (NULL == tmp)
+    {
+        return -1;
+    }
+    for (i = 0; i < 8; i++)
+    {
+        ID3_fseek(fp, i * ID3_SECTORSIZE, SEEK_SET);
+        ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fp);
+        for (j = 0; j < ID3_SECTORSIZE; j++)
+        {
+            if (tmp[j] != ogg_TagInfo[k])
+            {
+                k = 0;
+            }
+            else
+            {
+                k++;
+                if (k >= length)
+                {
+                    vorbis_address = (i * ID3_SECTORSIZE) + j + 1; //find ogg_TagInfo,record the vorbis_address;
+                    free(tmp);
+                    return vorbis_address;
+                }
+            }
+        }
+    }
+    free(tmp);
+    return vorbis_address;
+}
+
+void get_ogg_item(void *fd, const char *string, int addr, id3_item_info_t* it_info)
+{
+    int i;
+    int j;
+    int k = 0;
+    int len;
+    char * tmp;
+    int tempval;
+
+    if ((addr <= 0) || (string == NULL))
+    {
+        return;
+    }
+    len = (int) strlen(string);
+    tmp = (char *) malloc(ID3_SECTORSIZE);
+    if (tmp == NULL)
+    {
+        return;
+    }
+    for (i = 0; i < (8 - (addr / ID3_SECTORSIZE)); i++)
+    {
+        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE), SEEK_SET);
+        ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fd);
+
+        for (j = 0; j < ID3_SECTORSIZE; j++)
+        {
+            if (UPPER(tmp[j]) != string[k])
+            {
+                k = 0;
+            }
+            else
+            {
+                k++;
+                if (k >= len)
+                {
+                    tempval = j - len - 4;
+                    if (tempval >= 0)
+                    {
+                        memcpy(&(it_info->length), tmp + tempval + 1, 4);
+                    }
+                    else
+                    {
+                        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE) + (j - len - 4) + 1, SEEK_SET);
+                        ID3_fread(&(it_info->length), sizeof(char), 4, fd);
+                    }
+                    it_info->length -= len;
+                    if ((it_info->length <= 0) || (it_info->length > 0xC000))
+                    {
+                        k = 0;
+                        it_info->length = 0;
+                        continue;
+                    }
+                    it_info->content = (char*) malloc((unsigned int) (it_info->length + 1));
+                    if (NULL == it_info->content)
+                    {
+                        free(tmp);
+                        return;
+                    }
+
+                    if (j < (ID3_SECTORSIZE - it_info->length))
+                    {
+                        memcpy(it_info->content, tmp + j + 1, (unsigned int) it_info->length);
+                    }
+                    else
+                    {
+                        ID3_fseek(fd, addr + (i * ID3_SECTORSIZE) + j + 1, SEEK_SET);
+                        ID3_fread(it_info->content, sizeof(char), (unsigned int) it_info->length, fd);
+                    }
+                    it_info->content[it_info->length] = '\0';
+                    it_info->encoding = ENCODING_UTF8;
+                    free(tmp);
+                    return;
+                }
+            }
+        }
+    }
+    free(tmp);
+    return;
+}
+
+//**********************************************************************
+// Description :峰fileinfo涓ogg_tab[i]绛剧瀹癸骞跺浜涠柯1陇7777绗涠柯1陇7     *
+// Arguments   :fileinfo--寰ユ炬浠剁浠惰矾寰锖柯1陇7777                         *
+// Returns     :绫诲锛QString锛瀹癸柯1陇7777TAB[i]涓绛惧瀹癸涓涔柯1陇7777    *
+//               柯1陇7777"寮                                                     *
+// Notes       :寰璋 get_ogg_item()                                           *
+//**********************************************************************
+
+void get_oggtag(void *fd, id3_info_t* Tag)
+{
+    int addr;
+    int tmp;
+    char ogg_TagInfo[] =
+    { 0x03, 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73 };
+
+    addr = find_ogg_Tag(fd, ogg_TagInfo, 7);
+    if (addr <= 0)
+    {
+        return;
+    }
+    ID3_fseek(fd, addr, SEEK_SET);
+    ID3_fread(&tmp, sizeof(char), 4, fd);
+    addr += tmp + 8;
+    get_ogg_item(fd, "TITLE=", addr, &Tag->title);
+    get_ogg_item(fd, "ARTIST=", addr, &Tag->author);
+    get_ogg_item(fd, "ALBUM=", addr, &Tag->album);
+    get_ogg_item(fd, "GENRE=", addr, &Tag->genre);
+    get_ogg_item(fd, "DATE=", addr, &Tag->year);
+    get_ogg_item(fd, "COMMENT=", addr, &Tag->comment);
+    get_ogg_item(fd, "ANDROID_LOOP=", addr, &Tag->autoLoop);
+
+    /*Item_UTF8_To_UTF16(&Tag->title);
+    Item_UTF8_To_UTF16(&Tag->author);
+    Item_UTF8_To_UTF16(&Tag->album);
+    Item_UTF8_To_UTF16(&Tag->genre);
+    Item_UTF8_To_UTF16(&Tag->year);
+    Item_UTF8_To_UTF16(&Tag->comment);*/
+#if __TRACK_NUM__ > 0
+    get_ogg_item(fd, "TRACKNUMBER=", addr, &Tag->track);
+   // Item_UTF8_To_UTF16(&Tag->trackNumber);
+#endif
+}
+/*
+void get_ogg_extra_info(void *fd, id3_ext_info* extra_tag)
+{
+    char ogg_TagInfo[] =
+    { 0x01, 0x76, 0x6f, 0x72, 0x62, 0x69, 0x73 };
+    char buffer[16];
+    char size[4];
+    int i;
+    int j = 0;
+    int addr = 0;
+    int k = 0;
+    addr = find_ogg_Tag(fd, ogg_TagInfo, 7);
+    if (addr > 0)
+    {
+        ID3_fseek(fd, addr + 4, SEEK_SET);
+        ID3_fread(buffer, sizeof(char), 16, fd);
+        extra_tag->channel = (unsigned int) buffer[0];
+        memcpy(&(extra_tag->sample_rate), buffer + 1, 4);
+        memcpy(&(extra_tag->bitrate), buffer + 9, 4);
+        extra_tag->total_time = (unsigned int) get_total_time(fd, extra_tag->sample_rate);
+    }
+    else
+    {
+        extra_tag->sample_rate = 0;
+        extra_tag->bitrate = 0;
+        extra_tag->channel = 0;
+        extra_tag->total_time = 0;
+    }
+
+}
+
+int get_total_time(void *fd, unsigned int sample_rate)
+{
+    char sample_flag[] =
+    { 0x4f, 0x67, 0x67, 0x53 }; //"OggS"
+    char tmp[ID3_SECTORSIZE];
+    int totaltime = 0;
+    int i = 0, j = 0, k = 0;
+    int addr = 0;
+    char len[8];
+    char time[4];
+    unsigned int tmp1, tmp2;
+
+    memset(time, 0, 4);
+    if (sample_rate == 0)
+    {
+        return 0;
+    }
+
+    memset(time, 0, 4);
+    memset(len, 0, 8);
+
+    //for (i = 12; i > 0; i--)
+    i = 12;
+    while (i > 0)
+    {
+        ID3_fseek(fd, -(i * ID3_SECTORSIZE), SEEK_END);
+        ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fd);
+        for (j = 0; j < ID3_SECTORSIZE; j++)
+        {
+            if (tmp[j] != sample_flag[k])
+            {
+                k = 0;
+            }
+            else
+            {
+                k++;
+                if (k >= 4)
+                {
+                    if (j < (ID3_SECTORSIZE - 10))
+                    {
+                        memcpy(len, tmp[j + 3], 8);
+                    }
+                    else
+                    {
+                        addr = (i * ID3_SECTORSIZE) - j - 1; //find ogg_TagInfo,record the vorbis_address;
+                        addr -= 2;
+                        ID3_fseek(fd, -addr, SEEK_END);
+                        ID3_fread(len, sizeof(char), 8, fd);
+                    }
+
+                    memcpy(&tmp2, len + 3, 4);
+                    for (i = 3; i > 0; i--)
+                    {
+                        tmp1 = tmp2;
+                        time[i] = (char) (tmp1 / sample_rate);
+                        tmp2 = tmp1 % sample_rate;
+                        tmp2 = tmp2 << 8;
+                        tmp2 += (unsigned int) len[i - 1] & 0xff;
+                    }
+                    memcpy(&totaltime, time, 4);
+                    return totaltime;
+
+                }
+            }
+        }
+        i--;
+    }
+
+    return totaltime;
+}
+*/
+void get_ogg_audio_info(void *fd, id3_info_total* info)
+{
+    memset(info, 0, sizeof(id3_info_total));
+    get_oggtag(fd, &info->tag);
+    //get_ogg_extra_info(fd,&info->extra_info);
+}
+}
diff --git a/media/libstagefright/vendor/ID3parser/wma_id3parse.cpp b/media/libstagefright/vendor/ID3parser/wma_id3parse.cpp
new file mode 100755
index 0000000..66ec54f
--- /dev/null
+++ b/media/libstagefright/vendor/ID3parser/wma_id3parse.cpp
@@ -0,0 +1,543 @@
+#include "id3parse.h"
+
+namespace android {
+int find_wma_guid(void *fp, char guid[16])
+{
+    char head_GUID[16] =
+    { 
+        0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 
+        0xCF, 0x11, 0xA6, 0xD9, 0x00, 
+        0xAA, 0x00, 0x62, 0xCE, 0x6C 
+    }; //ASF_Header_Object 锟铰??UID //
+    char header_object[16];
+    char tmp[20];
+    long object_len;
+    long point;
+    long object_num;
+    int i;
+    int content_address = 0;
+    int filelength;
+
+    if (!fp)
+    {
+        return 0;
+    }
+
+    filelength = ID3_getfilelength(fp);
+
+    ID3_fseek(fp, 0, SEEK_SET);
+    ID3_fread(header_object, sizeof(char), 16, fp);
+
+    if (memcmp(header_object, head_GUID, 16) != 0)
+    {
+        printf("It's not a wma file!");
+        return 0;
+    }
+    else
+    {
+        ID3_fseek(fp, 24, SEEK_SET);
+        ID3_fread(&object_num, sizeof(char), 4, fp);
+
+        if (object_num != 0)
+        {
+            point = 30;
+            for (i = 0; i < object_num; i++)
+            {
+                ID3_fseek(fp, point, SEEK_SET);
+                ID3_fread(tmp, sizeof(char), 20, fp);
+
+                if (memcmp(tmp, guid, 16) == 0)
+                {
+                    content_address = point;
+                    break;
+                }
+                else
+                {
+                    memcpy(&object_len, tmp + 16, 4);
+                    point += object_len;
+                    if (point >= filelength)
+                    {
+                        return 0;
+                    }
+                }
+
+            }
+        }
+    }
+    return content_address;
+}
+void get_wmatag(void *fp, id3_info_t* Tag)
+{
+    char content_GUID[16] =
+    { 0x33, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C };
+    int copyr_len;
+    int descrip_offset;
+    int content_address = 0;
+    char tmp[10];
+    char* unicode;
+    int length;
+    int filelength;
+
+    content_address = find_wma_guid(fp, content_GUID);
+    filelength = ID3_getfilelength(fp);
+    if (content_address > filelength)
+    {
+        return;
+    }
+
+    if (content_address != 0)
+    {
+        //plDEBUGf("content_address:%d\n",content_address);
+        /*get length*/
+        ID3_fseek(fp, content_address + 24, SEEK_SET);
+        ID3_fread(tmp, sizeof(char), 10, fp);
+        Tag->title.length = ((unsigned char) tmp[0]) + (((unsigned char) tmp[1]) * 0x100);
+        length = Tag->title.length;
+
+        Tag->author.length = (unsigned char) tmp[2] + (((unsigned char) tmp[3]) * 0x100);
+        if (length < Tag->author.length)
+        {
+            length = Tag->author.length;
+        }
+
+        copyr_len = (unsigned char) (tmp[4]) +((unsigned char) tmp[5] * 0x100);
+        Tag->comment.length = (unsigned char) (tmp[6]) +((unsigned char) tmp[7] * 0x100);
+        if (length < Tag->comment.length)
+        {
+            length = Tag->comment.length;
+        }
+        //cz_20121112 ID3信息太大引起死机
+        if(length>ID3_SECTORSIZE)
+        {
+           Tag->title.length=0;
+           Tag->comment.length=0;
+           Tag->author.length=0;
+           ALOGE("wma id3 too larger");
+           return;            
+        }
+        unicode = (char*) malloc((unsigned int) (length + 2));
+        if (NULL == unicode)
+        {
+            return;
+        }
+
+//        /*get comment*/
+//        memset(unicode, 0, (unsigned int) (length + 2));
+//        descrip_offset = content_address + 34 + Tag->title.length + Tag->author.length + copyr_len;
+//        ID3_fseek(fp, descrip_offset, SEEK_SET);
+//        ID3_fread(unicode, sizeof(char), (unsigned int) (Tag->comment.length), fp);
+//            
+//        Tag->comment.encoding = ENCODING_UNICODE;
+//        Tag->comment.length = wstrlen(unicode, Tag->comment.length + 2);
+//#if 0
+//        Unicode2Char(unicode, Tag->comment.length + 2);
+//        Tag->comment.length = (int)strlen(unicode);
+//#endif
+//        if (Tag->comment.length != 0)
+//        {
+//            Tag->comment.content = (char*) malloc((unsigned int) (Tag->comment.length + 2));
+//            if (NULL == Tag->comment.content)
+//            {
+//                free(unicode);
+//                return;
+//            }
+//            memset(Tag->comment.content, 0, (unsigned int) (Tag->comment.length + 2));
+//            memcpy(Tag->comment.content, unicode, (unsigned int) Tag->comment.length);
+//        }
+
+        /*get author*/
+        memset(unicode, 0, (unsigned int) (length + 2));
+        ID3_fseek(fp, content_address + 34 + Tag->title.length, SEEK_SET);
+        ID3_fread(unicode, sizeof(char), (unsigned int) Tag->author.length, fp);
+        Tag->author.encoding = ENCODING_UNICODE;
+        Tag->author.length = wstrlen((char *)unicode, Tag->author.length+2);
+#if 0
+        Unicode2Char(unicode, Tag->author.length + 2);
+        Tag->author.length = (int)strlen(unicode);
+#endif
+        if (Tag->author.length != 0)
+        {
+            Tag->author.content = (char*) malloc((unsigned int) (Tag->author.length + 2));
+            if (NULL == Tag->author.content)
+            {
+                free(unicode);
+                return;
+            }
+            memset(Tag->author.content, 0, (unsigned int) (Tag->author.length + 2));
+            memcpy(Tag->author.content, unicode, (unsigned int) Tag->author.length);
+        }
+
+        /*get title*/
+        memset(unicode, 0, (unsigned int) (length + 2));
+        ID3_fseek(fp, content_address + 34, SEEK_SET);
+        ID3_fread(unicode, sizeof(char), (unsigned int) Tag->title.length, fp);
+        Tag->title.encoding = ENCODING_UNICODE;
+        Tag->title.length = wstrlen((char *)unicode, Tag->title.length+2);
+#if 0
+        Unicode2Char(unicode, Tag->title.length + 2);
+        Tag->title.length = (int) strlen(unicode);
+#endif
+        if (Tag->title.length != 0)
+        {
+            Tag->title.content = (char*) malloc((unsigned int) (Tag->title.length + 2));
+            if (NULL == Tag->title.content)
+            {
+                free(unicode);
+                return;
+            }
+            memset(Tag->title.content, 0, (unsigned int) (Tag->title.length + 2));
+            memcpy(Tag->title.content, unicode, (unsigned int) Tag->title.length);
+        }
+        free(unicode);
+    }
+}
+
+void get_wma_image(id3_image_t *pImage, int imageArrayAddr, void *fp)
+{
+    char *tmp;
+    short dataType = 0;
+    unsigned short dataLen = 0;
+    char picType;
+    short MIMEType[128];
+    int MIMETypeLen;
+    char *pimageType;
+    int offset = 0;
+
+    if ((imageArrayAddr <= 0) || (fp == 0))
+    {
+        return;
+    }
+
+    tmp = (char *) malloc(ID3_SECTORSIZE);
+    if (NULL == tmp)
+    {
+        return;
+    }
+    ID3_fseek(fp, imageArrayAddr, SEEK_SET);
+    ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fp);
+    /*ASF_Extended_Content_Description_Object  Content Descriptor:datatype(16bits):1--byteArray*/
+    memcpy(&dataType, tmp, 2);
+    offset += 2;
+    /*ASF_Extended_Content_Description_Object  Content Descriptor(16bits):data length*/
+    memcpy(&dataLen, tmp + 2, 2);
+    offset += 2;
+
+    /*image type*/
+    picType = tmp[4];
+    offset++;
+    /*image length*/
+    memcpy(&pImage->length, tmp + offset, sizeof(int));
+    offset += 4;
+    /*MIMEType*/
+    memcpy(MIMEType, tmp + 9, 40);
+    MIMETypeLen = wstrlen((char *)MIMEType, 40);
+    offset += MIMETypeLen + 2;
+    Unicode2utf8((char *)MIMEType, 40);
+    pimageType = strrchr((char *) MIMEType, '/');
+    if (pimageType != NULL)
+    {
+        memcpy(pImage->imageType, pimageType + 1, 8);
+    }
+
+    /*image description*/
+    memcpy(MIMEType, tmp + offset, 128);
+    offset += wstrlen((char *)MIMEType, 128) + 2;
+    pImage->offset = imageArrayAddr + offset;
+
+    if ((dataType != 1) || (dataLen < pImage->length) || (offset > ID3_SECTORSIZE))
+    {
+        memset(pImage, 0, sizeof(id3_image_t));
+    }
+    free(tmp);
+}
+
+void get_wmatag1(void* fp, id3_info_t* Tag)
+{
+    char externed_content_GUID[16] =
+    { 
+        0x40, 0xA4, 0xD0, 0xD2, 0x07, 
+        0xE3, 0xD2, 0x11, 0x97, 0xf0, 
+        0x00, 0xA0, 0xC9, 0x5E, 0xA8, 0x50 
+    }; //ASF_Extended_Content_Description_Object
+    char id3count;
+    unsigned int offset = 0, offset_sec = 0;
+    unsigned int object_end = 0;
+    int count = 0;
+    int length = 0;
+    int datatype = 0;
+    int i = 0;
+    char *tmp = NULL;
+    char *title = NULL;
+    id3_item_info_t *item = NULL;
+    int imageArrayAddr = 0;
+
+    offset = (unsigned int)find_wma_guid(fp, externed_content_GUID);
+    if (!offset)
+    {
+        return;
+    }
+    tmp = (char *) malloc(ID3_SECTORSIZE);
+    if (NULL == tmp)
+    {
+        return;
+    }
+    title = (char *) malloc(ID3_SECTORSIZE);
+    if (NULL == title)
+    {
+        free(tmp);
+        return;
+    }
+    offset += 16; //16 is the length of ASF_Extended_Content_Description_Object
+
+
+    ID3_fseek(fp, (int)offset, SEEK_SET);
+    ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fp);
+    memcpy(&object_end, tmp, 4); //object size
+    object_end += offset - 16; //object end address
+
+    memcpy(&count, tmp + 8, 2); //content number
+    offset_sec = 10;
+    id3count = 0;
+#if __TRACK_NUM__ <= 0
+    id3count++;
+#endif
+    while ((count > 0)&&(offset < object_end) && (id3count < 5))
+    {
+        /*
+         WM/AlbumTitle = 0x1E, + namelen 2bytes, + flag 2bytes, + datalen 2bytes = 0x24*/
+        if (offset_sec > (ID3_SECTORSIZE - 0x30))
+        {
+            offset += offset_sec;
+            ID3_fseek(fp, (int)offset, SEEK_SET);
+            ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fp);
+            offset_sec = 0;
+        }
+        
+        memcpy(&length, tmp + offset_sec, 2);
+        offset_sec += 2;
+        item = NULL;
+        switch (length)
+        {
+        case 0x10:
+            memcpy(title, tmp + offset_sec, (unsigned int) length);
+            //Unicode2Char(title, length);
+            Unicode2utf8(title, length);
+            if (strcasecmp(title, "WM/Year") == 0)
+            {
+                if(Tag->year.length == 0)
+                {
+                    item = &Tag->year;
+                } 
+            }
+            break;
+
+        case 0x12:
+            memcpy(title, tmp + offset_sec, (unsigned int) length);
+            //Unicode2Char(title, length);
+            Unicode2utf8(title, length);
+            if (strcasecmp(title, "WM/Genre") == 0)
+            {
+                if(Tag->genre.length == 0)
+                {
+                    item = &Tag->genre;
+                }
+            }
+            break;
+
+        case 0x16:
+            memcpy(title, tmp + offset_sec, (unsigned int) length);
+            //Unicode2Char(title, length);
+            Unicode2utf8(title, length);
+            if (strcasecmp(title, "WM/Picture") == 0)
+            {
+                if(imageArrayAddr == 0)
+                {
+                    imageArrayAddr = (int)(offset + offset_sec) + length;
+                    id3count++;
+                }
+            }
+            
+            break;
+
+        case 0x1c:
+            memcpy(title, tmp + offset_sec, (unsigned int) length);
+            //Unicode2Char(title, length);
+            Unicode2utf8(title, length);
+            if (strcasecmp(title, "WM/AlbumTitle") == 0)
+            {
+                if(Tag->album.length == 0)
+                {
+                    item = &Tag->album;                    
+                }                 
+
+            }
+            break;
+
+#if __TRACK_NUM__ > 0
+            case 0x1e:
+            memcpy(title, tmp + offset_sec, (unsigned int)length);
+            //Unicode2Char(title, length);
+            Unicode2utf8(title, length);
+            if (strcasecmp(title, "WM/TrackNumber") == 0)
+            {
+                if(Tag->track.length == 0)
+                {
+                    item = &Tag->track;
+                }
+            }
+            break;
+#endif
+
+        default:
+            item = NULL;
+            break;
+        }
+        count--;
+        offset_sec += (unsigned int)length;
+
+        if(offset_sec >= (ID3_SECTORSIZE -4))
+        {
+            //防止offset_sec超出ID3_SECTORSIZE，memcpy死机
+            continue;
+        }
+
+        memcpy(&datatype, tmp + offset_sec, 2);
+        offset_sec += 2;
+        memcpy(&length, tmp + offset_sec, 2);
+        offset_sec += 2;
+
+        if ((item != NULL) && (length > 2))
+        {
+            id3count++;
+            i = length;
+            if (offset_sec > (unsigned int)(ID3_SECTORSIZE - length))
+            {
+                offset += offset_sec;
+                ID3_fseek(fp, (int)offset, SEEK_SET);
+                ID3_fread(tmp, sizeof(char), ID3_SECTORSIZE, fp);
+                offset_sec = 0;
+                i = ID3_SECTORSIZE;
+            }
+            memset(title, 0, ID3_SECTORSIZE);
+            if(i >= ID3_SECTORSIZE)
+            {
+                i=ID3_SECTORSIZE-2;
+            }
+            memcpy(title, tmp + offset_sec, (unsigned int) i);
+
+            item->encoding = ENCODING_UNICODE;
+            item->length = wstrlen(title, i);
+
+            if (item->length != 0)
+            {
+                item->content = (char*) malloc((unsigned int)(item->length + 2));
+                if (NULL == item->content)
+                {
+                    break;
+                }
+                memset(item->content, 0, (unsigned int) (item->length + 2));
+                memcpy(item->content, title, (unsigned int) item->length);
+
+            }
+        }
+#if __TRACK_NUM__ > 0
+        if ((item == &Tag->track) && (datatype == 3))
+        {
+            item_itoa(item);
+        }
+#endif
+        offset_sec += (unsigned int)length;
+
+    }
+
+    free(tmp);
+    free(title);
+    if (imageArrayAddr > 0)
+    {
+        get_wma_image(&Tag->imageInfo, imageArrayAddr, fp);
+    }
+
+}
+
+void get_wma_extra_info(void *fp, id3_ext_info* extra_tag)
+{
+    char file_Object_GUID[16] =
+    { 
+        0xA1, 0xDC, 0xAB, 0x8C, 0x47, 
+        0xA9, 0xCF, 0x11, 0x8E, 0xE4, 
+        0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 
+    };//ASF_File_Properties_Object
+    char stream_Object_GUID[16] =
+    { 
+        0x91, 0x07, 0xDC, 0xB7, 0xB7, 
+        0xA9, 0xCF, 0x11, 0x8E, 0xE6, 
+        0x00, 0xC0, 0x0C, 0x20, 0x53, 
+        0x65 
+    };//ASF_Stream_Properties_Object
+    char tmp[10];
+    int file_object_addr;
+    int stream_object_addr;
+    char len1[8], len2[8];
+    int i;
+    int tmp1, tmp2;
+    extra_tag->sample_rate = 0;
+    extra_tag->bitrate = 0;
+    extra_tag->total_time = 0;
+    extra_tag->channel = 0;
+
+    file_object_addr = find_wma_guid(fp, file_Object_GUID);
+    ID3_fseek(fp, file_object_addr + 64, SEEK_SET);
+    ID3_fread(len1, sizeof(char), 8, fp);
+
+    ID3_fseek(fp, file_object_addr + 80, SEEK_SET);
+    ID3_fread(len2, sizeof(char), 8, fp);
+
+    //tmp=len1/(10000*1000)
+    memset(tmp, 0, 10);
+    tmp2 = 0;
+    for (i = 7; i >= 0; i--)
+    {
+        tmp2 += len1[i];
+        tmp1 = tmp2;
+        tmp[i] = (char) (tmp1 / 10000000);
+        tmp2 = tmp1 % 10000000;
+        tmp2 = tmp2 << 8;
+    }
+    memcpy(len1, tmp, 8);
+
+    //tmp=len2/(1000)
+    memset(tmp, 0, 10);
+    tmp2 = 0;
+    for (i = 7; i >= 0; i--)
+    {
+        tmp2 += len1[i];
+        tmp1 = tmp2;
+        tmp[i] = (char) (tmp1 / 1000);
+        tmp2 = tmp1 % 1000;
+        tmp2 = tmp2 << 8;
+    }
+    memcpy(&tmp2, tmp, 4);
+    memcpy(&tmp1, len1, 4);
+    extra_tag->total_time = (unsigned int) (tmp1 - tmp2);
+    //plDEBUGf("%d\n",extra_tag->total_time);
+
+    stream_object_addr = find_wma_guid(fp, stream_Object_GUID);
+    ID3_fseek(fp, stream_object_addr + 80, SEEK_SET);
+    ID3_fread(tmp, sizeof(char), 10, fp);
+    extra_tag->channel = (unsigned int) ((unsigned char) (tmp[0]) +((unsigned char) tmp[1] * 0x100));
+    memcpy(&(extra_tag->sample_rate), tmp + 2, 4);
+    //     printf("%d\n",extra_tag->sample_rate);
+    memcpy(&(extra_tag->bitrate), tmp + 6, 4);
+    //     printf("%d\n",extra_tag->bitrate);
+    return;
+}
+
+void get_wma_audio_info(void *fp, id3_info_total* info)
+{
+    memset(info, 0, sizeof(id3_info_total));
+
+    get_wmatag(fp, &info->tag);
+    get_wmatag1(fp, &info->tag);
+    //get_wma_extra_info(fp,&info->extra_info);
+}
+}
diff --git a/media/libstagefright/vendor/al_libc/Android.mk b/media/libstagefright/vendor/al_libc/Android.mk
new file mode 100755
index 0000000..4010a31
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/Android.mk
@@ -0,0 +1,39 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    al_libc.c 					\
+    al_uconv.c 					\
+    al_detect.cpp 				\
+    SinoDetect.cpp
+
+LOCAL_C_INCLUDES := \
+        $(call include-path-for, alsp) \
+        $(TOP)/frameworks/av/include/alsp/inc \
+        $(TOP)/system/core/include/ion \
+        $(TOP)/external/icu4c/common
+
+LOCAL_SHARED_LIBRARIES := 	\
+    libutils 				\
+    libcutils 				\
+    libicuuc 				\
+    libion
+                
+LOCAL_MODULE_TAGS := optional
+LOCAL_PRELINK_MODULE := false
+
+LOCAL_MODULE:= libalc
+
+include $(BUILD_SHARED_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    al_libc.c
+
+LOCAL_C_INCLUDES := \
+    $(call include-path-for, alsp) \
+    $(TOP)/frameworks/av/include/alsp/inc \
+    $(TOP)/system/core/include/ion
+
+LOCAL_MODULE:= libalc
+include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/vendor/al_libc/SinoDetect.cpp b/media/libstagefright/vendor/al_libc/SinoDetect.cpp
new file mode 100755
index 0000000..4701e54
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/SinoDetect.cpp
@@ -0,0 +1,4682 @@
+#include <actal_posix_dev.h>
+#include "SinoDetect.h"
+
+#define debug 0
+#define maxfreq 500
+#define minfreq 200
+
+/*
+ SinoDetect.cpp
+ C++ class to detect encoding of an unsigned char* array
+ Works for
+ Chinese:  GB, GBK, GB18030, HZ, Big5, Big5+, EUC-TW, ISO 2022-CN
+ Korean:   EUC-KR, Cp949, ISO 2022-KR
+ Japanese: EUC-JP, SJIS, ISO 2022-JP
+ General:  UTF-8, UTF-16
+ Written by Erik Peterson, erik@mandarintools.com
+ Last update July, 2006
+ License fee required for commercial use
+ */
+
+/* Function  :  detect_encoding
+ Aruguments:  pointer to unsigned char array
+ Returns   :  One of the encodings from the Encoding enumeration
+ (GB2312, GBK, HZ, BIG5, BIG5PLUS, EUC_TW, UTF8, UTF16, ASCII, or OTHER)
+ Description: This function looks at the unsigned char array
+ and assigns it a probability score for each encoding type.
+ The encoding type with the highest probability is returned.
+ */
+SinoDetect::SinoDetect() {
+	// Initialize the Frequency Table for GB, Big5, EUC-TW
+	initialize_frequencies();
+}
+
+SinoDetect::~SinoDetect() {
+}
+/*
+int SinoDetect::detect_encoding(FILE *srcfile) {
+	int size = 2 * 1024 * 1024;
+
+	fseek(srcfile, 0L, SEEK_END);
+	long filelen = ftell(srcfile);
+	fseek(srcfile, 0L, SEEK_SET);
+	if (filelen < size) {
+		size = filelen;
+	}
+
+	char subchar[size];
+	fread(subchar, 1, size, srcfile);
+
+	return detect_encoding((unsigned char *) subchar);
+}
+*/
+int SinoDetect::detect_encoding(unsigned char* rawtext) {
+	int scores[TOTAL_ENCODINGS];
+	int index, maxscore = 0;
+	enum Encodings encoding_guess = OTHER;
+
+	// Assign Scores
+	//  scores[GB2312]      = gb2312_probability(rawtext);
+	scores[GBK] = gbk_probability(rawtext);
+
+	//  scores[GB18030]     = gb18030_probability(rawtext);
+	//  scores[HZ]          = hz_probability(rawtext);
+	scores[BIG5] = big5_probability(rawtext);
+
+	//  scores[BIG5PLUS]    = big5plus_probability(rawtext);
+	//  scores[EUC_TW]      = euc_tw_probability(rawtext);
+	//  scores[ISO_2022_CN] = iso_2022_cn_probability(rawtext);
+	//  scores[UTF8]        = utf8_probability(rawtext);
+	//  scores[UTF16]       = utf16_probability(rawtext);
+
+	scores[EUC_KR] = euc_kr_probability(rawtext);
+
+	//  scores[CP949]       = cp949_probability(rawtext);
+	//  scores[JOHAB]       = 0;
+	//  scores[ISO_2022_KR]   = iso_2022_kr_probability(rawtext);
+
+	scores[SJIS] = sjis_probability(rawtext);
+
+	scores[EUC_JP] = euc_jp_probability(rawtext);
+
+	//  scores[ISO_2022_JP]   = iso_2022_jp_probability(rawtext);
+
+	//  scores[ASCII]       = ascii_probability(rawtext);
+	scores[OTHER] = 0;
+
+	// Tabulate Scores
+	for (index = 0; index < TOTAL_ENCODINGS; index++) {
+		if (debug) {
+			fprintf(stderr, "%d\n", scores[index]);
+		}
+		if (scores[index] > maxscore) {
+			encoding_guess = (enum Encodings) index;
+			maxscore = scores[index];
+		}
+	}
+
+	// Return OTHER if nothing scored above 50
+	if (maxscore <= 50) {
+		encoding_guess = OTHER;
+	}
+
+	return encoding_guess;
+}
+
+/* Function:  gb2312_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses GB-2312 encoding
+ */
+
+/*
+ int SinoDetect::gb2312_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+
+ int dbchars = 1, gbchars = 1;
+ long gbfreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Stage 1:  Check to see if characters fit into acceptable ranges
+
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ if (rawtext[i] <= 0x7E) {
+ //asciichars++;
+ } else {
+ dbchars++;
+ if (0xA1 <= rawtext[i] && rawtext[i] <= 0xF7 &&
+ 0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)
+ {
+ gbchars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0xA1;
+ column = rawtext[i+1] - 0xA1;
+ if (GBFreq[row][column] != 0) {
+ gbfreq += GBFreq[row][column];
+ } else if (15 <= row && row < 55) {
+ gbfreq += minfreq;
+ }
+ }
+ i++;
+ }
+ }
+ rangeval = 50 * ((float)gbchars/(float)dbchars);
+ freqval = 50 * ((float)gbfreq/(float)totalfreq);
+
+ return (int)(rangeval + freqval);
+ }
+ */
+
+/* Function:  gbk_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses GBK encoding
+ */
+
+int SinoDetect::gbk_probability(unsigned char* rawtext) {
+	int i, rawtextlen = 0;
+
+	int dbchars = 1, gbchars = 1;
+	long gbfreq = 0, totalfreq = 1;
+	float rangeval = 0, freqval = 0;
+	int row, column;
+
+	// Stage 1:  Check to see if characters fit into acceptable ranges
+	rawtextlen = strlen((char*) rawtext);
+	for (i = 0; i < rawtextlen - 1; i++) {
+		//System.err.println(rawtext[i]);
+		if (rawtext[i] <= 0x7E) {
+			//asciichars++;
+		} else {
+			dbchars++;
+			if (0xA1 <= rawtext[i] && rawtext[i] <= 0xF7 && // Original GB range
+					0xA1 <= rawtext[i + 1] && rawtext[i + 1] <= 0xFE) {
+				gbchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i] - 0xA1;
+				column = rawtext[i + 1] - 0xA1;
+
+				//System.out.println("original row " + row + " column " + column);
+				if (GBFreq[row][column] != 0) {
+					gbfreq += GBFreq[row][column];
+				} else if (15 <= row && row < 55) {
+					gbfreq += minfreq;
+				}
+
+			} else if ((i + 1 < rawtextlen) && (0x81 <= rawtext[i]
+					&& rawtext[i] <= 0xFE) && // Extended GB range
+					((0x40 <= rawtext[i + 1] && rawtext[i + 1] <= 0x7E)
+							|| (0x80 <= rawtext[i + 1] && rawtext[i + 1]
+									<= 0xFE))) {
+				gbchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i] - 0x81;
+				if (0x40 <= rawtext[i + 1] && rawtext[i + 1] <= 0x7E) {
+					column = rawtext[i + 1] - 0x40;
+				} else {
+					column = rawtext[i + 1] - 0x40;
+				}
+				//System.out.println("extended row " + row + " column " + column + " rawtext[i] " + rawtext[i]);
+				if (GBKFreq[row][column] != 0) {
+					gbfreq += GBKFreq[row][column];
+				}
+			}
+			i++;
+		}
+	}
+	rangeval = 50 * ((float) gbchars / (float) dbchars);
+	freqval = 50 * ((float) gbfreq / (float) totalfreq);
+
+	// For regular GB files, this would give the same score, so I handicap it slightly
+	return (int) (rangeval + freqval) - 1;
+}
+
+/* Function:  gb18030_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses GB18030 encoding
+ */
+/*
+ int SinoDetect::gb18030_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+
+ int dbchars = 1, gbchars = 1;
+ long gbfreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Stage 1:  Check to see if characters fit into acceptable ranges
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ //System.err.println(rawtext[i]);
+ if (rawtext[i] <= 0x7E) {
+ //asciichars++;
+ } else {
+ dbchars++;
+ if (0xA1 <= rawtext[i] && rawtext[i] <= 0xF7 &&   // Original GB range
+ 0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)
+ {
+ gbchars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0xA1;
+ column = rawtext[i+1] - 0xA1;
+
+ //System.out.println("original row " + row + " column " + column);
+ if (GBFreq[row][column] != 0) {
+ gbfreq += GBFreq[row][column];
+ } else if (15 <= row && row < 55) {
+ gbfreq += minfreq;
+ }
+
+ }
+ else if ((i + 1 < rawtextlen) &&
+ (0x81 <= rawtext[i] && rawtext[i] <= 0xFE) &&   // Extended GB range
+ ((0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) ||
+ (0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)))
+ {
+ gbchars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0x81;
+ if (0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) {
+ column = rawtext[i+1] - 0x40;
+ } else {
+ column = rawtext[i+1] - 0x40;
+ }
+ //System.out.println("extended row " + row + " column " + column + " rawtext[i] " + rawtext[i]);
+ if (GBKFreq[row][column] != 0) {
+ gbfreq += GBKFreq[row][column];
+ }
+ }
+ else if ((i + 3 < rawtextlen) &&
+ 0x81 <= rawtext[i] && rawtext[i] <= 0xFE &&   // Extended GB range
+ 0x30 <= rawtext[i+1] && rawtext[i+1] <= 0x39 &&
+ 0x81 <= rawtext[i+2] && rawtext[i+2] <= 0xFE &&   // Extended GB range
+ 0x30 <= rawtext[i+3] && rawtext[i+3] <= 0x39 )
+ {
+ gbchars++;
+ //  totalfreq += maxfreq;
+ //  row = rawtext[i] - 0x81;
+ //  if (0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) {
+ //    column = rawtext[i+1] - 0x40;
+ //  } else {
+ //    column = rawtext[i+1] - 0x40;
+ //  }
+ //System.out.println("extended row " + row + " column " + column + " rawtext[i] " + rawtext[i]);
+ //  if (GBKFreq[row][column] != 0) {
+ //    gbfreq += GBKFreq[row][column];
+ //  }
+
+ i+=2;
+ }
+ i++;
+ }
+ }
+ rangeval = 50 * ((float)gbchars/(float)dbchars);
+ freqval = 50 * ((float)gbfreq/(float)totalfreq);
+
+ // For regular GB files, this would give the same score, so I handicap it slightly
+ return (int)(rangeval + freqval) - 1;
+ }
+ */
+
+/* Function:  hz_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses HZ encoding
+ */
+/*
+ int SinoDetect::hz_probability(unsigned char* rawtext) {
+ int i, rawtextlen;
+ int hzchars = 0, dbchars = 1;
+ long hzfreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int hzstart = 0, hzend = 0;
+ int row, column;
+
+ rawtextlen = strlen((char*)rawtext);
+
+ for (i = 0; i < rawtextlen; i++) {
+ if (rawtext[i] == '~') {
+ if (rawtext[i+1] == '{') {
+ hzstart++;
+ i+=2;
+ while (i < rawtextlen - 1) {
+ if (rawtext[i] == 0x0A || rawtext[i] == 0x0D) {
+ break;
+ } else if (rawtext[i] == '~' && rawtext[i+1] == '}') {
+ hzend++;
+ i++;
+ break;
+ } else if ((0x21 <= rawtext[i] && rawtext[i] <= 0x77) &&
+ (0x21 <= rawtext[i+1] && rawtext[i+1] <= 0x77)) {
+ hzchars+=2;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0x21;
+ column = rawtext[i+1] - 0x21;
+ if (GBFreq[row][column] != 0) {
+ hzfreq += GBFreq[row][column];
+ } else if (15 <= row && row < 55) {
+ hzfreq += minfreq;
+ }
+ } else if ((0xA1 <= rawtext[i] && rawtext[i] <= 0xF7) &&
+ (0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xF7)) {
+ hzchars+=2;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0xA1;
+ column = rawtext[i+1] - 0xA1;
+ if (GBFreq[row][column] != 0) {
+ hzfreq += GBFreq[row][column];
+ } else if (15 <= row && row < 55) {
+ hzfreq += minfreq;
+ }
+ }
+ dbchars+=2;
+ i+=2;
+ }
+ } else if (rawtext[i+1] == '}') {
+ hzend++;
+ i++;
+ } else if (rawtext[i+1] == '~') {
+ i++;
+ }
+ }
+
+ }
+
+ if (hzstart > 4) {
+ rangeval = 50;
+ } else if (hzstart > 1) {
+ rangeval = 41;
+ } else if (hzstart > 0) { // Only 39 in case the sequence happened to occur
+ rangeval = 39; 	      // in otherwise non-Hz text
+ } else {
+ rangeval = 0;
+ }
+ freqval = 50 * ((float)hzfreq/(float)totalfreq);
+
+ return (int)(rangeval + freqval);
+ }
+ */
+
+/* Function:  big5_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses Big5 encoding
+ */
+
+int SinoDetect::big5_probability(unsigned char* rawtext) {
+	int score = 0;
+	int i, rawtextlen = 0;
+	int dbchars = 1, bfchars = 1;
+	float rangeval = 0, freqval = 0;
+	long bffreq = 0, totalfreq = 1;
+	int row, column;
+
+	// Check to see if characters fit into acceptable ranges
+
+	rawtextlen = strlen((char*) rawtext);
+	for (i = 0; i < rawtextlen - 1; i++) {
+		if (rawtext[i] <= 0x7E) {
+			//asciichars++;
+		} else {
+			dbchars++;
+			if (0xA1 <= rawtext[i] && rawtext[i] <= 0xF9 && ((0x40 <= rawtext[i
+					+ 1] && rawtext[i + 1] <= 0x7E) || (0xA1 <= rawtext[i + 1]
+					&& rawtext[i + 1] <= 0xFE))) {
+				bfchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i] - 0xA1;
+				if (0x40 <= rawtext[i + 1] && rawtext[i + 1] <= 0x7E) {
+					column = rawtext[i + 1] - 0x40;
+				} else {
+					column = rawtext[i + 1] - 0x61;
+				}
+
+				if (Big5Freq[row][column] != 0) {
+					bffreq += Big5Freq[row][column];
+				} else if (3 <= row && row <= 37) {
+					bffreq += minfreq;
+				}
+			}
+			i++;
+		}
+	}
+	rangeval = 50 * ((float) bfchars / (float) dbchars);
+	freqval = 50 * ((float) bffreq / (float) totalfreq);
+
+	return (int) (rangeval + freqval);
+}
+
+/* Function:  big5plus_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses Big5+ encoding
+ */
+/*
+ int SinoDetect::big5plus_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+
+ int dbchars = 1, bfchars = 1;
+ long bffreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Stage 1:  Check to see if characters fit into acceptable ranges
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ //System.err.println(rawtext[i]);
+ if (rawtext[i] <= 0x7E) {
+ //asciichars++;
+ } else {
+ dbchars++;
+ if (0xA1 <= rawtext[i] && rawtext[i] <= 0xF9 &&    // Original Big5 range
+ ((0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) ||
+ (0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)))
+ {
+ bfchars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0xA1;
+ if (0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) {
+ column = rawtext[i+1] - 0x40;
+ } else {
+ column = rawtext[i+1] - 0x61;
+ }
+
+ //System.out.println("original row " + row + " column " + column);
+ if (Big5Freq[row][column] != 0) {
+ bffreq += Big5Freq[row][column];
+ } else if (3 <= row && row < 37) {
+ bffreq += minfreq;
+ }
+
+ }
+ else if (0x81 <= rawtext[i] && rawtext[i] <= 0xFE &&   // Extended Big5 range
+ ((0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) ||
+ (0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)))
+ {
+ bfchars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0x81;
+ if (0x40 <= rawtext[i+1] && rawtext[i+1] <= 0x7E) {
+ column = rawtext[i+1] - 0x40;
+ } else {
+ column = rawtext[i+1] - 0x40;
+ }
+ //System.out.println("extended row " + row + " column " + column + " rawtext[i] " + rawtext[i]);
+ if (Big5PFreq[row][column] != 0) {
+ bffreq += Big5PFreq[row][column];
+ }
+ }
+ i++;
+ }
+ }
+
+ rangeval = 50 * ((float)bfchars/(float)dbchars);
+ freqval = 50 * ((float)bffreq/(float)totalfreq);
+
+ // For regular Big5 files, this would give the same score, so I handicap it slightly
+ return (int)(rangeval + freqval) - 1;
+ }
+ */
+
+/* Function:  euc_tw_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses EUC-TW (CNS 11643) encoding
+ */
+/*
+ int SinoDetect::euc_tw_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+ int dbchars = 1, cnschars = 1;
+ long cnsfreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Check to see if characters fit into acceptable ranges
+ // and have expected frequency of use
+
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ if (rawtext[i] <= 0x7E) {
+ //asciichars++;
+ } else {
+ dbchars++;
+ if (i + 3 < rawtextlen && 0x8E == rawtext[i] &&
+ 0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xB0 &&
+ 0xA1 <= rawtext[i+2] && rawtext[i+2] <= 0xFE &&
+ 0xA1 <= rawtext[i+3] && rawtext[i+3] <= 0xFE) { // Planes 1 - 16
+
+ cnschars++;
+ //System.out.println("plane 2 or above CNS char");
+ // These are all less frequent chars so just ignore freq
+ i+=3;
+ } else if (i+1 < rawtextlen &&
+ 0xA1 <= rawtext[i] && rawtext[i] <= 0xFE &&
+ 0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)
+ {
+ cnschars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0xA1;
+ column = rawtext[i+1] - 0xA1;
+ if (EUC_TWFreq[row][column] != 0) {
+ cnsfreq += EUC_TWFreq[row][column];
+ } else if (35 <= row && row <= 92) {
+ cnsfreq += 150;
+ }
+ }
+ i++;
+ }
+ }
+ rangeval = 50 * ((float)cnschars/(float)dbchars);
+ freqval = 50 * ((float)cnsfreq/(float)totalfreq);
+
+ return (int)(rangeval + freqval);
+ }
+ */
+
+/* Function:  iso_2022_cn_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses ISO 2022-CN encoding
+ */
+/*
+ int SinoDetect::iso_2022_cn_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+ int dbchars = 1, isochars = 1;
+ long isofreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Check to see if characters fit into acceptable ranges
+ // and have expected frequency of use
+
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ if (rawtext[i] == 0x1B && i+3 < rawtextlen) { // Escape char ESC
+ if (rawtext[i+1] == 0x24 && rawtext[i+2] == 0x29 &&
+ rawtext[i+3] == 0x41) {  // GB Escape  $ ) A
+ i += 4;
+ while (rawtext[i] != 0x1B) {
+ dbchars++;
+ if ((0x21 <= rawtext[i] && rawtext[i] <= 0x77) &&
+ (0x21 <= rawtext[i+1] && rawtext[i+1] <= 0x77)) {
+ isochars++;
+ row = rawtext[i] - 0x21;
+ column = rawtext[i+1] - 0x21;
+ totalfreq += maxfreq;
+ if (GBFreq[row][column] != 0) {
+ isofreq += GBFreq[row][column];
+ } else if (15 <= row && row < 55) {
+ isofreq += minfreq;
+ }
+ i++;
+ }
+ i++;
+ }
+ } else if (i+3 < rawtextlen &&
+ rawtext[i+1] == 0x24 && rawtext[i+2] == 0x29 &&
+ rawtext[i+3] == 0x47) {
+ // CNS Escape $ ) G
+ i+=4;
+ while (rawtext[i] != 0x1B) {
+ dbchars++;
+ if (0x21 <= rawtext[i] && rawtext[i] <= 0x7E &&
+ 0x21 <= rawtext[i+1] && rawtext[i+1] <= 0x7E)
+ {
+ isochars++;
+ totalfreq += maxfreq;
+ row = rawtext[i] - 0x21;
+ column = rawtext[i+1] - 0x21;
+ if (EUC_TWFreq[row][column] != 0) {
+ isofreq += EUC_TWFreq[row][column];
+ } else if (35 <= row && row <= 92) {
+ isofreq += 150;
+ }
+ i++;
+ }
+ i++;
+ }
+ }
+ if (rawtext[i] == 0x1B && i+2 < rawtextlen &&
+ rawtext[i+1] == 0x28 && rawtext[i+2] == 0x42) { // ASCII:  ESC ( B
+ i+=2;
+ }
+ }
+ }
+ rangeval = 50 * ((float)isochars/(float)dbchars);
+ freqval = 50 * ((float)isofreq/(float)totalfreq);
+
+ //System.out.println("isochars dbchars isofreq totalfreq " + isochars + " " + dbchars + " " + isofreq + " " + totalfreq + " " + rangeval + " " + freqval);
+
+ return (int)(rangeval + freqval);
+
+ }
+ */
+
+/* Function:  utf8_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses UTF-8 encoding of Unicode
+ */
+/*
+ int SinoDetect::utf8_probability(unsigned char* rawtext) {
+ int score = 0;
+ int i, rawtextlen = 0;
+ int dbchars = 1, utf8chars = 1;
+ int goodbytes = 0, asciibytes = 0;
+ long totalfreq = 1, utf8freq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+
+ // Maybe also use UTF8 Byte Order Mark:  EF BB BF
+
+ // Check to see if characters fit into acceptable ranges
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen; i++) {
+ if ((rawtext[i] & 0x7F) == rawtext[i]) {  // One byte
+ asciibytes++;
+ // Ignore ASCII, can throw off count
+ } else if (0xC0 <= rawtext[i] && rawtext[i] <= 0xDF && // Two bytes
+ i+1 < rawtextlen &&
+ 0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xBF) {
+ goodbytes += 2;
+ i++;
+ } else if (0xE0 <= rawtext[i] && rawtext[i] <= 0xEF && // Three bytes
+ i+2 < rawtextlen &&
+ 0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xBF &&
+ 0x80 <= rawtext[i+2] && rawtext[i+2] <= 0xBF) {
+ goodbytes += 3;
+ i+=2;
+ }
+ }
+
+
+ if (asciibytes == rawtextlen) { return ASCII; }
+
+ score = (int)(100 * ((float)goodbytes/(float)(rawtextlen-asciibytes)));
+ //System.out.println("rawtextlen " + rawtextlen + " goodbytes " + goodbytes + " asciibytes " + asciibytes + " score " + score);
+
+
+ // If not above 98, reduce to zero to prevent coincidental matches
+ // Allows for some (few) bad formed sequences
+ if (score > 98) {
+ return score;
+ } else if (score > 95 && goodbytes > 30) {
+ return score;
+ } else {
+ return 0;
+ }
+
+
+ //  Check to see if characters fit into acceptable ranges
+ //  and have expected frequency of use
+
+ //  rawtextlen = strlen((char*)rawtext);
+ //  for (i = 0; i < rawtextlen-2; i++) {
+ //    if ((unsigned char)rawtext[i] <= 0x7E) {
+ //      //asciichars++;
+ //    } else {
+ //      dbchars++;
+ //
+ //      if (0xC0 <= rawtext[i] && rawtext[i] <= 0xDF) {
+ //	if (0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xBF) {
+ //	  utf8chars++;
+ //	  i++;
+ //	}
+ //      } else if (0xE0 <= rawtext[i] && rawtext[i] <= 0xEF) {
+ //	if (0x80 <= rawtext[i+1] && rawtext[i+1] <= 0xBF) {
+ //	  if (0x80 <= rawtext[i+2] && rawtext[i+2] <= 0xBF) {
+ //	    utf8chars++;
+ //
+ //	    totalfreq += maxfreq;
+ //	    // Find row/column for UCS2
+ //	    row = rawtext[i] - 0xA1;
+ //	    column = rawtext[i+1] - 0xA1;
+ //	    //utf8freq += UniFreq[row][column];
+ //
+ //	    i += 2;
+ //	  }
+ //	}
+ //      }
+ //    }
+ //
+ //  }
+ //  rangeval = 50 * ((float)utf8chars/(float)dbchars);
+ //  freqval = 50 * ((float)utf8freq/(float)totalfreq);
+ //
+ //  return (int)(rangeval+freqval)
+
+ }
+ */
+
+/* Function:  utf16_probability
+ Argument:  byte array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses UTF-16 encoding of Unicode, guess based on BOM
+ // NOT VERY GENERAL, NEEDS MUCH MORE WORK
+ */
+/*
+ int SinoDetect::utf16_probability(unsigned char* rawtext) {
+
+ if ((0xFE == rawtext[0] && 0xFF == rawtext[1]) ||  // Big-endian
+ (0xFF == rawtext[0] && 0xFE == rawtext[1])) {  // Little-endian
+ return 100;
+ }
+
+ return 0;
+
+ }
+ */
+
+/* Function:  ascii_probability
+ Argument:  pointer to unsigned char array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses UTF-8 encoding of Unicode
+ Description:  Sees if array has any characters not in
+ ASCII range, if so, score is reduced
+ */
+/*
+ int SinoDetect::ascii_probability(unsigned char* rawtext) {
+ int score = 70;
+ int i, rawtextlen;
+
+ rawtextlen = strlen((char*) rawtext);
+
+ for (i = 0; i < rawtextlen; i++) {
+ if (rawtext[i] > 0x7E) {
+ score -= 10;
+ } else if (rawtext[i] == 0x1b) {
+ score -= 5;
+ }
+ if (score < 0) return 0;
+ }
+
+ return score;
+ }
+ */
+
+/* Function:  euc_kr__probability
+ Argument:  pointer to byte array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses EUC-KR encoding
+ */
+
+int SinoDetect::euc_kr_probability(unsigned char* rawtext) {
+	int i, rawtextlen = 0;
+
+	int dbchars = 1, krchars = 1;
+	long krfreq = 0, totalfreq = 1;
+	float rangeval = 0, freqval = 0;
+	int row, column;
+
+	// Stage 1:  Check to see if characters fit into acceptable ranges
+
+	rawtextlen = strlen((char*) rawtext);
+	for (i = 0; i < rawtextlen - 1; i++) {
+		//System.err.println(rawtext[i]);
+		if (rawtext[i] <= 0x7E) {
+			//asciichars++;
+		} else {
+			dbchars++;
+			if (0xA1 <= rawtext[i] && rawtext[i] <= 0xFE && 0xA1 <= rawtext[i
+					+ 1] && rawtext[i + 1] <= 0xFE) {
+				krchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i] - 0xA1;
+				column = rawtext[i + 1] - 0xA1;
+				if (KRFreq[row][column] != 0) {
+					krfreq += KRFreq[row][column];
+				} else if (15 <= row && row < 55) {
+					krfreq += 0;
+				}
+
+			}
+			i++;
+		}
+	}
+	rangeval = 50 * ((float) krchars / (float) dbchars);
+	freqval = 50 * ((float) krfreq / (float) totalfreq);
+
+	return (int) (rangeval + freqval);
+}
+
+/* Function:  cp949__probability
+ Argument:  pointer to byte array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses Cp949 encoding
+ */
+/*
+ int SinoDetect::cp949_probability(unsigned char* rawtext) {
+ int i, rawtextlen = 0;
+
+ int dbchars = 1, krchars = 1;
+ long krfreq = 0, totalfreq = 1;
+ float rangeval = 0, freqval = 0;
+ int row, column;
+
+ // Stage 1:  Check to see if characters fit into acceptable ranges
+ rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen-1; i++) {
+ //System.err.println(rawtext[i]);
+ if (rawtext[i] <= 0x7E) {
+ //asciichars++;
+ } else {
+ dbchars++;
+ if (0x81 <= rawtext[i] && rawtext[i] <= 0xFE &&
+ ((0x41 <= rawtext[i+1] && (rawtext[i+1] <= 0x5A)) ||
+ (0x61 <= rawtext[i+1] && rawtext[i+1] <= 0x7A) ||
+ (0x81 <= rawtext[i+1] && rawtext[i+1] <= 0xFE)))
+ {
+ krchars++;
+ totalfreq += maxfreq;
+ if (0xA1 <= rawtext[i] && rawtext[i] <= 0xFE &&
+ 0xA1 <= rawtext[i+1] && rawtext[i+1] <= 0xFE) {
+ row = rawtext[i] - 0xA1;
+ column = rawtext[i+1] - 0xA1;
+ if (KRFreq[row][column] != 0) {
+ krfreq += KRFreq[row][column];
+ }
+ }
+ }
+ i++;
+ }
+ }
+ rangeval = 50 * ((float)krchars/(float)dbchars);
+ freqval = 50 * ((float)krfreq/(float)totalfreq);
+
+ return (int)(rangeval + freqval);
+ }
+ */
+
+/*
+ int SinoDetect::iso_2022_kr_probability(unsigned char* rawtext) {
+ int i;
+ int rawtextlen = strlen((char*) rawtext);
+ for (i = 0; i < rawtextlen; i++) {
+ if (i+3 < rawtextlen &&
+ rawtext[i] == 0x1B && // ESC
+ (char)rawtext[i+1] == '$' &&
+ (char)rawtext[i+2] == ')' &&
+ (char)rawtext[i+3] == 'C') {
+ return 100;
+ }
+ }
+ return 0;
+ }
+ */
+
+/* Function:  euc_jp_probability
+ Argument:  pointer to byte array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses EUC-JP encoding
+ */
+
+int SinoDetect::euc_jp_probability(unsigned char* rawtext) {
+	int i, rawtextlen = 0;
+
+	int dbchars = 1, jpchars = 1;
+	long jpfreq = 0, totalfreq = 1;
+	float rangeval = 0, freqval = 0;
+	int row, column;
+
+	// Stage 1:  Check to see if characters fit into acceptable ranges
+
+	rawtextlen = strlen((char*) rawtext);
+	for (i = 0; i < rawtextlen - 1; i++) {
+		//System.err.println(rawtext[i]);
+		if (rawtext[i] <= 0x7E) {
+			//asciichars++;
+		} else {
+			dbchars++;
+			if (0xA1 <= rawtext[i] && rawtext[i] <= 0xFE && 0xA1 <= rawtext[i
+					+ 1] && rawtext[i + 1] <= 0xFE) {
+				jpchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i] - 0xA1;
+				column = rawtext[i + 1] - 0xA1;
+				if (JPFreq[row][column] != 0) {
+					jpfreq += JPFreq[row][column];
+				} else if (15 <= row && row < 55) {
+					jpfreq += 0;
+				}
+
+			}
+			i++;
+		}
+	}
+	rangeval = 50 * ((float) jpchars / (float) dbchars);
+	freqval = 50 * ((float) jpfreq / (float) totalfreq);
+
+	return (int) (rangeval + freqval);
+}
+
+/*
+ int SinoDetect::iso_2022_jp_probability(unsigned char* rawtext) {
+ int i;
+ int rawtextlen = strlen((char*)rawtext);
+ for (i = 0; i < rawtextlen; i++) {
+ if (i+2 < rawtextlen &&
+ rawtext[i] == 0x1b &&
+ (char)rawtext[i+1] == '$' &&
+ (char)rawtext[i+2] == 'B') {
+ return 100;
+ }
+ }
+ return 0;
+ }
+ */
+
+/* Function:  sjis_probability
+ Argument:  pointer to byte array
+ Returns :  number from 0 to 100 representing probability
+ text in array uses Shift-JIS encoding
+ */
+
+int SinoDetect::sjis_probability(unsigned char* rawtext) {
+	int i, rawtextlen = 0;
+
+	int dbchars = 1, jpchars = 1;
+	long jpfreq = 0, totalfreq = 1;
+	float rangeval = 0, freqval = 0;
+	int row, column, adjust;
+
+	// Stage 1:  Check to see if characters fit into acceptable ranges
+	rawtextlen = strlen((char*) rawtext);
+	for (i = 0; i < rawtextlen - 1; i++) {
+		//System.err.println(rawtext[i]);
+		if (rawtext[i] <= 0x7E) {
+			//asciichars++;
+		} else {
+			dbchars++;
+			if (i + 1 < rawtextlen && ((0x81 <= rawtext[i] && rawtext[i]
+					<= 0x9F) || (0xE0 <= rawtext[i] && rawtext[i] <= 0xEF))
+					&& ((0x40 <= rawtext[i + 1] && rawtext[i + 1] <= 0x7E)
+							|| (0x80 <= rawtext[i + 1] && rawtext[i + 1]
+									<= 0xFC))) {
+				jpchars++;
+				totalfreq += maxfreq;
+				row = rawtext[i];
+				column = rawtext[i + 1];
+				if (column < 0x9f) {
+					adjust = 1;
+					if (column > 0x7f) {
+						column -= 0x20;
+					} else {
+						column -= 0x19;
+					}
+				} else {
+					adjust = 0;
+					column -= 0x7e;
+				}
+				if (row < 0xa0) {
+					row = ((row - 0x70) << 1) - adjust;
+				} else {
+					row = ((row - 0xb0) << 1) - adjust;
+				}
+
+				row -= 0x20;
+				column = 0x20;
+
+				//System.out.println("original row " + row + " column " + column);
+				if (row < 93 && column < 93 && JPFreq[row][column] != 0) {
+					jpfreq += JPFreq[row][column];
+				}
+				i++;
+			} else if (0xA1 <= rawtext[i] && rawtext[i] <= 0xDF) {
+				// half-width katakana, convert to full-width
+			}
+
+		}
+	}
+	rangeval = 50 * ((float) jpchars / (float) dbchars);
+	freqval = 50 * ((float) jpfreq / (float) totalfreq);
+
+	return (int) (rangeval + freqval);
+}
+
+void SinoDetect::initialize_frequencies() {
+	int i, j;
+
+	for (i = 0; i < 94; i++) {
+		for (j = 0; j < 94; j++) {
+			GBFreq[i][j] = 0;
+		}
+	}
+
+	for (i = 0; i < 126; i++) {
+		for (j = 0; j < 191; j++) {
+			GBKFreq[i][j] = 0;
+		}
+	}
+
+	for (i = 0; i < 94; i++) {
+		for (j = 0; j < 158; j++) {
+			Big5Freq[i][j] = 0;
+		}
+	}
+	/*
+	 for (i = 0; i < 126; i++) {
+	 for (j = 0; j < 191; j++) {
+	 Big5PFreq[i][j] = 0;
+	 }
+	 }
+	 */
+	/*
+	 for (i = 0; i < 94; i++) {
+	 for (j = 0; j < 94; j++) {
+	 EUC_TWFreq[i][j] = 0;
+	 }
+	 }
+	 */
+	for (i = 0; i < 94; i++) {
+		for (j = 0; j < 94; j++) {
+			KRFreq[i][j] = 0;
+		}
+	}
+
+	for (i = 0; i < 94; i++) {
+		for (j = 0; j < 94; j++) {
+			JPFreq[i][j] = 0;
+		}
+	}
+
+	GBFreq[20][35] = 599;
+	GBFreq[49][26] = 598;
+	GBFreq[41][38] = 597;
+	GBFreq[17][26] = 596;
+	GBFreq[32][42] = 595;
+	GBFreq[39][42] = 594;
+	GBFreq[45][49] = 593;
+	GBFreq[51][57] = 592;
+	GBFreq[50][47] = 591;
+	GBFreq[42][90] = 590;
+	GBFreq[52][65] = 589;
+	GBFreq[53][47] = 588;
+	GBFreq[19][82] = 587;
+	GBFreq[31][19] = 586;
+	GBFreq[40][46] = 585;
+	GBFreq[24][89] = 584;
+	GBFreq[23][85] = 583;
+	GBFreq[20][28] = 582;
+	GBFreq[42][20] = 581;
+	GBFreq[34][38] = 580;
+	GBFreq[45][9] = 579;
+	GBFreq[54][50] = 578;
+	GBFreq[25][44] = 577;
+	GBFreq[35][66] = 576;
+	GBFreq[20][55] = 575;
+	GBFreq[18][85] = 574;
+	GBFreq[20][31] = 573;
+	GBFreq[49][17] = 572;
+	GBFreq[41][16] = 571;
+	GBFreq[35][73] = 570;
+	GBFreq[20][34] = 569;
+	GBFreq[29][44] = 568;
+	GBFreq[35][38] = 567;
+	GBFreq[49][9] = 566;
+	GBFreq[46][33] = 565;
+	GBFreq[49][51] = 564;
+	GBFreq[40][89] = 563;
+	GBFreq[26][64] = 562;
+	GBFreq[54][51] = 561;
+	GBFreq[54][36] = 560;
+	GBFreq[39][4] = 559;
+	GBFreq[53][13] = 558;
+	GBFreq[24][92] = 557;
+	GBFreq[27][49] = 556;
+	GBFreq[48][6] = 555;
+	GBFreq[21][51] = 554;
+	GBFreq[30][40] = 553;
+	GBFreq[42][92] = 552;
+	GBFreq[31][78] = 551;
+	GBFreq[25][82] = 550;
+	GBFreq[47][0] = 549;
+	GBFreq[34][19] = 548;
+	GBFreq[47][35] = 547;
+	GBFreq[21][63] = 546;
+	GBFreq[43][75] = 545;
+	GBFreq[21][87] = 544;
+	GBFreq[35][59] = 543;
+	GBFreq[25][34] = 542;
+	GBFreq[21][27] = 541;
+	GBFreq[39][26] = 540;
+	GBFreq[34][26] = 539;
+	GBFreq[39][52] = 538;
+	GBFreq[50][57] = 537;
+	GBFreq[37][79] = 536;
+	GBFreq[26][24] = 535;
+	GBFreq[22][1] = 534;
+	GBFreq[18][40] = 533;
+	GBFreq[41][33] = 532;
+	GBFreq[53][26] = 531;
+	GBFreq[54][86] = 530;
+	GBFreq[20][16] = 529;
+	GBFreq[46][74] = 528;
+	GBFreq[30][19] = 527;
+	GBFreq[45][35] = 526;
+	GBFreq[45][61] = 525;
+	GBFreq[30][9] = 524;
+	GBFreq[41][53] = 523;
+	GBFreq[41][13] = 522;
+	GBFreq[50][34] = 521;
+	GBFreq[53][86] = 520;
+	GBFreq[47][47] = 519;
+	GBFreq[22][28] = 518;
+	GBFreq[50][53] = 517;
+	GBFreq[39][70] = 516;
+	GBFreq[38][15] = 515;
+	GBFreq[42][88] = 514;
+	GBFreq[16][29] = 513;
+	GBFreq[27][90] = 512;
+	GBFreq[29][12] = 511;
+	GBFreq[44][22] = 510;
+	GBFreq[34][69] = 509;
+	GBFreq[24][10] = 508;
+	GBFreq[44][11] = 507;
+	GBFreq[39][92] = 506;
+	GBFreq[49][48] = 505;
+	GBFreq[31][46] = 504;
+	GBFreq[19][50] = 503;
+	GBFreq[21][14] = 502;
+	GBFreq[32][28] = 501;
+	GBFreq[18][3] = 500;
+	GBFreq[53][9] = 499;
+	GBFreq[34][80] = 498;
+	GBFreq[48][88] = 497;
+	GBFreq[46][53] = 496;
+	GBFreq[22][53] = 495;
+	GBFreq[28][10] = 494;
+	GBFreq[44][65] = 493;
+	GBFreq[20][10] = 492;
+	GBFreq[40][76] = 491;
+	GBFreq[47][8] = 490;
+	GBFreq[50][74] = 489;
+	GBFreq[23][62] = 488;
+	GBFreq[49][65] = 487;
+	GBFreq[28][87] = 486;
+	GBFreq[15][48] = 485;
+	GBFreq[22][7] = 484;
+	GBFreq[19][42] = 483;
+	GBFreq[41][20] = 482;
+	GBFreq[26][55] = 481;
+	GBFreq[21][93] = 480;
+	GBFreq[31][76] = 479;
+	GBFreq[34][31] = 478;
+	GBFreq[20][66] = 477;
+	GBFreq[51][33] = 476;
+	GBFreq[34][86] = 475;
+	GBFreq[37][67] = 474;
+	GBFreq[53][53] = 473;
+	GBFreq[40][88] = 472;
+	GBFreq[39][10] = 471;
+	GBFreq[24][3] = 470;
+	GBFreq[27][25] = 469;
+	GBFreq[26][15] = 468;
+	GBFreq[21][88] = 467;
+	GBFreq[52][62] = 466;
+	GBFreq[46][81] = 465;
+	GBFreq[38][72] = 464;
+	GBFreq[17][30] = 463;
+	GBFreq[52][92] = 462;
+	GBFreq[34][90] = 461;
+	GBFreq[21][7] = 460;
+	GBFreq[36][13] = 459;
+	GBFreq[45][41] = 458;
+	GBFreq[32][5] = 457;
+	GBFreq[26][89] = 456;
+	GBFreq[23][87] = 455;
+	GBFreq[20][39] = 454;
+	GBFreq[27][23] = 453;
+	GBFreq[25][59] = 452;
+	GBFreq[49][20] = 451;
+	GBFreq[54][77] = 450;
+	GBFreq[27][67] = 449;
+	GBFreq[47][33] = 448;
+	GBFreq[41][17] = 447;
+	GBFreq[19][81] = 446;
+	GBFreq[16][66] = 445;
+	GBFreq[45][26] = 444;
+	GBFreq[49][81] = 443;
+	GBFreq[53][55] = 442;
+	GBFreq[16][26] = 441;
+	GBFreq[54][62] = 440;
+	GBFreq[20][70] = 439;
+	GBFreq[42][35] = 438;
+	GBFreq[20][57] = 437;
+	GBFreq[34][36] = 436;
+	GBFreq[46][63] = 435;
+	GBFreq[19][45] = 434;
+	GBFreq[21][10] = 433;
+	GBFreq[52][93] = 432;
+	GBFreq[25][2] = 431;
+	GBFreq[30][57] = 430;
+	GBFreq[41][24] = 429;
+	GBFreq[28][43] = 428;
+	GBFreq[45][86] = 427;
+	GBFreq[51][56] = 426;
+	GBFreq[37][28] = 425;
+	GBFreq[52][69] = 424;
+	GBFreq[43][92] = 423;
+	GBFreq[41][31] = 422;
+	GBFreq[37][87] = 421;
+	GBFreq[47][36] = 420;
+	GBFreq[16][16] = 419;
+	GBFreq[40][56] = 418;
+	GBFreq[24][55] = 417;
+	GBFreq[17][1] = 416;
+	GBFreq[35][57] = 415;
+	GBFreq[27][50] = 414;
+	GBFreq[26][14] = 413;
+	GBFreq[50][40] = 412;
+	GBFreq[39][19] = 411;
+	GBFreq[19][89] = 410;
+	GBFreq[29][91] = 409;
+	GBFreq[17][89] = 408;
+	GBFreq[39][74] = 407;
+	GBFreq[46][39] = 406;
+	GBFreq[40][28] = 405;
+	GBFreq[45][68] = 404;
+	GBFreq[43][10] = 403;
+	GBFreq[42][13] = 402;
+	GBFreq[44][81] = 401;
+	GBFreq[41][47] = 400;
+	GBFreq[48][58] = 399;
+	GBFreq[43][68] = 398;
+	GBFreq[16][79] = 397;
+	GBFreq[19][5] = 396;
+	GBFreq[54][59] = 395;
+	GBFreq[17][36] = 394;
+	GBFreq[18][0] = 393;
+	GBFreq[41][5] = 392;
+	GBFreq[41][72] = 391;
+	GBFreq[16][39] = 390;
+	GBFreq[54][0] = 389;
+	GBFreq[51][16] = 388;
+	GBFreq[29][36] = 387;
+	GBFreq[47][5] = 386;
+	GBFreq[47][51] = 385;
+	GBFreq[44][7] = 384;
+	GBFreq[35][30] = 383;
+	GBFreq[26][9] = 382;
+	GBFreq[16][7] = 381;
+	GBFreq[32][1] = 380;
+	GBFreq[33][76] = 379;
+	GBFreq[34][91] = 378;
+	GBFreq[52][36] = 377;
+	GBFreq[26][77] = 376;
+	GBFreq[35][48] = 375;
+	GBFreq[40][80] = 374;
+	GBFreq[41][92] = 373;
+	GBFreq[27][93] = 372;
+	GBFreq[15][17] = 371;
+	GBFreq[16][76] = 370;
+	GBFreq[51][12] = 369;
+	GBFreq[18][20] = 368;
+	GBFreq[15][54] = 367;
+	GBFreq[50][5] = 366;
+	GBFreq[33][22] = 365;
+	GBFreq[37][57] = 364;
+	GBFreq[28][47] = 363;
+	GBFreq[42][31] = 362;
+	GBFreq[18][2] = 361;
+	GBFreq[43][64] = 360;
+	GBFreq[23][47] = 359;
+	GBFreq[28][79] = 358;
+	GBFreq[25][45] = 357;
+	GBFreq[23][91] = 356;
+	GBFreq[22][19] = 355;
+	GBFreq[25][46] = 354;
+	GBFreq[22][36] = 353;
+	GBFreq[54][85] = 352;
+	GBFreq[46][20] = 351;
+	GBFreq[27][37] = 350;
+	GBFreq[26][81] = 349;
+	GBFreq[42][29] = 348;
+	GBFreq[31][90] = 347;
+	GBFreq[41][59] = 346;
+	GBFreq[24][65] = 345;
+	GBFreq[44][84] = 344;
+	GBFreq[24][90] = 343;
+	GBFreq[38][54] = 342;
+	GBFreq[28][70] = 341;
+	GBFreq[27][15] = 340;
+	GBFreq[28][80] = 339;
+	GBFreq[29][8] = 338;
+	GBFreq[45][80] = 337;
+	GBFreq[53][37] = 336;
+	GBFreq[28][65] = 335;
+	GBFreq[23][86] = 334;
+	GBFreq[39][45] = 333;
+	GBFreq[53][32] = 332;
+	GBFreq[38][68] = 331;
+	GBFreq[45][78] = 330;
+	GBFreq[43][7] = 329;
+	GBFreq[46][82] = 328;
+	GBFreq[27][38] = 327;
+	GBFreq[16][62] = 326;
+	GBFreq[24][17] = 325;
+	GBFreq[22][70] = 324;
+	GBFreq[52][28] = 323;
+	GBFreq[23][40] = 322;
+	GBFreq[28][50] = 321;
+	GBFreq[42][91] = 320;
+	GBFreq[47][76] = 319;
+	GBFreq[15][42] = 318;
+	GBFreq[43][55] = 317;
+	GBFreq[29][84] = 316;
+	GBFreq[44][90] = 315;
+	GBFreq[53][16] = 314;
+	GBFreq[22][93] = 313;
+	GBFreq[34][10] = 312;
+	GBFreq[32][53] = 311;
+	GBFreq[43][65] = 310;
+	GBFreq[28][7] = 309;
+	GBFreq[35][46] = 308;
+	GBFreq[21][39] = 307;
+	GBFreq[44][18] = 306;
+	GBFreq[40][10] = 305;
+	GBFreq[54][53] = 304;
+	GBFreq[38][74] = 303;
+	GBFreq[28][26] = 302;
+	GBFreq[15][13] = 301;
+	GBFreq[39][34] = 300;
+	GBFreq[39][46] = 299;
+	GBFreq[42][66] = 298;
+	GBFreq[33][58] = 297;
+	GBFreq[15][56] = 296;
+	GBFreq[18][51] = 295;
+	GBFreq[49][68] = 294;
+	GBFreq[30][37] = 293;
+	GBFreq[51][84] = 292;
+	GBFreq[51][9] = 291;
+	GBFreq[40][70] = 290;
+	GBFreq[41][84] = 289;
+	GBFreq[28][64] = 288;
+	GBFreq[32][88] = 287;
+	GBFreq[24][5] = 286;
+	GBFreq[53][23] = 285;
+	GBFreq[42][27] = 284;
+	GBFreq[22][38] = 283;
+	GBFreq[32][86] = 282;
+	GBFreq[34][30] = 281;
+	GBFreq[38][63] = 280;
+	GBFreq[24][59] = 279;
+	GBFreq[22][81] = 278;
+	GBFreq[32][11] = 277;
+	GBFreq[51][21] = 276;
+	GBFreq[54][41] = 275;
+	GBFreq[21][50] = 274;
+	GBFreq[23][89] = 273;
+	GBFreq[19][87] = 272;
+	GBFreq[26][7] = 271;
+	GBFreq[30][75] = 270;
+	GBFreq[43][84] = 269;
+	GBFreq[51][25] = 268;
+	GBFreq[16][67] = 267;
+	GBFreq[32][9] = 266;
+	GBFreq[48][51] = 265;
+	GBFreq[39][7] = 264;
+	GBFreq[44][88] = 263;
+	GBFreq[52][24] = 262;
+	GBFreq[23][34] = 261;
+	GBFreq[32][75] = 260;
+	GBFreq[19][10] = 259;
+	GBFreq[28][91] = 258;
+	GBFreq[32][83] = 257;
+	GBFreq[25][75] = 256;
+	GBFreq[53][45] = 255;
+	GBFreq[29][85] = 254;
+	GBFreq[53][59] = 253;
+	GBFreq[16][2] = 252;
+	GBFreq[19][78] = 251;
+	GBFreq[15][75] = 250;
+	GBFreq[51][42] = 249;
+	GBFreq[45][67] = 248;
+	GBFreq[15][74] = 247;
+	GBFreq[25][81] = 246;
+	GBFreq[37][62] = 245;
+	GBFreq[16][55] = 244;
+	GBFreq[18][38] = 243;
+	GBFreq[23][23] = 242;
+	GBFreq[38][30] = 241;
+	GBFreq[17][28] = 240;
+	GBFreq[44][73] = 239;
+	GBFreq[23][78] = 238;
+	GBFreq[40][77] = 237;
+	GBFreq[38][87] = 236;
+	GBFreq[27][19] = 235;
+	GBFreq[38][82] = 234;
+	GBFreq[37][22] = 233;
+	GBFreq[41][30] = 232;
+	GBFreq[54][9] = 231;
+	GBFreq[32][30] = 230;
+	GBFreq[30][52] = 229;
+	GBFreq[40][84] = 228;
+	GBFreq[53][57] = 227;
+	GBFreq[27][27] = 226;
+	GBFreq[38][64] = 225;
+	GBFreq[18][43] = 224;
+	GBFreq[23][69] = 223;
+	GBFreq[28][12] = 222;
+	GBFreq[50][78] = 221;
+	GBFreq[50][1] = 220;
+	GBFreq[26][88] = 219;
+	GBFreq[36][40] = 218;
+	GBFreq[33][89] = 217;
+	GBFreq[41][28] = 216;
+	GBFreq[31][77] = 215;
+	GBFreq[46][1] = 214;
+	GBFreq[47][19] = 213;
+	GBFreq[35][55] = 212;
+	GBFreq[41][21] = 211;
+	GBFreq[27][10] = 210;
+	GBFreq[32][77] = 209;
+	GBFreq[26][37] = 208;
+	GBFreq[20][33] = 207;
+	GBFreq[41][52] = 206;
+	GBFreq[32][18] = 205;
+	GBFreq[38][13] = 204;
+	GBFreq[20][18] = 203;
+	GBFreq[20][24] = 202;
+	GBFreq[45][19] = 201;
+	GBFreq[18][53] = 200;
+	GBFreq[39][0] = 199;
+	GBFreq[40][71] = 198;
+	GBFreq[41][27] = 197;
+	GBFreq[15][69] = 196;
+	GBFreq[42][10] = 195;
+	GBFreq[31][89] = 194;
+	GBFreq[51][28] = 193;
+	GBFreq[41][22] = 192;
+	GBFreq[40][43] = 191;
+	GBFreq[38][6] = 190;
+	GBFreq[37][11] = 189;
+	GBFreq[39][60] = 188;
+	GBFreq[48][47] = 187;
+	GBFreq[46][80] = 186;
+	GBFreq[52][49] = 185;
+	GBFreq[50][48] = 184;
+	GBFreq[25][1] = 183;
+	GBFreq[52][29] = 182;
+	GBFreq[24][66] = 181;
+	GBFreq[23][35] = 180;
+	GBFreq[49][72] = 179;
+	GBFreq[47][45] = 178;
+	GBFreq[45][14] = 177;
+	GBFreq[51][70] = 176;
+	GBFreq[22][30] = 175;
+	GBFreq[49][83] = 174;
+	GBFreq[26][79] = 173;
+	GBFreq[27][41] = 172;
+	GBFreq[51][81] = 171;
+	GBFreq[41][54] = 170;
+	GBFreq[20][4] = 169;
+	GBFreq[29][60] = 168;
+	GBFreq[20][27] = 167;
+	GBFreq[50][15] = 166;
+	GBFreq[41][6] = 165;
+	GBFreq[35][34] = 164;
+	GBFreq[44][87] = 163;
+	GBFreq[46][66] = 162;
+	GBFreq[42][37] = 161;
+	GBFreq[42][24] = 160;
+	GBFreq[54][7] = 159;
+	GBFreq[41][14] = 158;
+	GBFreq[39][83] = 157;
+	GBFreq[16][87] = 156;
+	GBFreq[20][59] = 155;
+	GBFreq[42][12] = 154;
+	GBFreq[47][2] = 153;
+	GBFreq[21][32] = 152;
+	GBFreq[53][29] = 151;
+	GBFreq[22][40] = 150;
+	GBFreq[24][58] = 149;
+	GBFreq[52][88] = 148;
+	GBFreq[29][30] = 147;
+	GBFreq[15][91] = 146;
+	GBFreq[54][72] = 145;
+	GBFreq[51][75] = 144;
+	GBFreq[33][67] = 143;
+	GBFreq[41][50] = 142;
+	GBFreq[27][34] = 141;
+	GBFreq[46][17] = 140;
+	GBFreq[31][74] = 139;
+	GBFreq[42][67] = 138;
+	GBFreq[54][87] = 137;
+	GBFreq[27][14] = 136;
+	GBFreq[16][63] = 135;
+	GBFreq[16][5] = 134;
+	GBFreq[43][23] = 133;
+	GBFreq[23][13] = 132;
+	GBFreq[31][12] = 131;
+	GBFreq[25][57] = 130;
+	GBFreq[38][49] = 129;
+	GBFreq[42][69] = 128;
+	GBFreq[23][80] = 127;
+	GBFreq[29][0] = 126;
+	GBFreq[28][2] = 125;
+	GBFreq[28][17] = 124;
+	GBFreq[17][27] = 123;
+	GBFreq[40][16] = 122;
+	GBFreq[45][1] = 121;
+	GBFreq[36][33] = 120;
+	GBFreq[35][23] = 119;
+	GBFreq[20][86] = 118;
+	GBFreq[29][53] = 117;
+	GBFreq[23][88] = 116;
+	GBFreq[51][87] = 115;
+	GBFreq[54][27] = 114;
+	GBFreq[44][36] = 113;
+	GBFreq[21][45] = 112;
+	GBFreq[53][52] = 111;
+	GBFreq[31][53] = 110;
+	GBFreq[38][47] = 109;
+	GBFreq[27][21] = 108;
+	GBFreq[30][42] = 107;
+	GBFreq[29][10] = 106;
+	GBFreq[35][35] = 105;
+	GBFreq[24][56] = 104;
+	GBFreq[41][29] = 103;
+	GBFreq[18][68] = 102;
+	GBFreq[29][24] = 101;
+	GBFreq[25][84] = 100;
+	GBFreq[35][47] = 99;
+	GBFreq[29][56] = 98;
+	GBFreq[30][44] = 97;
+	GBFreq[53][3] = 96;
+	GBFreq[30][63] = 95;
+	GBFreq[52][52] = 94;
+	GBFreq[54][1] = 93;
+	GBFreq[22][48] = 92;
+	GBFreq[54][66] = 91;
+	GBFreq[21][90] = 90;
+	GBFreq[52][47] = 89;
+	GBFreq[39][25] = 88;
+	GBFreq[39][39] = 87;
+	GBFreq[44][37] = 86;
+	GBFreq[44][76] = 85;
+	GBFreq[46][75] = 84;
+	GBFreq[18][37] = 83;
+	GBFreq[47][42] = 82;
+	GBFreq[19][92] = 81;
+	GBFreq[51][27] = 80;
+	GBFreq[48][83] = 79;
+	GBFreq[23][70] = 78;
+	GBFreq[29][9] = 77;
+	GBFreq[33][79] = 76;
+	GBFreq[52][90] = 75;
+	GBFreq[53][6] = 74;
+	GBFreq[24][36] = 73;
+	GBFreq[25][25] = 72;
+	GBFreq[44][26] = 71;
+	GBFreq[25][36] = 70;
+	GBFreq[29][87] = 69;
+	GBFreq[48][0] = 68;
+	GBFreq[15][40] = 67;
+	GBFreq[17][45] = 66;
+	GBFreq[30][14] = 65;
+	GBFreq[48][38] = 64;
+	GBFreq[23][19] = 63;
+	GBFreq[40][42] = 62;
+	GBFreq[31][63] = 61;
+	GBFreq[16][23] = 60;
+	GBFreq[26][21] = 59;
+	GBFreq[32][76] = 58;
+	GBFreq[23][58] = 57;
+	GBFreq[41][37] = 56;
+	GBFreq[30][43] = 55;
+	GBFreq[47][38] = 54;
+	GBFreq[21][46] = 53;
+	GBFreq[18][33] = 52;
+	GBFreq[52][37] = 51;
+	GBFreq[36][8] = 50;
+	GBFreq[49][24] = 49;
+	GBFreq[15][66] = 48;
+	GBFreq[35][77] = 47;
+	GBFreq[27][58] = 46;
+	GBFreq[35][51] = 45;
+	GBFreq[24][69] = 44;
+	GBFreq[20][54] = 43;
+	GBFreq[24][41] = 42;
+	GBFreq[41][0] = 41;
+	GBFreq[33][71] = 40;
+	GBFreq[23][52] = 39;
+	GBFreq[29][67] = 38;
+	GBFreq[46][51] = 37;
+	GBFreq[46][90] = 36;
+	GBFreq[49][33] = 35;
+	GBFreq[33][28] = 34;
+	GBFreq[37][86] = 33;
+	GBFreq[39][22] = 32;
+	GBFreq[37][37] = 31;
+	GBFreq[29][62] = 30;
+	GBFreq[29][50] = 29;
+	GBFreq[36][89] = 28;
+	GBFreq[42][44] = 27;
+	GBFreq[51][82] = 26;
+	GBFreq[28][83] = 25;
+	GBFreq[15][78] = 24;
+	GBFreq[46][62] = 23;
+	GBFreq[19][69] = 22;
+	GBFreq[51][23] = 21;
+	GBFreq[37][69] = 20;
+	GBFreq[25][5] = 19;
+	GBFreq[51][85] = 18;
+	GBFreq[48][77] = 17;
+	GBFreq[32][46] = 16;
+	GBFreq[53][60] = 15;
+	GBFreq[28][57] = 14;
+	GBFreq[54][82] = 13;
+	GBFreq[54][15] = 12;
+	GBFreq[49][54] = 11;
+	GBFreq[53][87] = 10;
+	GBFreq[27][16] = 9;
+	GBFreq[29][34] = 8;
+	GBFreq[20][44] = 7;
+	GBFreq[42][73] = 6;
+	GBFreq[47][71] = 5;
+	GBFreq[29][37] = 4;
+	GBFreq[25][50] = 3;
+	GBFreq[18][84] = 2;
+	GBFreq[50][45] = 1;
+	GBFreq[48][46] = 0;
+	//GBFreq[43][89] = -1;	GBFreq[54][68] = -2;
+
+	GBKFreq[52][132] = 600;
+	GBKFreq[73][135] = 599;
+	GBKFreq[49][123] = 598;
+	GBKFreq[77][146] = 597;
+	GBKFreq[81][123] = 596;
+	GBKFreq[82][144] = 595;
+	GBKFreq[51][179] = 594;
+	GBKFreq[83][154] = 593;
+	GBKFreq[71][139] = 592;
+	GBKFreq[64][139] = 591;
+	GBKFreq[85][144] = 590;
+	GBKFreq[52][125] = 589;
+	GBKFreq[88][25] = 588;
+	GBKFreq[81][106] = 587;
+	GBKFreq[81][148] = 586;
+	GBKFreq[62][137] = 585;
+	GBKFreq[94][0] = 584;
+	GBKFreq[1][64] = 583;
+	GBKFreq[67][163] = 582;
+	GBKFreq[20][190] = 581;
+	GBKFreq[57][131] = 580;
+	GBKFreq[29][169] = 579;
+	GBKFreq[72][143] = 578;
+	GBKFreq[0][173] = 577;
+	GBKFreq[11][23] = 576;
+	GBKFreq[61][141] = 575;
+	GBKFreq[60][123] = 574;
+	GBKFreq[81][114] = 573;
+	GBKFreq[82][131] = 572;
+	GBKFreq[67][156] = 571;
+	GBKFreq[71][167] = 570;
+	GBKFreq[20][50] = 569;
+	GBKFreq[77][132] = 568;
+	GBKFreq[84][38] = 567;
+	GBKFreq[26][29] = 566;
+	GBKFreq[74][187] = 565;
+	GBKFreq[62][116] = 564;
+	GBKFreq[67][135] = 563;
+	GBKFreq[5][86] = 562;
+	GBKFreq[72][186] = 561;
+	GBKFreq[75][161] = 560;
+	GBKFreq[78][130] = 559;
+	GBKFreq[94][30] = 558;
+	GBKFreq[84][72] = 557;
+	GBKFreq[1][67] = 556;
+	GBKFreq[75][172] = 555;
+	GBKFreq[74][185] = 554;
+	GBKFreq[53][160] = 553;
+	GBKFreq[123][14] = 552;
+	GBKFreq[79][97] = 551;
+	GBKFreq[85][110] = 550;
+	GBKFreq[78][171] = 549;
+	GBKFreq[52][131] = 548;
+	GBKFreq[56][100] = 547;
+	GBKFreq[50][182] = 546;
+	GBKFreq[94][64] = 545;
+	GBKFreq[106][74] = 544;
+	GBKFreq[11][102] = 543;
+	GBKFreq[53][124] = 542;
+	GBKFreq[24][3] = 541;
+	GBKFreq[86][148] = 540;
+	GBKFreq[53][184] = 539;
+	GBKFreq[86][147] = 538;
+	GBKFreq[96][161] = 537;
+	GBKFreq[82][77] = 536;
+	GBKFreq[59][146] = 535;
+	GBKFreq[84][126] = 534;
+	GBKFreq[79][132] = 533;
+	GBKFreq[85][123] = 532;
+	GBKFreq[71][101] = 531;
+	GBKFreq[85][106] = 530;
+	GBKFreq[6][184] = 529;
+	GBKFreq[57][156] = 528;
+	GBKFreq[75][104] = 527;
+	GBKFreq[50][137] = 526;
+	GBKFreq[79][133] = 525;
+	GBKFreq[76][108] = 524;
+	GBKFreq[57][142] = 523;
+	GBKFreq[84][130] = 522;
+	GBKFreq[52][128] = 521;
+	GBKFreq[47][44] = 520;
+	GBKFreq[52][152] = 519;
+	GBKFreq[54][104] = 518;
+	GBKFreq[30][47] = 517;
+	GBKFreq[71][123] = 516;
+	GBKFreq[52][107] = 515;
+	GBKFreq[45][84] = 514;
+	GBKFreq[107][118] = 513;
+	GBKFreq[5][161] = 512;
+	GBKFreq[48][126] = 511;
+	GBKFreq[67][170] = 510;
+	GBKFreq[43][6] = 509;
+	GBKFreq[70][112] = 508;
+	GBKFreq[86][174] = 507;
+	GBKFreq[84][166] = 506;
+	GBKFreq[79][130] = 505;
+	GBKFreq[57][141] = 504;
+	GBKFreq[81][178] = 503;
+	GBKFreq[56][187] = 502;
+	GBKFreq[81][162] = 501;
+	GBKFreq[53][104] = 500;
+	GBKFreq[123][35] = 499;
+	GBKFreq[70][169] = 498;
+	GBKFreq[69][164] = 497;
+	GBKFreq[109][61] = 496;
+	GBKFreq[73][130] = 495;
+	GBKFreq[62][134] = 494;
+	GBKFreq[54][125] = 493;
+	GBKFreq[79][105] = 492;
+	GBKFreq[70][165] = 491;
+	GBKFreq[71][189] = 490;
+	GBKFreq[23][147] = 489;
+	GBKFreq[51][139] = 488;
+	GBKFreq[47][137] = 487;
+	GBKFreq[77][123] = 486;
+	GBKFreq[86][183] = 485;
+	GBKFreq[63][173] = 484;
+	GBKFreq[79][144] = 483;
+	GBKFreq[84][159] = 482;
+	GBKFreq[60][91] = 481;
+	GBKFreq[66][187] = 480;
+	GBKFreq[73][114] = 479;
+	GBKFreq[85][56] = 478;
+	GBKFreq[71][149] = 477;
+	GBKFreq[84][189] = 476;
+	GBKFreq[104][31] = 475;
+	GBKFreq[83][82] = 474;
+	GBKFreq[68][35] = 473;
+	GBKFreq[11][77] = 472;
+	GBKFreq[15][155] = 471;
+	GBKFreq[83][153] = 470;
+	GBKFreq[71][1] = 469;
+	GBKFreq[53][190] = 468;
+	GBKFreq[50][135] = 467;
+	GBKFreq[3][147] = 466;
+	GBKFreq[48][136] = 465;
+	GBKFreq[66][166] = 464;
+	GBKFreq[55][159] = 463;
+	GBKFreq[82][150] = 462;
+	GBKFreq[58][178] = 461;
+	GBKFreq[64][102] = 460;
+	GBKFreq[16][106] = 459;
+	GBKFreq[68][110] = 458;
+	GBKFreq[54][14] = 457;
+	GBKFreq[60][140] = 456;
+	GBKFreq[91][71] = 455;
+	GBKFreq[54][150] = 454;
+	GBKFreq[78][177] = 453;
+	GBKFreq[78][117] = 452;
+	GBKFreq[104][12] = 451;
+	GBKFreq[73][150] = 450;
+	GBKFreq[51][142] = 449;
+	GBKFreq[81][145] = 448;
+	GBKFreq[66][183] = 447;
+	GBKFreq[51][178] = 446;
+	GBKFreq[75][107] = 445;
+	GBKFreq[65][119] = 444;
+	GBKFreq[69][176] = 443;
+	GBKFreq[59][122] = 442;
+	GBKFreq[78][160] = 441;
+	GBKFreq[85][183] = 440;
+	GBKFreq[105][16] = 439;
+	GBKFreq[73][110] = 438;
+	GBKFreq[104][39] = 437;
+	GBKFreq[119][16] = 436;
+	GBKFreq[76][162] = 435;
+	GBKFreq[67][152] = 434;
+	GBKFreq[82][24] = 433;
+	GBKFreq[73][121] = 432;
+	GBKFreq[83][83] = 431;
+	GBKFreq[82][145] = 430;
+	GBKFreq[49][133] = 429;
+	GBKFreq[94][13] = 428;
+	GBKFreq[58][139] = 427;
+	GBKFreq[74][189] = 426;
+	GBKFreq[66][177] = 425;
+	GBKFreq[85][184] = 424;
+	GBKFreq[55][183] = 423;
+	GBKFreq[71][107] = 422;
+	GBKFreq[11][98] = 421;
+	GBKFreq[72][153] = 420;
+	GBKFreq[2][137] = 419;
+	GBKFreq[59][147] = 418;
+	GBKFreq[58][152] = 417;
+	GBKFreq[55][144] = 416;
+	GBKFreq[73][125] = 415;
+	GBKFreq[52][154] = 414;
+	GBKFreq[70][178] = 413;
+	GBKFreq[79][148] = 412;
+	GBKFreq[63][143] = 411;
+	GBKFreq[50][140] = 410;
+	GBKFreq[47][145] = 409;
+	GBKFreq[48][123] = 408;
+	GBKFreq[56][107] = 407;
+	GBKFreq[84][83] = 406;
+	GBKFreq[59][112] = 405;
+	GBKFreq[124][72] = 404;
+	GBKFreq[79][99] = 403;
+	GBKFreq[3][37] = 402;
+	GBKFreq[114][55] = 401;
+	GBKFreq[85][152] = 400;
+	GBKFreq[60][47] = 399;
+	GBKFreq[65][96] = 398;
+	GBKFreq[74][110] = 397;
+	GBKFreq[86][182] = 396;
+	GBKFreq[50][99] = 395;
+	GBKFreq[67][186] = 394;
+	GBKFreq[81][74] = 393;
+	GBKFreq[80][37] = 392;
+	GBKFreq[21][60] = 391;
+	GBKFreq[110][12] = 390;
+	GBKFreq[60][162] = 389;
+	GBKFreq[29][115] = 388;
+	GBKFreq[83][130] = 387;
+	GBKFreq[52][136] = 386;
+	GBKFreq[63][114] = 385;
+	GBKFreq[49][127] = 384;
+	GBKFreq[83][109] = 383;
+	GBKFreq[66][128] = 382;
+	GBKFreq[78][136] = 381;
+	GBKFreq[81][180] = 380;
+	GBKFreq[76][104] = 379;
+	GBKFreq[56][156] = 378;
+	GBKFreq[61][23] = 377;
+	GBKFreq[4][30] = 376;
+	GBKFreq[69][154] = 375;
+	GBKFreq[100][37] = 374;
+	GBKFreq[54][177] = 373;
+	GBKFreq[23][119] = 372;
+	GBKFreq[71][171] = 371;
+	GBKFreq[84][146] = 370;
+	GBKFreq[20][184] = 369;
+	GBKFreq[86][76] = 368;
+	GBKFreq[74][132] = 367;
+	GBKFreq[47][97] = 366;
+	GBKFreq[82][137] = 365;
+	GBKFreq[94][56] = 364;
+	GBKFreq[92][30] = 363;
+	GBKFreq[19][117] = 362;
+	GBKFreq[48][173] = 361;
+	GBKFreq[2][136] = 360;
+	GBKFreq[7][182] = 359;
+	GBKFreq[74][188] = 358;
+	GBKFreq[14][132] = 357;
+	GBKFreq[62][172] = 356;
+	GBKFreq[25][39] = 355;
+	GBKFreq[85][129] = 354;
+	GBKFreq[64][98] = 353;
+	GBKFreq[67][127] = 352;
+	GBKFreq[72][167] = 351;
+	GBKFreq[57][143] = 350;
+	GBKFreq[76][187] = 349;
+	GBKFreq[83][181] = 348;
+	GBKFreq[84][10] = 347;
+	GBKFreq[55][166] = 346;
+	GBKFreq[55][188] = 345;
+	GBKFreq[13][151] = 344;
+	GBKFreq[62][124] = 343;
+	GBKFreq[53][136] = 342;
+	GBKFreq[106][57] = 341;
+	GBKFreq[47][166] = 340;
+	GBKFreq[109][30] = 339;
+	GBKFreq[78][114] = 338;
+	GBKFreq[83][19] = 337;
+	GBKFreq[56][162] = 336;
+	GBKFreq[60][177] = 335;
+	GBKFreq[88][9] = 334;
+	GBKFreq[74][163] = 333;
+	GBKFreq[52][156] = 332;
+	GBKFreq[71][180] = 331;
+	GBKFreq[60][57] = 330;
+	GBKFreq[72][173] = 329;
+	GBKFreq[82][91] = 328;
+	GBKFreq[51][186] = 327;
+	GBKFreq[75][86] = 326;
+	GBKFreq[75][78] = 325;
+	GBKFreq[76][170] = 324;
+	GBKFreq[60][147] = 323;
+	GBKFreq[82][75] = 322;
+	GBKFreq[80][148] = 321;
+	GBKFreq[86][150] = 320;
+	GBKFreq[13][95] = 319;
+	GBKFreq[0][11] = 318;
+	GBKFreq[84][190] = 317;
+	GBKFreq[76][166] = 316;
+	GBKFreq[14][72] = 315;
+	GBKFreq[67][144] = 314;
+	GBKFreq[84][44] = 313;
+	GBKFreq[72][125] = 312;
+	GBKFreq[66][127] = 311;
+	GBKFreq[60][25] = 310;
+	GBKFreq[70][146] = 309;
+	GBKFreq[79][135] = 308;
+	GBKFreq[54][135] = 307;
+	GBKFreq[60][104] = 306;
+	GBKFreq[55][132] = 305;
+	GBKFreq[94][2] = 304;
+	GBKFreq[54][133] = 303;
+	GBKFreq[56][190] = 302;
+	GBKFreq[58][174] = 301;
+	GBKFreq[80][144] = 300;
+	GBKFreq[85][113] = 299;
+	GBKFreq[83][15] = 298;
+	GBKFreq[105][80] = 297;
+	GBKFreq[7][179] = 296;
+	GBKFreq[93][4] = 295;
+	GBKFreq[123][40] = 294;
+	GBKFreq[85][120] = 293;
+	GBKFreq[77][165] = 292;
+	GBKFreq[86][67] = 291;
+	GBKFreq[25][162] = 290;
+	GBKFreq[77][183] = 289;
+	GBKFreq[83][71] = 288;
+	GBKFreq[78][99] = 287;
+	GBKFreq[72][177] = 286;
+	GBKFreq[71][97] = 285;
+	GBKFreq[58][111] = 284;
+	GBKFreq[77][175] = 283;
+	GBKFreq[76][181] = 282;
+	GBKFreq[71][142] = 281;
+	GBKFreq[64][150] = 280;
+	GBKFreq[5][142] = 279;
+	GBKFreq[73][128] = 278;
+	GBKFreq[73][156] = 277;
+	GBKFreq[60][188] = 276;
+	GBKFreq[64][56] = 275;
+	GBKFreq[74][128] = 274;
+	GBKFreq[48][163] = 273;
+	GBKFreq[54][116] = 272;
+	GBKFreq[73][127] = 271;
+	GBKFreq[16][176] = 270;
+	GBKFreq[62][149] = 269;
+	GBKFreq[105][96] = 268;
+	GBKFreq[55][186] = 267;
+	GBKFreq[4][51] = 266;
+	GBKFreq[48][113] = 265;
+	GBKFreq[48][152] = 264;
+	GBKFreq[23][9] = 263;
+	GBKFreq[56][102] = 262;
+	GBKFreq[11][81] = 261;
+	GBKFreq[82][112] = 260;
+	GBKFreq[65][85] = 259;
+	GBKFreq[69][125] = 258;
+	GBKFreq[68][31] = 257;
+	GBKFreq[5][20] = 256;
+	GBKFreq[60][176] = 255;
+	GBKFreq[82][81] = 254;
+	GBKFreq[72][107] = 253;
+	GBKFreq[3][52] = 252;
+	GBKFreq[71][157] = 251;
+	GBKFreq[24][46] = 250;
+	GBKFreq[69][108] = 249;
+	GBKFreq[78][178] = 248;
+	GBKFreq[9][69] = 247;
+	GBKFreq[73][144] = 246;
+	GBKFreq[63][187] = 245;
+	GBKFreq[68][36] = 244;
+	GBKFreq[47][151] = 243;
+	GBKFreq[14][74] = 242;
+	GBKFreq[47][114] = 241;
+	GBKFreq[80][171] = 240;
+	GBKFreq[75][152] = 239;
+	GBKFreq[86][40] = 238;
+	GBKFreq[93][43] = 237;
+	GBKFreq[2][50] = 236;
+	GBKFreq[62][66] = 235;
+	GBKFreq[1][183] = 234;
+	GBKFreq[74][124] = 233;
+	GBKFreq[58][104] = 232;
+	GBKFreq[83][106] = 231;
+	GBKFreq[60][144] = 230;
+	GBKFreq[48][99] = 229;
+	GBKFreq[54][157] = 228;
+	GBKFreq[70][179] = 227;
+	GBKFreq[61][127] = 226;
+	GBKFreq[57][135] = 225;
+	GBKFreq[59][190] = 224;
+	GBKFreq[77][116] = 223;
+	GBKFreq[26][17] = 222;
+	GBKFreq[60][13] = 221;
+	GBKFreq[71][38] = 220;
+	GBKFreq[85][177] = 219;
+	GBKFreq[59][73] = 218;
+	GBKFreq[50][150] = 217;
+	GBKFreq[79][102] = 216;
+	GBKFreq[76][118] = 215;
+	GBKFreq[67][132] = 214;
+	GBKFreq[73][146] = 213;
+	GBKFreq[83][184] = 212;
+	GBKFreq[86][159] = 211;
+	GBKFreq[95][120] = 210;
+	GBKFreq[23][139] = 209;
+	GBKFreq[64][183] = 208;
+	GBKFreq[85][103] = 207;
+	GBKFreq[41][90] = 206;
+	GBKFreq[87][72] = 205;
+	GBKFreq[62][104] = 204;
+	GBKFreq[79][168] = 203;
+	GBKFreq[79][150] = 202;
+	GBKFreq[104][20] = 201;
+	GBKFreq[56][114] = 200;
+	GBKFreq[84][26] = 199;
+	GBKFreq[57][99] = 198;
+	GBKFreq[62][154] = 197;
+	GBKFreq[47][98] = 196;
+	GBKFreq[61][64] = 195;
+	GBKFreq[112][18] = 194;
+	GBKFreq[123][19] = 193;
+	GBKFreq[4][98] = 192;
+	GBKFreq[47][163] = 191;
+	GBKFreq[66][188] = 190;
+	GBKFreq[81][85] = 189;
+	GBKFreq[82][30] = 188;
+	GBKFreq[65][83] = 187;
+	GBKFreq[67][24] = 186;
+	GBKFreq[68][179] = 185;
+	GBKFreq[55][177] = 184;
+	GBKFreq[2][122] = 183;
+	GBKFreq[47][139] = 182;
+	GBKFreq[79][158] = 181;
+	GBKFreq[64][143] = 180;
+	GBKFreq[100][24] = 179;
+	GBKFreq[73][103] = 178;
+	GBKFreq[50][148] = 177;
+	GBKFreq[86][97] = 176;
+	GBKFreq[59][116] = 175;
+	GBKFreq[64][173] = 174;
+	GBKFreq[99][91] = 173;
+	GBKFreq[11][99] = 172;
+	GBKFreq[78][179] = 171;
+	GBKFreq[18][17] = 170;
+	GBKFreq[58][185] = 169;
+	GBKFreq[47][165] = 168;
+	GBKFreq[67][131] = 167;
+	GBKFreq[94][40] = 166;
+	GBKFreq[74][153] = 165;
+	GBKFreq[79][142] = 164;
+	GBKFreq[57][98] = 163;
+	GBKFreq[1][164] = 162;
+	GBKFreq[55][168] = 161;
+	GBKFreq[13][141] = 160;
+	GBKFreq[51][31] = 159;
+	GBKFreq[57][178] = 158;
+	GBKFreq[50][189] = 157;
+	GBKFreq[60][167] = 156;
+	GBKFreq[80][34] = 155;
+	GBKFreq[109][80] = 154;
+	GBKFreq[85][54] = 153;
+	GBKFreq[69][183] = 152;
+	GBKFreq[67][143] = 151;
+	GBKFreq[47][120] = 150;
+	GBKFreq[45][75] = 149;
+	GBKFreq[82][98] = 148;
+	GBKFreq[83][22] = 147;
+	GBKFreq[13][103] = 146;
+	GBKFreq[49][174] = 145;
+	GBKFreq[57][181] = 144;
+	GBKFreq[64][127] = 143;
+	GBKFreq[61][131] = 142;
+	GBKFreq[52][180] = 141;
+	GBKFreq[74][134] = 140;
+	GBKFreq[84][187] = 139;
+	GBKFreq[81][189] = 138;
+	GBKFreq[47][160] = 137;
+	GBKFreq[66][148] = 136;
+	GBKFreq[7][4] = 135;
+	GBKFreq[85][134] = 134;
+	GBKFreq[88][13] = 133;
+	GBKFreq[88][80] = 132;
+	GBKFreq[69][166] = 131;
+	GBKFreq[86][18] = 130;
+	GBKFreq[79][141] = 129;
+	GBKFreq[50][108] = 128;
+	GBKFreq[94][69] = 127;
+	GBKFreq[81][110] = 126;
+	GBKFreq[69][119] = 125;
+	GBKFreq[72][161] = 124;
+	GBKFreq[106][45] = 123;
+	GBKFreq[73][124] = 122;
+	GBKFreq[94][28] = 121;
+	GBKFreq[63][174] = 120;
+	GBKFreq[3][149] = 119;
+	GBKFreq[24][160] = 118;
+	GBKFreq[113][94] = 117;
+	GBKFreq[56][138] = 116;
+	GBKFreq[64][185] = 115;
+	GBKFreq[86][56] = 114;
+	GBKFreq[56][150] = 113;
+	GBKFreq[110][55] = 112;
+	GBKFreq[28][13] = 111;
+	GBKFreq[54][190] = 110;
+	GBKFreq[8][180] = 109;
+	GBKFreq[73][149] = 108;
+	GBKFreq[80][155] = 107;
+	GBKFreq[83][172] = 106;
+	GBKFreq[67][174] = 105;
+	GBKFreq[64][180] = 104;
+	GBKFreq[84][46] = 103;
+	GBKFreq[91][74] = 102;
+	GBKFreq[69][134] = 101;
+	GBKFreq[61][107] = 100;
+	GBKFreq[47][171] = 99;
+	GBKFreq[59][51] = 98;
+	GBKFreq[109][74] = 97;
+	GBKFreq[64][174] = 96;
+	GBKFreq[52][151] = 95;
+	GBKFreq[51][176] = 94;
+	GBKFreq[80][157] = 93;
+	GBKFreq[94][31] = 92;
+	GBKFreq[79][155] = 91;
+	GBKFreq[72][174] = 90;
+	GBKFreq[69][113] = 89;
+	GBKFreq[83][167] = 88;
+	GBKFreq[83][122] = 87;
+	GBKFreq[8][178] = 86;
+	GBKFreq[70][186] = 85;
+	GBKFreq[59][153] = 84;
+	GBKFreq[84][68] = 83;
+	GBKFreq[79][39] = 82;
+	GBKFreq[47][180] = 81;
+	GBKFreq[88][53] = 80;
+	GBKFreq[57][154] = 79;
+	GBKFreq[47][153] = 78;
+	GBKFreq[3][153] = 77;
+	GBKFreq[76][134] = 76;
+	GBKFreq[51][166] = 75;
+	GBKFreq[58][176] = 74;
+	GBKFreq[27][138] = 73;
+	GBKFreq[73][126] = 72;
+	GBKFreq[76][185] = 71;
+	GBKFreq[52][186] = 70;
+	GBKFreq[81][151] = 69;
+	GBKFreq[26][50] = 68;
+	GBKFreq[76][173] = 67;
+	GBKFreq[106][56] = 66;
+	GBKFreq[85][142] = 65;
+	GBKFreq[11][103] = 64;
+	GBKFreq[69][159] = 63;
+	GBKFreq[53][142] = 62;
+	GBKFreq[7][6] = 61;
+	GBKFreq[84][59] = 60;
+	GBKFreq[86][3] = 59;
+	GBKFreq[64][144] = 58;
+	GBKFreq[1][187] = 57;
+	GBKFreq[82][128] = 56;
+	GBKFreq[3][66] = 55;
+	GBKFreq[68][133] = 54;
+	GBKFreq[55][167] = 53;
+	GBKFreq[52][130] = 52;
+	GBKFreq[61][133] = 51;
+	GBKFreq[72][181] = 50;
+	GBKFreq[25][98] = 49;
+	GBKFreq[84][149] = 48;
+	GBKFreq[91][91] = 47;
+	GBKFreq[47][188] = 46;
+	GBKFreq[68][130] = 45;
+	GBKFreq[22][44] = 44;
+	GBKFreq[81][121] = 43;
+	GBKFreq[72][140] = 42;
+	GBKFreq[55][133] = 41;
+	GBKFreq[55][185] = 40;
+	GBKFreq[56][105] = 39;
+	GBKFreq[60][30] = 38;
+	GBKFreq[70][103] = 37;
+	GBKFreq[62][141] = 36;
+	GBKFreq[70][144] = 35;
+	GBKFreq[59][111] = 34;
+	GBKFreq[54][17] = 33;
+	GBKFreq[18][190] = 32;
+	GBKFreq[65][164] = 31;
+	GBKFreq[83][125] = 30;
+	GBKFreq[61][121] = 29;
+	GBKFreq[48][13] = 28;
+	GBKFreq[51][189] = 27;
+	GBKFreq[65][68] = 26;
+	GBKFreq[7][0] = 25;
+	GBKFreq[76][188] = 24;
+	GBKFreq[85][117] = 23;
+	GBKFreq[45][33] = 22;
+	GBKFreq[78][187] = 21;
+	GBKFreq[106][48] = 20;
+	GBKFreq[59][52] = 19;
+	GBKFreq[86][185] = 18;
+	GBKFreq[84][121] = 17;
+	GBKFreq[82][189] = 16;
+	GBKFreq[68][156] = 15;
+	GBKFreq[55][125] = 14;
+	GBKFreq[65][175] = 13;
+	GBKFreq[7][140] = 12;
+	GBKFreq[50][106] = 11;
+	GBKFreq[59][124] = 10;
+	GBKFreq[67][115] = 9;
+	GBKFreq[82][114] = 8;
+	GBKFreq[74][121] = 7;
+	GBKFreq[106][69] = 6;
+	GBKFreq[94][27] = 5;
+	GBKFreq[78][98] = 4;
+	GBKFreq[85][186] = 3;
+	GBKFreq[108][90] = 2;
+	GBKFreq[62][160] = 1;
+	GBKFreq[60][169] = 0;
+
+	Big5Freq[9][89] = 600;
+	Big5Freq[11][15] = 599;
+	Big5Freq[3][66] = 598;
+	Big5Freq[6][121] = 597;
+	Big5Freq[3][0] = 596;
+	Big5Freq[5][82] = 595;
+	Big5Freq[3][42] = 594;
+	Big5Freq[5][34] = 593;
+	Big5Freq[3][8] = 592;
+	Big5Freq[3][6] = 591;
+	Big5Freq[3][67] = 590;
+	Big5Freq[7][139] = 589;
+	Big5Freq[23][137] = 588;
+	Big5Freq[12][46] = 587;
+	Big5Freq[4][8] = 586;
+	Big5Freq[4][41] = 585;
+	Big5Freq[18][47] = 584;
+	Big5Freq[12][114] = 583;
+	Big5Freq[6][1] = 582;
+	Big5Freq[22][60] = 581;
+	Big5Freq[5][46] = 580;
+	Big5Freq[11][79] = 579;
+	Big5Freq[3][23] = 578;
+	Big5Freq[7][114] = 577;
+	Big5Freq[29][102] = 576;
+	Big5Freq[19][14] = 575;
+	Big5Freq[4][133] = 574;
+	Big5Freq[3][29] = 573;
+	Big5Freq[4][109] = 572;
+	Big5Freq[14][127] = 571;
+	Big5Freq[5][48] = 570;
+	Big5Freq[13][104] = 569;
+	Big5Freq[3][132] = 568;
+	Big5Freq[26][64] = 567;
+	Big5Freq[7][19] = 566;
+	Big5Freq[4][12] = 565;
+	Big5Freq[11][124] = 564;
+	Big5Freq[7][89] = 563;
+	Big5Freq[15][124] = 562;
+	Big5Freq[4][108] = 561;
+	Big5Freq[19][66] = 560;
+	Big5Freq[3][21] = 559;
+	Big5Freq[24][12] = 558;
+	Big5Freq[28][111] = 557;
+	Big5Freq[12][107] = 556;
+	Big5Freq[3][112] = 555;
+	Big5Freq[8][113] = 554;
+	Big5Freq[5][40] = 553;
+	Big5Freq[26][145] = 552;
+	Big5Freq[3][48] = 551;
+	Big5Freq[3][70] = 550;
+	Big5Freq[22][17] = 549;
+	Big5Freq[16][47] = 548;
+	Big5Freq[3][53] = 547;
+	Big5Freq[4][24] = 546;
+	Big5Freq[32][120] = 545;
+	Big5Freq[24][49] = 544;
+	Big5Freq[24][142] = 543;
+	Big5Freq[18][66] = 542;
+	Big5Freq[29][150] = 541;
+	Big5Freq[5][122] = 540;
+	Big5Freq[5][114] = 539;
+	Big5Freq[3][44] = 538;
+	Big5Freq[10][128] = 537;
+	Big5Freq[15][20] = 536;
+	Big5Freq[13][33] = 535;
+	Big5Freq[14][87] = 534;
+	Big5Freq[3][126] = 533;
+	Big5Freq[4][53] = 532;
+	Big5Freq[4][40] = 531;
+	Big5Freq[9][93] = 530;
+	Big5Freq[15][137] = 529;
+	Big5Freq[10][123] = 528;
+	Big5Freq[4][56] = 527;
+	Big5Freq[5][71] = 526;
+	Big5Freq[10][8] = 525;
+	Big5Freq[5][16] = 524;
+	Big5Freq[5][146] = 523;
+	Big5Freq[18][88] = 522;
+	Big5Freq[24][4] = 521;
+	Big5Freq[20][47] = 520;
+	Big5Freq[5][33] = 519;
+	Big5Freq[9][43] = 518;
+	Big5Freq[20][12] = 517;
+	Big5Freq[20][13] = 516;
+	Big5Freq[5][156] = 515;
+	Big5Freq[22][140] = 514;
+	Big5Freq[8][146] = 513;
+	Big5Freq[21][123] = 512;
+	Big5Freq[4][90] = 511;
+	Big5Freq[5][62] = 510;
+	Big5Freq[17][59] = 509;
+	Big5Freq[10][37] = 508;
+	Big5Freq[18][107] = 507;
+	Big5Freq[14][53] = 506;
+	Big5Freq[22][51] = 505;
+	Big5Freq[8][13] = 504;
+	Big5Freq[5][29] = 503;
+	Big5Freq[9][7] = 502;
+	Big5Freq[22][14] = 501;
+	Big5Freq[8][55] = 500;
+	Big5Freq[33][9] = 499;
+	Big5Freq[16][64] = 498;
+	Big5Freq[7][131] = 497;
+	Big5Freq[34][4] = 496;
+	Big5Freq[7][101] = 495;
+	Big5Freq[11][139] = 494;
+	Big5Freq[3][135] = 493;
+	Big5Freq[7][102] = 492;
+	Big5Freq[17][13] = 491;
+	Big5Freq[3][20] = 490;
+	Big5Freq[27][106] = 489;
+	Big5Freq[5][88] = 488;
+	Big5Freq[6][33] = 487;
+	Big5Freq[5][139] = 486;
+	Big5Freq[6][0] = 485;
+	Big5Freq[17][58] = 484;
+	Big5Freq[5][133] = 483;
+	Big5Freq[9][107] = 482;
+	Big5Freq[23][39] = 481;
+	Big5Freq[5][23] = 480;
+	Big5Freq[3][79] = 479;
+	Big5Freq[32][97] = 478;
+	Big5Freq[3][136] = 477;
+	Big5Freq[4][94] = 476;
+	Big5Freq[21][61] = 475;
+	Big5Freq[23][123] = 474;
+	Big5Freq[26][16] = 473;
+	Big5Freq[24][137] = 472;
+	Big5Freq[22][18] = 471;
+	Big5Freq[5][1] = 470;
+	Big5Freq[20][119] = 469;
+	Big5Freq[3][7] = 468;
+	Big5Freq[10][79] = 467;
+	Big5Freq[15][105] = 466;
+	Big5Freq[3][144] = 465;
+	Big5Freq[12][80] = 464;
+	Big5Freq[15][73] = 463;
+	Big5Freq[3][19] = 462;
+	Big5Freq[8][109] = 461;
+	Big5Freq[3][15] = 460;
+	Big5Freq[31][82] = 459;
+	Big5Freq[3][43] = 458;
+	Big5Freq[25][119] = 457;
+	Big5Freq[16][111] = 456;
+	Big5Freq[7][77] = 455;
+	Big5Freq[3][95] = 454;
+	Big5Freq[24][82] = 453;
+	Big5Freq[7][52] = 452;
+	Big5Freq[9][151] = 451;
+	Big5Freq[3][129] = 450;
+	Big5Freq[5][87] = 449;
+	Big5Freq[3][55] = 448;
+	Big5Freq[8][153] = 447;
+	Big5Freq[4][83] = 446;
+	Big5Freq[3][114] = 445;
+	Big5Freq[23][147] = 444;
+	Big5Freq[15][31] = 443;
+	Big5Freq[3][54] = 442;
+	Big5Freq[11][122] = 441;
+	Big5Freq[4][4] = 440;
+	Big5Freq[34][149] = 439;
+	Big5Freq[3][17] = 438;
+	Big5Freq[21][64] = 437;
+	Big5Freq[26][144] = 436;
+	Big5Freq[4][62] = 435;
+	Big5Freq[8][15] = 434;
+	Big5Freq[35][80] = 433;
+	Big5Freq[7][110] = 432;
+	Big5Freq[23][114] = 431;
+	Big5Freq[3][108] = 430;
+	Big5Freq[3][62] = 429;
+	Big5Freq[21][41] = 428;
+	Big5Freq[15][99] = 427;
+	Big5Freq[5][47] = 426;
+	Big5Freq[4][96] = 425;
+	Big5Freq[20][122] = 424;
+	Big5Freq[5][21] = 423;
+	Big5Freq[4][157] = 422;
+	Big5Freq[16][14] = 421;
+	Big5Freq[3][117] = 420;
+	Big5Freq[7][129] = 419;
+	Big5Freq[4][27] = 418;
+	Big5Freq[5][30] = 417;
+	Big5Freq[22][16] = 416;
+	Big5Freq[5][64] = 415;
+	Big5Freq[17][99] = 414;
+	Big5Freq[17][57] = 413;
+	Big5Freq[8][105] = 412;
+	Big5Freq[5][112] = 411;
+	Big5Freq[20][59] = 410;
+	Big5Freq[6][129] = 409;
+	Big5Freq[18][17] = 408;
+	Big5Freq[3][92] = 407;
+	Big5Freq[28][118] = 406;
+	Big5Freq[3][109] = 405;
+	Big5Freq[31][51] = 404;
+	Big5Freq[13][116] = 403;
+	Big5Freq[6][15] = 402;
+	Big5Freq[36][136] = 401;
+	Big5Freq[12][74] = 400;
+	Big5Freq[20][88] = 399;
+	Big5Freq[36][68] = 398;
+	Big5Freq[3][147] = 397;
+	Big5Freq[15][84] = 396;
+	Big5Freq[16][32] = 395;
+	Big5Freq[16][58] = 394;
+	Big5Freq[7][66] = 393;
+	Big5Freq[23][107] = 392;
+	Big5Freq[9][6] = 391;
+	Big5Freq[12][86] = 390;
+	Big5Freq[23][112] = 389;
+	Big5Freq[37][23] = 388;
+	Big5Freq[3][138] = 387;
+	Big5Freq[20][68] = 386;
+	Big5Freq[15][116] = 385;
+	Big5Freq[18][64] = 384;
+	Big5Freq[12][139] = 383;
+	Big5Freq[11][155] = 382;
+	Big5Freq[4][156] = 381;
+	Big5Freq[12][84] = 380;
+	Big5Freq[18][49] = 379;
+	Big5Freq[25][125] = 378;
+	Big5Freq[25][147] = 377;
+	Big5Freq[15][110] = 376;
+	Big5Freq[19][96] = 375;
+	Big5Freq[30][152] = 374;
+	Big5Freq[6][31] = 373;
+	Big5Freq[27][117] = 372;
+	Big5Freq[3][10] = 371;
+	Big5Freq[6][131] = 370;
+	Big5Freq[13][112] = 369;
+	Big5Freq[36][156] = 368;
+	Big5Freq[4][60] = 367;
+	Big5Freq[15][121] = 366;
+	Big5Freq[4][112] = 365;
+	Big5Freq[30][142] = 364;
+	Big5Freq[23][154] = 363;
+	Big5Freq[27][101] = 362;
+	Big5Freq[9][140] = 361;
+	Big5Freq[3][89] = 360;
+	Big5Freq[18][148] = 359;
+	Big5Freq[4][69] = 358;
+	Big5Freq[16][49] = 357;
+	Big5Freq[6][117] = 356;
+	Big5Freq[36][55] = 355;
+	Big5Freq[5][123] = 354;
+	Big5Freq[4][126] = 353;
+	Big5Freq[4][119] = 352;
+	Big5Freq[9][95] = 351;
+	Big5Freq[5][24] = 350;
+	Big5Freq[16][133] = 349;
+	Big5Freq[10][134] = 348;
+	Big5Freq[26][59] = 347;
+	Big5Freq[6][41] = 346;
+	Big5Freq[6][146] = 345;
+	Big5Freq[19][24] = 344;
+	Big5Freq[5][113] = 343;
+	Big5Freq[10][118] = 342;
+	Big5Freq[34][151] = 341;
+	Big5Freq[9][72] = 340;
+	Big5Freq[31][25] = 339;
+	Big5Freq[18][126] = 338;
+	Big5Freq[18][28] = 337;
+	Big5Freq[4][153] = 336;
+	Big5Freq[3][84] = 335;
+	Big5Freq[21][18] = 334;
+	Big5Freq[25][129] = 333;
+	Big5Freq[6][107] = 332;
+	Big5Freq[12][25] = 331;
+	Big5Freq[17][109] = 330;
+	Big5Freq[7][76] = 329;
+	Big5Freq[15][15] = 328;
+	Big5Freq[4][14] = 327;
+	Big5Freq[23][88] = 326;
+	Big5Freq[18][2] = 325;
+	Big5Freq[6][88] = 324;
+	Big5Freq[16][84] = 323;
+	Big5Freq[12][48] = 322;
+	Big5Freq[7][68] = 321;
+	Big5Freq[5][50] = 320;
+	Big5Freq[13][54] = 319;
+	Big5Freq[7][98] = 318;
+	Big5Freq[11][6] = 317;
+	Big5Freq[9][80] = 316;
+	Big5Freq[16][41] = 315;
+	Big5Freq[7][43] = 314;
+	Big5Freq[28][117] = 313;
+	Big5Freq[3][51] = 312;
+	Big5Freq[7][3] = 311;
+	Big5Freq[20][81] = 310;
+	Big5Freq[4][2] = 309;
+	Big5Freq[11][16] = 308;
+	Big5Freq[10][4] = 307;
+	Big5Freq[10][119] = 306;
+	Big5Freq[6][142] = 305;
+	Big5Freq[18][51] = 304;
+	Big5Freq[8][144] = 303;
+	Big5Freq[10][65] = 302;
+	Big5Freq[11][64] = 301;
+	Big5Freq[11][130] = 300;
+	Big5Freq[9][92] = 299;
+	Big5Freq[18][29] = 298;
+	Big5Freq[18][78] = 297;
+	Big5Freq[18][151] = 296;
+	Big5Freq[33][127] = 295;
+	Big5Freq[35][113] = 294;
+	Big5Freq[10][155] = 293;
+	Big5Freq[3][76] = 292;
+	Big5Freq[36][123] = 291;
+	Big5Freq[13][143] = 290;
+	Big5Freq[5][135] = 289;
+	Big5Freq[23][116] = 288;
+	Big5Freq[6][101] = 287;
+	Big5Freq[14][74] = 286;
+	Big5Freq[7][153] = 285;
+	Big5Freq[3][101] = 284;
+	Big5Freq[9][74] = 283;
+	Big5Freq[3][156] = 282;
+	Big5Freq[4][147] = 281;
+	Big5Freq[9][12] = 280;
+	Big5Freq[18][133] = 279;
+	Big5Freq[4][0] = 278;
+	Big5Freq[7][155] = 277;
+	Big5Freq[9][144] = 276;
+	Big5Freq[23][49] = 275;
+	Big5Freq[5][89] = 274;
+	Big5Freq[10][11] = 273;
+	Big5Freq[3][110] = 272;
+	Big5Freq[3][40] = 271;
+	Big5Freq[29][115] = 270;
+	Big5Freq[9][100] = 269;
+	Big5Freq[21][67] = 268;
+	Big5Freq[23][145] = 267;
+	Big5Freq[10][47] = 266;
+	Big5Freq[4][31] = 265;
+	Big5Freq[4][81] = 264;
+	Big5Freq[22][62] = 263;
+	Big5Freq[4][28] = 262;
+	Big5Freq[27][39] = 261;
+	Big5Freq[27][54] = 260;
+	Big5Freq[32][46] = 259;
+	Big5Freq[4][76] = 258;
+	Big5Freq[26][15] = 257;
+	Big5Freq[12][154] = 256;
+	Big5Freq[9][150] = 255;
+	Big5Freq[15][17] = 254;
+	Big5Freq[5][129] = 253;
+	Big5Freq[10][40] = 252;
+	Big5Freq[13][37] = 251;
+	Big5Freq[31][104] = 250;
+	Big5Freq[3][152] = 249;
+	Big5Freq[5][22] = 248;
+	Big5Freq[8][48] = 247;
+	Big5Freq[4][74] = 246;
+	Big5Freq[6][17] = 245;
+	Big5Freq[30][82] = 244;
+	Big5Freq[4][116] = 243;
+	Big5Freq[16][42] = 242;
+	Big5Freq[5][55] = 241;
+	Big5Freq[4][64] = 240;
+	Big5Freq[14][19] = 239;
+	Big5Freq[35][82] = 238;
+	Big5Freq[30][139] = 237;
+	Big5Freq[26][152] = 236;
+	Big5Freq[32][32] = 235;
+	Big5Freq[21][102] = 234;
+	Big5Freq[10][131] = 233;
+	Big5Freq[9][128] = 232;
+	Big5Freq[3][87] = 231;
+	Big5Freq[4][51] = 230;
+	Big5Freq[10][15] = 229;
+	Big5Freq[4][150] = 228;
+	Big5Freq[7][4] = 227;
+	Big5Freq[7][51] = 226;
+	Big5Freq[7][157] = 225;
+	Big5Freq[4][146] = 224;
+	Big5Freq[4][91] = 223;
+	Big5Freq[7][13] = 222;
+	Big5Freq[17][116] = 221;
+	Big5Freq[23][21] = 220;
+	Big5Freq[5][106] = 219;
+	Big5Freq[14][100] = 218;
+	Big5Freq[10][152] = 217;
+	Big5Freq[14][89] = 216;
+	Big5Freq[6][138] = 215;
+	Big5Freq[12][157] = 214;
+	Big5Freq[10][102] = 213;
+	Big5Freq[19][94] = 212;
+	Big5Freq[7][74] = 211;
+	Big5Freq[18][128] = 210;
+	Big5Freq[27][111] = 209;
+	Big5Freq[11][57] = 208;
+	Big5Freq[3][131] = 207;
+	Big5Freq[30][23] = 206;
+	Big5Freq[30][126] = 205;
+	Big5Freq[4][36] = 204;
+	Big5Freq[26][124] = 203;
+	Big5Freq[4][19] = 202;
+	Big5Freq[9][152] = 201;
+	Big5Freq[5][0] = 200;
+	Big5Freq[26][57] = 199;
+	Big5Freq[13][155] = 198;
+	Big5Freq[3][38] = 197;
+	Big5Freq[9][155] = 196;
+	Big5Freq[28][53] = 195;
+	Big5Freq[15][71] = 194;
+	Big5Freq[21][95] = 193;
+	Big5Freq[15][112] = 192;
+	Big5Freq[14][138] = 191;
+	Big5Freq[8][18] = 190;
+	Big5Freq[20][151] = 189;
+	Big5Freq[37][27] = 188;
+	Big5Freq[32][48] = 187;
+	Big5Freq[23][66] = 186;
+	Big5Freq[9][2] = 185;
+	Big5Freq[13][133] = 184;
+	Big5Freq[7][127] = 183;
+	Big5Freq[3][11] = 182;
+	Big5Freq[12][118] = 181;
+	Big5Freq[13][101] = 180;
+	Big5Freq[30][153] = 179;
+	Big5Freq[4][65] = 178;
+	Big5Freq[5][25] = 177;
+	Big5Freq[5][140] = 176;
+	Big5Freq[6][25] = 175;
+	Big5Freq[4][52] = 174;
+	Big5Freq[30][156] = 173;
+	Big5Freq[16][13] = 172;
+	Big5Freq[21][8] = 171;
+	Big5Freq[19][74] = 170;
+	Big5Freq[15][145] = 169;
+	Big5Freq[9][15] = 168;
+	Big5Freq[13][82] = 167;
+	Big5Freq[26][86] = 166;
+	Big5Freq[18][52] = 165;
+	Big5Freq[6][109] = 164;
+	Big5Freq[10][99] = 163;
+	Big5Freq[18][101] = 162;
+	Big5Freq[25][49] = 161;
+	Big5Freq[31][79] = 160;
+	Big5Freq[28][20] = 159;
+	Big5Freq[12][115] = 158;
+	Big5Freq[15][66] = 157;
+	Big5Freq[11][104] = 156;
+	Big5Freq[23][106] = 155;
+	Big5Freq[34][157] = 154;
+	Big5Freq[32][94] = 153;
+	Big5Freq[29][88] = 152;
+	Big5Freq[10][46] = 151;
+	Big5Freq[13][118] = 150;
+	Big5Freq[20][37] = 149;
+	Big5Freq[12][30] = 148;
+	Big5Freq[21][4] = 147;
+	Big5Freq[16][33] = 146;
+	Big5Freq[13][52] = 145;
+	Big5Freq[4][7] = 144;
+	Big5Freq[21][49] = 143;
+	Big5Freq[3][27] = 142;
+	Big5Freq[16][91] = 141;
+	Big5Freq[5][155] = 140;
+	Big5Freq[29][130] = 139;
+	Big5Freq[3][125] = 138;
+	Big5Freq[14][26] = 137;
+	Big5Freq[15][39] = 136;
+	Big5Freq[24][110] = 135;
+	Big5Freq[7][141] = 134;
+	Big5Freq[21][15] = 133;
+	Big5Freq[32][104] = 132;
+	Big5Freq[8][31] = 131;
+	Big5Freq[34][112] = 130;
+	Big5Freq[10][75] = 129;
+	Big5Freq[21][23] = 128;
+	Big5Freq[34][131] = 127;
+	Big5Freq[12][3] = 126;
+	Big5Freq[10][62] = 125;
+	Big5Freq[9][120] = 124;
+	Big5Freq[32][149] = 123;
+	Big5Freq[8][44] = 122;
+	Big5Freq[24][2] = 121;
+	Big5Freq[6][148] = 120;
+	Big5Freq[15][103] = 119;
+	Big5Freq[36][54] = 118;
+	Big5Freq[36][134] = 117;
+	Big5Freq[11][7] = 116;
+	Big5Freq[3][90] = 115;
+	Big5Freq[36][73] = 114;
+	Big5Freq[8][102] = 113;
+	Big5Freq[12][87] = 112;
+	Big5Freq[25][64] = 111;
+	Big5Freq[9][1] = 110;
+	Big5Freq[24][121] = 109;
+	Big5Freq[5][75] = 108;
+	Big5Freq[17][83] = 107;
+	Big5Freq[18][57] = 106;
+	Big5Freq[8][95] = 105;
+	Big5Freq[14][36] = 104;
+	Big5Freq[28][113] = 103;
+	Big5Freq[12][56] = 102;
+	Big5Freq[14][61] = 101;
+	Big5Freq[25][138] = 100;
+	Big5Freq[4][34] = 99;
+	Big5Freq[11][152] = 98;
+	Big5Freq[35][0] = 97;
+	Big5Freq[4][15] = 96;
+	Big5Freq[8][82] = 95;
+	Big5Freq[20][73] = 94;
+	Big5Freq[25][52] = 93;
+	Big5Freq[24][6] = 92;
+	Big5Freq[21][78] = 91;
+	Big5Freq[17][32] = 90;
+	Big5Freq[17][91] = 89;
+	Big5Freq[5][76] = 88;
+	Big5Freq[15][60] = 87;
+	Big5Freq[15][150] = 86;
+	Big5Freq[5][80] = 85;
+	Big5Freq[15][81] = 84;
+	Big5Freq[28][108] = 83;
+	Big5Freq[18][14] = 82;
+	Big5Freq[19][109] = 81;
+	Big5Freq[28][133] = 80;
+	Big5Freq[21][97] = 79;
+	Big5Freq[5][105] = 78;
+	Big5Freq[18][114] = 77;
+	Big5Freq[16][95] = 76;
+	Big5Freq[5][51] = 75;
+	Big5Freq[3][148] = 74;
+	Big5Freq[22][102] = 73;
+	Big5Freq[4][123] = 72;
+	Big5Freq[8][88] = 71;
+	Big5Freq[25][111] = 70;
+	Big5Freq[8][149] = 69;
+	Big5Freq[9][48] = 68;
+	Big5Freq[16][126] = 67;
+	Big5Freq[33][150] = 66;
+	Big5Freq[9][54] = 65;
+	Big5Freq[29][104] = 64;
+	Big5Freq[3][3] = 63;
+	Big5Freq[11][49] = 62;
+	Big5Freq[24][109] = 61;
+	Big5Freq[28][116] = 60;
+	Big5Freq[34][113] = 59;
+	Big5Freq[5][3] = 58;
+	Big5Freq[21][106] = 57;
+	Big5Freq[4][98] = 56;
+	Big5Freq[12][135] = 55;
+	Big5Freq[16][101] = 54;
+	Big5Freq[12][147] = 53;
+	Big5Freq[27][55] = 52;
+	Big5Freq[3][5] = 51;
+	Big5Freq[11][101] = 50;
+	Big5Freq[16][157] = 49;
+	Big5Freq[22][114] = 48;
+	Big5Freq[18][46] = 47;
+	Big5Freq[4][29] = 46;
+	Big5Freq[8][103] = 45;
+	Big5Freq[16][151] = 44;
+	Big5Freq[8][29] = 43;
+	Big5Freq[15][114] = 42;
+	Big5Freq[22][70] = 41;
+	Big5Freq[13][121] = 40;
+	Big5Freq[7][112] = 39;
+	Big5Freq[20][83] = 38;
+	Big5Freq[3][36] = 37;
+	Big5Freq[10][103] = 36;
+	Big5Freq[3][96] = 35;
+	Big5Freq[21][79] = 34;
+	Big5Freq[25][120] = 33;
+	Big5Freq[29][121] = 32;
+	Big5Freq[23][71] = 31;
+	Big5Freq[21][22] = 30;
+	Big5Freq[18][89] = 29;
+	Big5Freq[25][104] = 28;
+	Big5Freq[10][124] = 27;
+	Big5Freq[26][4] = 26;
+	Big5Freq[21][136] = 25;
+	Big5Freq[6][112] = 24;
+	Big5Freq[12][103] = 23;
+	Big5Freq[17][66] = 22;
+	Big5Freq[13][151] = 21;
+	Big5Freq[33][152] = 20;
+	Big5Freq[11][148] = 19;
+	Big5Freq[13][57] = 18;
+	Big5Freq[13][41] = 17;
+	Big5Freq[7][60] = 16;
+	Big5Freq[21][29] = 15;
+	Big5Freq[9][157] = 14;
+	Big5Freq[24][95] = 13;
+	Big5Freq[15][148] = 12;
+	Big5Freq[15][122] = 11;
+	Big5Freq[6][125] = 10;
+	Big5Freq[11][25] = 9;
+	Big5Freq[20][55] = 8;
+	Big5Freq[19][84] = 7;
+	Big5Freq[21][82] = 6;
+	Big5Freq[24][3] = 5;
+	Big5Freq[13][70] = 4;
+	Big5Freq[6][21] = 3;
+	Big5Freq[21][86] = 2;
+	Big5Freq[12][23] = 1;
+	Big5Freq[3][85] = 0;
+	/*
+	 Big5PFreq[41][122] = 600;	Big5PFreq[35][0] = 599;
+	 Big5PFreq[43][15] = 598;	Big5PFreq[35][99] = 597;
+	 Big5PFreq[35][6] = 596;	Big5PFreq[35][8] = 595;
+	 Big5PFreq[38][154] = 594;	Big5PFreq[37][34] = 593;
+	 Big5PFreq[37][115] = 592;	Big5PFreq[36][12] = 591;
+	 Big5PFreq[18][77] = 590;	Big5PFreq[35][100] = 589;
+	 Big5PFreq[35][42] = 588;	Big5PFreq[120][75] = 587;
+	 Big5PFreq[35][23] = 586;	Big5PFreq[13][72] = 585;
+	 Big5PFreq[0][67] = 584;	Big5PFreq[39][172] = 583;
+	 Big5PFreq[22][182] = 582;	Big5PFreq[15][186] = 581;
+	 Big5PFreq[15][165] = 580;	Big5PFreq[35][44] = 579;
+	 Big5PFreq[40][13] = 578;	Big5PFreq[38][1] = 577;
+	 Big5PFreq[37][33] = 576;	Big5PFreq[36][24] = 575;
+	 Big5PFreq[56][4] = 574;	Big5PFreq[35][29] = 573;
+	 Big5PFreq[9][96] = 572;	Big5PFreq[37][62] = 571;
+	 Big5PFreq[48][47] = 570;	Big5PFreq[51][14] = 569;
+	 Big5PFreq[39][122] = 568;	Big5PFreq[44][46] = 567;
+	 Big5PFreq[35][21] = 566;	Big5PFreq[36][8] = 565;
+	 Big5PFreq[36][141] = 564;	Big5PFreq[3][81] = 563;
+	 Big5PFreq[37][155] = 562;	Big5PFreq[42][84] = 561;
+	 Big5PFreq[36][40] = 560;	Big5PFreq[35][103] = 559;
+	 Big5PFreq[11][84] = 558;	Big5PFreq[45][33] = 557;
+	 Big5PFreq[121][79] = 556;	Big5PFreq[2][77] = 555;
+	 Big5PFreq[36][41] = 554;	Big5PFreq[37][47] = 553;
+	 Big5PFreq[39][125] = 552;	Big5PFreq[37][26] = 551;
+	 Big5PFreq[35][48] = 550;	Big5PFreq[35][28] = 549;
+	 Big5PFreq[35][159] = 548;	Big5PFreq[37][40] = 547;
+	 Big5PFreq[35][145] = 546;	Big5PFreq[37][147] = 545;
+	 Big5PFreq[46][160] = 544;	Big5PFreq[37][46] = 543;
+	 Big5PFreq[50][99] = 542;	Big5PFreq[52][13] = 541;
+	 Big5PFreq[10][82] = 540;	Big5PFreq[35][169] = 539;
+	 Big5PFreq[35][31] = 538;	Big5PFreq[47][31] = 537;
+	 Big5PFreq[18][79] = 536;	Big5PFreq[16][113] = 535;
+	 Big5PFreq[37][104] = 534;	Big5PFreq[39][134] = 533;
+	 Big5PFreq[36][53] = 532;	Big5PFreq[38][0] = 531;
+	 Big5PFreq[4][86] = 530;	Big5PFreq[54][17] = 529;
+	 Big5PFreq[43][157] = 528;	Big5PFreq[35][165] = 527;
+	 Big5PFreq[69][147] = 526;	Big5PFreq[117][95] = 525;
+	 Big5PFreq[35][162] = 524;	Big5PFreq[35][17] = 523;
+	 Big5PFreq[36][142] = 522;	Big5PFreq[36][4] = 521;
+	 Big5PFreq[37][166] = 520;	Big5PFreq[35][168] = 519;
+	 Big5PFreq[35][19] = 518;	Big5PFreq[37][48] = 517;
+	 Big5PFreq[42][37] = 516;	Big5PFreq[40][146] = 515;
+	 Big5PFreq[36][123] = 514;	Big5PFreq[22][41] = 513;
+	 Big5PFreq[20][119] = 512;	Big5PFreq[2][74] = 511;
+	 Big5PFreq[44][113] = 510;	Big5PFreq[35][125] = 509;
+	 Big5PFreq[37][16] = 508;	Big5PFreq[35][20] = 507;
+	 Big5PFreq[35][55] = 506;	Big5PFreq[37][145] = 505;
+	 Big5PFreq[0][88] = 504;	Big5PFreq[3][94] = 503;
+	 Big5PFreq[6][65] = 502;	Big5PFreq[26][15] = 501;
+	 Big5PFreq[41][126] = 500;	Big5PFreq[36][129] = 499;
+	 Big5PFreq[31][75] = 498;	Big5PFreq[19][61] = 497;
+	 Big5PFreq[35][128] = 496;	Big5PFreq[29][79] = 495;
+	 Big5PFreq[36][62] = 494;	Big5PFreq[37][189] = 493;
+	 Big5PFreq[39][109] = 492;	Big5PFreq[39][135] = 491;
+	 Big5PFreq[72][15] = 490;	Big5PFreq[47][106] = 489;
+	 Big5PFreq[54][14] = 488;	Big5PFreq[24][52] = 487;
+	 Big5PFreq[38][162] = 486;	Big5PFreq[41][43] = 485;
+	 Big5PFreq[37][121] = 484;	Big5PFreq[14][66] = 483;
+	 Big5PFreq[37][30] = 482;	Big5PFreq[35][7] = 481;
+	 Big5PFreq[49][58] = 480;	Big5PFreq[43][188] = 479;
+	 Big5PFreq[24][66] = 478;	Big5PFreq[35][171] = 477;
+	 Big5PFreq[40][186] = 476;	Big5PFreq[39][164] = 475;
+	 Big5PFreq[78][186] = 474;	Big5PFreq[8][72] = 473;
+	 Big5PFreq[36][190] = 472;	Big5PFreq[35][53] = 471;
+	 Big5PFreq[35][54] = 470;	Big5PFreq[22][159] = 469;
+	 Big5PFreq[35][9] = 468;	Big5PFreq[41][140] = 467;
+	 Big5PFreq[37][22] = 466;	Big5PFreq[48][97] = 465;
+	 Big5PFreq[50][97] = 464;	Big5PFreq[36][127] = 463;
+	 Big5PFreq[37][23] = 462;	Big5PFreq[40][55] = 461;
+	 Big5PFreq[35][43] = 460;	Big5PFreq[26][22] = 459;
+	 Big5PFreq[35][15] = 458;	Big5PFreq[72][179] = 457;
+	 Big5PFreq[20][129] = 456;	Big5PFreq[52][101] = 455;
+	 Big5PFreq[35][12] = 454;	Big5PFreq[42][156] = 453;
+	 Big5PFreq[15][157] = 452;	Big5PFreq[50][140] = 451;
+	 Big5PFreq[26][28] = 450;	Big5PFreq[54][51] = 449;
+	 Big5PFreq[35][112] = 448;	Big5PFreq[36][116] = 447;
+	 Big5PFreq[42][11] = 446;	Big5PFreq[37][172] = 445;
+	 Big5PFreq[37][29] = 444;	Big5PFreq[44][107] = 443;
+	 Big5PFreq[50][17] = 442;	Big5PFreq[39][107] = 441;
+	 Big5PFreq[19][109] = 440;	Big5PFreq[36][60] = 439;
+	 Big5PFreq[49][132] = 438;	Big5PFreq[26][16] = 437;
+	 Big5PFreq[43][155] = 436;	Big5PFreq[37][120] = 435;
+	 Big5PFreq[15][159] = 434;	Big5PFreq[43][6] = 433;
+	 Big5PFreq[45][188] = 432;	Big5PFreq[35][38] = 431;
+	 Big5PFreq[39][143] = 430;	Big5PFreq[48][144] = 429;
+	 Big5PFreq[37][168] = 428;	Big5PFreq[37][1] = 427;
+	 Big5PFreq[36][109] = 426;	Big5PFreq[46][53] = 425;
+	 Big5PFreq[38][54] = 424;	Big5PFreq[36][0] = 423;
+	 Big5PFreq[72][33] = 422;	Big5PFreq[42][8] = 421;
+	 Big5PFreq[36][31] = 420;	Big5PFreq[35][150] = 419;
+	 Big5PFreq[118][93] = 418;	Big5PFreq[37][61] = 417;
+	 Big5PFreq[0][85] = 416;	Big5PFreq[36][27] = 415;
+	 Big5PFreq[35][134] = 414;	Big5PFreq[36][145] = 413;
+	 Big5PFreq[6][96] = 412;	Big5PFreq[36][14] = 411;
+	 Big5PFreq[16][36] = 410;	Big5PFreq[15][175] = 409;
+	 Big5PFreq[35][10] = 408;	Big5PFreq[36][189] = 407;
+	 Big5PFreq[35][51] = 406;	Big5PFreq[35][109] = 405;
+	 Big5PFreq[35][147] = 404;	Big5PFreq[35][180] = 403;
+	 Big5PFreq[72][5] = 402;	Big5PFreq[36][107] = 401;
+	 Big5PFreq[49][116] = 400;	Big5PFreq[73][30] = 399;
+	 Big5PFreq[6][90] = 398;	Big5PFreq[2][70] = 397;
+	 Big5PFreq[17][141] = 396;	Big5PFreq[35][62] = 395;
+	 Big5PFreq[16][180] = 394;	Big5PFreq[4][91] = 393;
+	 Big5PFreq[15][171] = 392;	Big5PFreq[35][177] = 391;
+	 Big5PFreq[37][173] = 390;	Big5PFreq[16][121] = 389;
+	 Big5PFreq[35][5] = 388;	Big5PFreq[46][122] = 387;
+	 Big5PFreq[40][138] = 386;	Big5PFreq[50][49] = 385;
+	 Big5PFreq[36][152] = 384;	Big5PFreq[13][43] = 383;
+	 Big5PFreq[9][88] = 382;	Big5PFreq[36][159] = 381;
+	 Big5PFreq[27][62] = 380;	Big5PFreq[40][18] = 379;
+	 Big5PFreq[17][129] = 378;	Big5PFreq[43][97] = 377;
+	 Big5PFreq[13][131] = 376;	Big5PFreq[46][107] = 375;
+	 Big5PFreq[60][64] = 374;	Big5PFreq[36][179] = 373;
+	 Big5PFreq[37][55] = 372;	Big5PFreq[41][173] = 371;
+	 Big5PFreq[44][172] = 370;	Big5PFreq[23][187] = 369;
+	 Big5PFreq[36][149] = 368;	Big5PFreq[17][125] = 367;
+	 Big5PFreq[55][180] = 366;	Big5PFreq[51][129] = 365;
+	 Big5PFreq[36][51] = 364;	Big5PFreq[37][122] = 363;
+	 Big5PFreq[48][32] = 362;	Big5PFreq[51][99] = 361;
+	 Big5PFreq[54][16] = 360;	Big5PFreq[41][183] = 359;
+	 Big5PFreq[37][179] = 358;	Big5PFreq[38][179] = 357;
+	 Big5PFreq[35][143] = 356;	Big5PFreq[37][24] = 355;
+	 Big5PFreq[40][177] = 354;	Big5PFreq[47][117] = 353;
+	 Big5PFreq[39][52] = 352;	Big5PFreq[22][99] = 351;
+	 Big5PFreq[40][142] = 350;	Big5PFreq[36][49] = 349;
+	 Big5PFreq[38][17] = 348;	Big5PFreq[39][188] = 347;
+	 Big5PFreq[36][186] = 346;	Big5PFreq[35][189] = 345;
+	 Big5PFreq[41][7] = 344;	Big5PFreq[18][91] = 343;
+	 Big5PFreq[43][137] = 342;	Big5PFreq[35][142] = 341;
+	 Big5PFreq[35][117] = 340;	Big5PFreq[39][138] = 339;
+	 Big5PFreq[16][59] = 338;	Big5PFreq[39][174] = 337;
+	 Big5PFreq[55][145] = 336;	Big5PFreq[37][21] = 335;
+	 Big5PFreq[36][180] = 334;	Big5PFreq[37][156] = 333;
+	 Big5PFreq[49][13] = 332;	Big5PFreq[41][107] = 331;
+	 Big5PFreq[36][56] = 330;	Big5PFreq[53][8] = 329;
+	 Big5PFreq[22][114] = 328;	Big5PFreq[5][95] = 327;
+	 Big5PFreq[37][0] = 326;	Big5PFreq[26][183] = 325;
+	 Big5PFreq[22][66] = 324;	Big5PFreq[35][58] = 323;
+	 Big5PFreq[48][117] = 322;	Big5PFreq[36][102] = 321;
+	 Big5PFreq[22][122] = 320;	Big5PFreq[35][11] = 319;
+	 Big5PFreq[46][19] = 318;	Big5PFreq[22][49] = 317;
+	 Big5PFreq[48][166] = 316;	Big5PFreq[41][125] = 315;
+	 Big5PFreq[41][1] = 314;	Big5PFreq[35][178] = 313;
+	 Big5PFreq[41][12] = 312;	Big5PFreq[26][167] = 311;
+	 Big5PFreq[42][152] = 310;	Big5PFreq[42][46] = 309;
+	 Big5PFreq[42][151] = 308;	Big5PFreq[20][135] = 307;
+	 Big5PFreq[37][162] = 306;	Big5PFreq[37][50] = 305;
+	 Big5PFreq[22][185] = 304;	Big5PFreq[36][166] = 303;
+	 Big5PFreq[19][40] = 302;	Big5PFreq[22][107] = 301;
+	 Big5PFreq[22][102] = 300;	Big5PFreq[57][162] = 299;
+	 Big5PFreq[22][124] = 298;	Big5PFreq[37][138] = 297;
+	 Big5PFreq[37][25] = 296;	Big5PFreq[0][69] = 295;
+	 Big5PFreq[43][172] = 294;	Big5PFreq[42][167] = 293;
+	 Big5PFreq[35][120] = 292;	Big5PFreq[41][128] = 291;
+	 Big5PFreq[2][88] = 290;	Big5PFreq[20][123] = 289;
+	 Big5PFreq[35][123] = 288;	Big5PFreq[36][28] = 287;
+	 Big5PFreq[42][188] = 286;	Big5PFreq[42][164] = 285;
+	 Big5PFreq[42][4] = 284;	Big5PFreq[43][57] = 283;
+	 Big5PFreq[39][3] = 282;	Big5PFreq[42][3] = 281;
+	 Big5PFreq[57][158] = 280;	Big5PFreq[35][146] = 279;
+	 Big5PFreq[24][54] = 278;	Big5PFreq[13][110] = 277;
+	 Big5PFreq[23][132] = 276;	Big5PFreq[26][102] = 275;
+	 Big5PFreq[55][178] = 274;	Big5PFreq[17][117] = 273;
+	 Big5PFreq[41][161] = 272;	Big5PFreq[38][150] = 271;
+	 Big5PFreq[10][71] = 270;	Big5PFreq[47][60] = 269;
+	 Big5PFreq[16][114] = 268;	Big5PFreq[21][47] = 267;
+	 Big5PFreq[39][101] = 266;	Big5PFreq[18][45] = 265;
+	 Big5PFreq[40][121] = 264;	Big5PFreq[45][41] = 263;
+	 Big5PFreq[22][167] = 262;	Big5PFreq[26][149] = 261;
+	 Big5PFreq[15][189] = 260;	Big5PFreq[41][177] = 259;
+	 Big5PFreq[46][36] = 258;	Big5PFreq[20][40] = 257;
+	 Big5PFreq[41][54] = 256;	Big5PFreq[3][87] = 255;
+	 Big5PFreq[40][16] = 254;	Big5PFreq[42][15] = 253;
+	 Big5PFreq[11][83] = 252;	Big5PFreq[0][94] = 251;
+	 Big5PFreq[122][81] = 250;	Big5PFreq[41][26] = 249;
+	 Big5PFreq[36][34] = 248;	Big5PFreq[44][148] = 247;
+	 Big5PFreq[35][3] = 246;	Big5PFreq[36][114] = 245;
+	 Big5PFreq[42][112] = 244;	Big5PFreq[35][183] = 243;
+	 Big5PFreq[49][73] = 242;	Big5PFreq[39][2] = 241;
+	 Big5PFreq[38][121] = 240;	Big5PFreq[44][114] = 239;
+	 Big5PFreq[49][32] = 238;	Big5PFreq[1][65] = 237;
+	 Big5PFreq[38][25] = 236;	Big5PFreq[39][4] = 235;
+	 Big5PFreq[42][62] = 234;	Big5PFreq[35][40] = 233;
+	 Big5PFreq[24][2] = 232;	Big5PFreq[53][49] = 231;
+	 Big5PFreq[41][133] = 230;	Big5PFreq[43][134] = 229;
+	 Big5PFreq[3][83] = 228;	Big5PFreq[38][158] = 227;
+	 Big5PFreq[24][17] = 226;	Big5PFreq[52][59] = 225;
+	 Big5PFreq[38][41] = 224;	Big5PFreq[37][127] = 223;
+	 Big5PFreq[22][175] = 222;	Big5PFreq[44][30] = 221;
+	 Big5PFreq[47][178] = 220;	Big5PFreq[43][99] = 219;
+	 Big5PFreq[19][4] = 218;	Big5PFreq[37][97] = 217;
+	 Big5PFreq[38][181] = 216;	Big5PFreq[45][103] = 215;
+	 Big5PFreq[1][86] = 214;	Big5PFreq[40][15] = 213;
+	 Big5PFreq[22][136] = 212;	Big5PFreq[75][165] = 211;
+	 Big5PFreq[36][15] = 210;	Big5PFreq[46][80] = 209;
+	 Big5PFreq[59][55] = 208;	Big5PFreq[37][108] = 207;
+	 Big5PFreq[21][109] = 206;	Big5PFreq[24][165] = 205;
+	 Big5PFreq[79][158] = 204;	Big5PFreq[44][139] = 203;
+	 Big5PFreq[36][124] = 202;	Big5PFreq[42][185] = 201;
+	 Big5PFreq[39][186] = 200;	Big5PFreq[22][128] = 199;
+	 Big5PFreq[40][44] = 198;	Big5PFreq[41][105] = 197;
+	 Big5PFreq[1][70] = 196;	Big5PFreq[1][68] = 195;
+	 Big5PFreq[53][22] = 194;	Big5PFreq[36][54] = 193;
+	 Big5PFreq[47][147] = 192;	Big5PFreq[35][36] = 191;
+	 Big5PFreq[35][185] = 190;	Big5PFreq[45][37] = 189;
+	 Big5PFreq[43][163] = 188;	Big5PFreq[56][115] = 187;
+	 Big5PFreq[38][164] = 186;	Big5PFreq[35][141] = 185;
+	 Big5PFreq[42][132] = 184;	Big5PFreq[46][120] = 183;
+	 Big5PFreq[69][142] = 182;	Big5PFreq[38][175] = 181;
+	 Big5PFreq[22][112] = 180;	Big5PFreq[38][142] = 179;
+	 Big5PFreq[40][37] = 178;	Big5PFreq[37][109] = 177;
+	 Big5PFreq[40][144] = 176;	Big5PFreq[44][117] = 175;
+	 Big5PFreq[35][181] = 174;	Big5PFreq[26][105] = 173;
+	 Big5PFreq[16][48] = 172;	Big5PFreq[44][122] = 171;
+	 Big5PFreq[12][86] = 170;	Big5PFreq[84][53] = 169;
+	 Big5PFreq[17][44] = 168;	Big5PFreq[59][54] = 167;
+	 Big5PFreq[36][98] = 166;	Big5PFreq[45][115] = 165;
+	 Big5PFreq[73][9] = 164;	Big5PFreq[44][123] = 163;
+	 Big5PFreq[37][188] = 162;	Big5PFreq[51][117] = 161;
+	 Big5PFreq[15][156] = 160;	Big5PFreq[36][155] = 159;
+	 Big5PFreq[44][25] = 158;	Big5PFreq[38][12] = 157;
+	 Big5PFreq[38][140] = 156;	Big5PFreq[23][4] = 155;
+	 Big5PFreq[45][149] = 154;	Big5PFreq[22][189] = 153;
+	 Big5PFreq[38][147] = 152;	Big5PFreq[27][5] = 151;
+	 Big5PFreq[22][42] = 150;	Big5PFreq[3][68] = 149;
+	 Big5PFreq[39][51] = 148;	Big5PFreq[36][29] = 147;
+	 Big5PFreq[20][108] = 146;	Big5PFreq[50][57] = 145;
+	 Big5PFreq[55][104] = 144;	Big5PFreq[22][46] = 143;
+	 Big5PFreq[18][164] = 142;	Big5PFreq[50][159] = 141;
+	 Big5PFreq[85][131] = 140;	Big5PFreq[26][79] = 139;
+	 Big5PFreq[38][100] = 138;	Big5PFreq[53][112] = 137;
+	 Big5PFreq[20][190] = 136;	Big5PFreq[14][69] = 135;
+	 Big5PFreq[23][11] = 134;	Big5PFreq[40][114] = 133;
+	 Big5PFreq[40][148] = 132;	Big5PFreq[53][130] = 131;
+	 Big5PFreq[36][2] = 130;	Big5PFreq[66][82] = 129;
+	 Big5PFreq[45][166] = 128;	Big5PFreq[4][88] = 127;
+	 Big5PFreq[16][57] = 126;	Big5PFreq[22][116] = 125;
+	 Big5PFreq[36][108] = 124;	Big5PFreq[13][48] = 123;
+	 Big5PFreq[54][12] = 122;	Big5PFreq[40][136] = 121;
+	 Big5PFreq[36][128] = 120;	Big5PFreq[23][6] = 119;
+	 Big5PFreq[38][125] = 118;	Big5PFreq[45][154] = 117;
+	 Big5PFreq[51][127] = 116;	Big5PFreq[44][163] = 115;
+	 Big5PFreq[16][173] = 114;	Big5PFreq[43][49] = 113;
+	 Big5PFreq[20][112] = 112;	Big5PFreq[15][168] = 111;
+	 Big5PFreq[35][129] = 110;	Big5PFreq[20][45] = 109;
+	 Big5PFreq[38][10] = 108;	Big5PFreq[57][171] = 107;
+	 Big5PFreq[44][190] = 106;	Big5PFreq[40][56] = 105;
+	 Big5PFreq[36][156] = 104;	Big5PFreq[3][88] = 103;
+	 Big5PFreq[50][122] = 102;	Big5PFreq[36][7] = 101;
+	 Big5PFreq[39][43] = 100;	Big5PFreq[15][166] = 99;
+	 Big5PFreq[42][136] = 98;	Big5PFreq[22][131] = 97;
+	 Big5PFreq[44][23] = 96;	Big5PFreq[54][147] = 95;
+	 Big5PFreq[41][32] = 94;	Big5PFreq[23][121] = 93;
+	 Big5PFreq[39][108] = 92;	Big5PFreq[2][78] = 91;
+	 Big5PFreq[40][155] = 90;	Big5PFreq[55][51] = 89;
+	 Big5PFreq[19][34] = 88;	Big5PFreq[48][128] = 87;
+	 Big5PFreq[48][159] = 86;	Big5PFreq[20][70] = 85;
+	 Big5PFreq[34][71] = 84;	Big5PFreq[16][31] = 83;
+	 Big5PFreq[42][157] = 82;	Big5PFreq[20][44] = 81;
+	 Big5PFreq[11][92] = 80;	Big5PFreq[44][180] = 79;
+	 Big5PFreq[84][33] = 78;	Big5PFreq[16][116] = 77;
+	 Big5PFreq[61][163] = 76;	Big5PFreq[35][164] = 75;
+	 Big5PFreq[36][42] = 74;	Big5PFreq[13][40] = 73;
+	 Big5PFreq[43][176] = 72;	Big5PFreq[2][66] = 71;
+	 Big5PFreq[20][133] = 70;	Big5PFreq[36][65] = 69;
+	 Big5PFreq[38][33] = 68;	Big5PFreq[12][91] = 67;
+	 Big5PFreq[36][26] = 66;	Big5PFreq[15][174] = 65;
+	 Big5PFreq[77][32] = 64;	Big5PFreq[16][1] = 63;
+	 Big5PFreq[25][86] = 62;	Big5PFreq[17][13] = 61;
+	 Big5PFreq[5][75] = 60;	Big5PFreq[36][52] = 59;
+	 Big5PFreq[51][164] = 58;	Big5PFreq[12][85] = 57;
+	 Big5PFreq[39][168] = 56;	Big5PFreq[43][16] = 55;
+	 Big5PFreq[40][69] = 54;	Big5PFreq[26][108] = 53;
+	 Big5PFreq[51][56] = 52;	Big5PFreq[16][37] = 51;
+	 Big5PFreq[40][29] = 50;	Big5PFreq[46][171] = 49;
+	 Big5PFreq[40][128] = 48;	Big5PFreq[72][114] = 47;
+	 Big5PFreq[21][103] = 46;	Big5PFreq[22][44] = 45;
+	 Big5PFreq[40][115] = 44;	Big5PFreq[43][7] = 43;
+	 Big5PFreq[43][153] = 42;	Big5PFreq[17][20] = 41;
+	 Big5PFreq[16][49] = 40;	Big5PFreq[36][57] = 39;
+	 Big5PFreq[18][38] = 38;	Big5PFreq[45][184] = 37;
+	 Big5PFreq[37][167] = 36;	Big5PFreq[26][106] = 35;
+	 Big5PFreq[61][121] = 34;	Big5PFreq[89][140] = 33;
+	 Big5PFreq[46][61] = 32;	Big5PFreq[39][163] = 31;
+	 Big5PFreq[40][62] = 30;	Big5PFreq[38][165] = 29;
+	 Big5PFreq[47][37] = 28;	Big5PFreq[18][155] = 27;
+	 Big5PFreq[20][33] = 26;	Big5PFreq[29][90] = 25;
+	 Big5PFreq[20][103] = 24;	Big5PFreq[37][51] = 23;
+	 Big5PFreq[57][0] = 22;	Big5PFreq[40][31] = 21;
+	 Big5PFreq[45][32] = 20;	Big5PFreq[59][23] = 19;
+	 Big5PFreq[18][47] = 18;	Big5PFreq[45][134] = 17;
+	 Big5PFreq[37][59] = 16;	Big5PFreq[21][128] = 15;
+	 Big5PFreq[36][106] = 14;	Big5PFreq[31][39] = 13;
+	 Big5PFreq[40][182] = 12;	Big5PFreq[52][155] = 11;
+	 Big5PFreq[42][166] = 10;	Big5PFreq[35][27] = 9;
+	 Big5PFreq[38][3] = 8;	Big5PFreq[13][44] = 7;
+	 Big5PFreq[58][157] = 6;	Big5PFreq[47][51] = 5;
+	 Big5PFreq[41][37] = 4;	Big5PFreq[41][172] = 3;
+	 Big5PFreq[51][165] = 2;	Big5PFreq[15][161] = 1;
+	 Big5PFreq[24][181] = 0;
+	 */
+	/*
+	 EUC_TWFreq[45][90] = 600;
+	 EUC_TWFreq[48][49] = 599;
+	 EUC_TWFreq[35][65] = 598;	EUC_TWFreq[41][27] = 597;
+	 EUC_TWFreq[35][0] = 596;	EUC_TWFreq[39][19] = 595;
+	 EUC_TWFreq[35][42] = 594;	EUC_TWFreq[38][66] = 593;
+	 EUC_TWFreq[35][8] = 592;	EUC_TWFreq[35][6] = 591;
+	 EUC_TWFreq[35][66] = 590;	EUC_TWFreq[43][14] = 589;
+	 EUC_TWFreq[69][80] = 588;	EUC_TWFreq[50][48] = 587;
+	 EUC_TWFreq[36][71] = 586;	EUC_TWFreq[37][10] = 585;
+	 EUC_TWFreq[60][52] = 584;	EUC_TWFreq[51][21] = 583;
+	 EUC_TWFreq[40][2] = 582;	EUC_TWFreq[67][35] = 581;
+	 EUC_TWFreq[38][78] = 580;	EUC_TWFreq[49][18] = 579;
+	 EUC_TWFreq[35][23] = 578;	EUC_TWFreq[42][83] = 577;
+	 EUC_TWFreq[79][47] = 576;	EUC_TWFreq[61][82] = 575;
+	 EUC_TWFreq[38][7] = 574;	EUC_TWFreq[35][29] = 573;
+	 EUC_TWFreq[37][77] = 572;	EUC_TWFreq[54][67] = 571;
+	 EUC_TWFreq[38][80] = 570;	EUC_TWFreq[52][74] = 569;
+	 EUC_TWFreq[36][37] = 568;	EUC_TWFreq[74][8] = 567;
+	 EUC_TWFreq[41][83] = 566;	EUC_TWFreq[36][75] = 565;
+	 EUC_TWFreq[49][63] = 564;	EUC_TWFreq[42][58] = 563;
+	 EUC_TWFreq[56][33] = 562;	EUC_TWFreq[37][76] = 561;
+	 EUC_TWFreq[62][39] = 560;	EUC_TWFreq[35][21] = 559;
+	 EUC_TWFreq[70][19] = 558;	EUC_TWFreq[77][88] = 557;
+	 EUC_TWFreq[51][14] = 556;	EUC_TWFreq[36][17] = 555;
+	 EUC_TWFreq[44][51] = 554;	EUC_TWFreq[38][72] = 553;
+	 EUC_TWFreq[74][90] = 552;	EUC_TWFreq[35][48] = 551;
+	 EUC_TWFreq[35][69] = 550;	EUC_TWFreq[66][86] = 549;
+	 EUC_TWFreq[57][20] = 548;	EUC_TWFreq[35][53] = 547;
+	 EUC_TWFreq[36][87] = 546;	EUC_TWFreq[84][67] = 545;
+	 EUC_TWFreq[70][56] = 544;	EUC_TWFreq[71][54] = 543;
+	 EUC_TWFreq[60][70] = 542;	EUC_TWFreq[80][1] = 541;
+	 EUC_TWFreq[39][59] = 540;	EUC_TWFreq[39][51] = 539;
+	 EUC_TWFreq[35][44] = 538;	EUC_TWFreq[48][4] = 537;
+	 EUC_TWFreq[55][24] = 536;	EUC_TWFreq[52][4] = 535;
+	 EUC_TWFreq[54][26] = 534;	EUC_TWFreq[36][31] = 533;
+	 EUC_TWFreq[37][22] = 532;	EUC_TWFreq[37][9] = 531;
+	 EUC_TWFreq[46][0] = 530;	EUC_TWFreq[56][46] = 529;
+	 EUC_TWFreq[47][93] = 528;	EUC_TWFreq[37][25] = 527;
+	 EUC_TWFreq[39][8] = 526;	EUC_TWFreq[46][73] = 525;
+	 EUC_TWFreq[38][48] = 524;	EUC_TWFreq[39][83] = 523;
+	 EUC_TWFreq[60][92] = 522;	EUC_TWFreq[70][11] = 521;
+	 EUC_TWFreq[63][84] = 520;	EUC_TWFreq[38][65] = 519;
+	 EUC_TWFreq[45][45] = 518;	EUC_TWFreq[63][49] = 517;
+	 EUC_TWFreq[63][50] = 516;	EUC_TWFreq[39][93] = 515;
+	 EUC_TWFreq[68][20] = 514;	EUC_TWFreq[44][84] = 513;
+	 EUC_TWFreq[66][34] = 512;	EUC_TWFreq[37][58] = 511;
+	 EUC_TWFreq[39][0] = 510;	EUC_TWFreq[59][1] = 509;
+	 EUC_TWFreq[47][8] = 508;	EUC_TWFreq[61][17] = 507;
+	 EUC_TWFreq[53][87] = 506;	EUC_TWFreq[67][26] = 505;
+	 EUC_TWFreq[43][46] = 504;	EUC_TWFreq[38][61] = 503;
+	 EUC_TWFreq[45][9] = 502;	EUC_TWFreq[66][83] = 501;
+	 EUC_TWFreq[43][88] = 500;	EUC_TWFreq[85][20] = 499;
+	 EUC_TWFreq[57][36] = 498;	EUC_TWFreq[43][6] = 497;
+	 EUC_TWFreq[86][77] = 496;	EUC_TWFreq[42][70] = 495;
+	 EUC_TWFreq[49][78] = 494;	EUC_TWFreq[36][40] = 493;
+	 EUC_TWFreq[42][71] = 492;	EUC_TWFreq[58][49] = 491;
+	 EUC_TWFreq[35][20] = 490;	EUC_TWFreq[76][20] = 489;
+	 EUC_TWFreq[39][25] = 488;	EUC_TWFreq[40][34] = 487;
+	 EUC_TWFreq[39][76] = 486;	EUC_TWFreq[40][1] = 485;
+	 EUC_TWFreq[59][0] = 484;	EUC_TWFreq[39][70] = 483;
+	 EUC_TWFreq[46][14] = 482;	EUC_TWFreq[68][77] = 481;
+	 EUC_TWFreq[38][55] = 480;	EUC_TWFreq[35][78] = 479;
+	 EUC_TWFreq[84][44] = 478;	EUC_TWFreq[36][41] = 477;
+	 EUC_TWFreq[37][62] = 476;	EUC_TWFreq[65][67] = 475;
+	 EUC_TWFreq[69][66] = 474;	EUC_TWFreq[73][55] = 473;
+	 EUC_TWFreq[71][49] = 472;	EUC_TWFreq[66][87] = 471;
+	 EUC_TWFreq[38][33] = 470;	EUC_TWFreq[64][61] = 469;
+	 EUC_TWFreq[35][7] = 468;	EUC_TWFreq[47][49] = 467;
+	 EUC_TWFreq[56][14] = 466;	EUC_TWFreq[36][49] = 465;
+	 EUC_TWFreq[50][81] = 464;	EUC_TWFreq[55][76] = 463;
+	 EUC_TWFreq[35][19] = 462;	EUC_TWFreq[44][47] = 461;
+	 EUC_TWFreq[35][15] = 460;	EUC_TWFreq[82][59] = 459;
+	 EUC_TWFreq[35][43] = 458;	EUC_TWFreq[73][0] = 457;
+	 EUC_TWFreq[57][83] = 456;	EUC_TWFreq[42][46] = 455;
+	 EUC_TWFreq[36][0] = 454;	EUC_TWFreq[70][88] = 453;
+	 EUC_TWFreq[42][22] = 452;	EUC_TWFreq[46][58] = 451;
+	 EUC_TWFreq[36][34] = 450;	EUC_TWFreq[39][24] = 449;
+	 EUC_TWFreq[35][55] = 448;	EUC_TWFreq[44][91] = 447;
+	 EUC_TWFreq[37][51] = 446;	EUC_TWFreq[36][19] = 445;
+	 EUC_TWFreq[69][90] = 444;	EUC_TWFreq[55][35] = 443;
+	 EUC_TWFreq[35][54] = 442;	EUC_TWFreq[49][61] = 441;
+	 EUC_TWFreq[36][67] = 440;	EUC_TWFreq[88][34] = 439;
+	 EUC_TWFreq[35][17] = 438;	EUC_TWFreq[65][69] = 437;
+	 EUC_TWFreq[74][89] = 436;	EUC_TWFreq[37][31] = 435;
+	 EUC_TWFreq[43][48] = 434;	EUC_TWFreq[89][27] = 433;
+	 EUC_TWFreq[42][79] = 432;	EUC_TWFreq[69][57] = 431;
+	 EUC_TWFreq[36][13] = 430;	EUC_TWFreq[35][62] = 429;
+	 EUC_TWFreq[65][47] = 428;	EUC_TWFreq[56][8] = 427;
+	 EUC_TWFreq[38][79] = 426;	EUC_TWFreq[37][64] = 425;
+	 EUC_TWFreq[64][64] = 424;	EUC_TWFreq[38][53] = 423;
+	 EUC_TWFreq[38][31] = 422;	EUC_TWFreq[56][81] = 421;
+	 EUC_TWFreq[36][22] = 420;	EUC_TWFreq[43][4] = 419;
+	 EUC_TWFreq[36][90] = 418;	EUC_TWFreq[38][62] = 417;
+	 EUC_TWFreq[66][85] = 416;	EUC_TWFreq[39][1] = 415;
+	 EUC_TWFreq[59][40] = 414;	EUC_TWFreq[58][93] = 413;
+	 EUC_TWFreq[44][43] = 412;	EUC_TWFreq[39][49] = 411;
+	 EUC_TWFreq[64][2] = 410;	EUC_TWFreq[41][35] = 409;
+	 EUC_TWFreq[60][22] = 408;	EUC_TWFreq[35][91] = 407;
+	 EUC_TWFreq[78][1] = 406;	EUC_TWFreq[36][14] = 405;
+	 EUC_TWFreq[82][29] = 404;	EUC_TWFreq[52][86] = 403;
+	 EUC_TWFreq[40][16] = 402;	EUC_TWFreq[91][52] = 401;
+	 EUC_TWFreq[50][75] = 400;	EUC_TWFreq[64][30] = 399;
+	 EUC_TWFreq[90][78] = 398;	EUC_TWFreq[36][52] = 397;
+	 EUC_TWFreq[55][87] = 396;	EUC_TWFreq[57][5] = 395;
+	 EUC_TWFreq[57][31] = 394;	EUC_TWFreq[42][35] = 393;
+	 EUC_TWFreq[69][50] = 392;	EUC_TWFreq[45][8] = 391;
+	 EUC_TWFreq[50][87] = 390;	EUC_TWFreq[69][55] = 389;
+	 EUC_TWFreq[92][3] = 388;	EUC_TWFreq[36][43] = 387;
+	 EUC_TWFreq[64][10] = 386;	EUC_TWFreq[56][25] = 385;
+	 EUC_TWFreq[60][68] = 384;	EUC_TWFreq[51][46] = 383;
+	 EUC_TWFreq[50][0] = 382;	EUC_TWFreq[38][30] = 381;
+	 EUC_TWFreq[50][85] = 380;	EUC_TWFreq[60][54] = 379;
+	 EUC_TWFreq[73][6] = 378;	EUC_TWFreq[73][28] = 377;
+	 EUC_TWFreq[56][19] = 376;	EUC_TWFreq[62][69] = 375;
+	 EUC_TWFreq[81][66] = 374;	EUC_TWFreq[40][32] = 373;
+	 EUC_TWFreq[76][31] = 372;	EUC_TWFreq[35][10] = 371;
+	 EUC_TWFreq[41][37] = 370;	EUC_TWFreq[52][82] = 369;
+	 EUC_TWFreq[91][72] = 368;	EUC_TWFreq[37][29] = 367;
+	 EUC_TWFreq[56][30] = 366;	EUC_TWFreq[37][80] = 365;
+	 EUC_TWFreq[81][56] = 364;	EUC_TWFreq[70][3] = 363;
+	 EUC_TWFreq[76][15] = 362;	EUC_TWFreq[46][47] = 361;
+	 EUC_TWFreq[35][88] = 360;	EUC_TWFreq[61][58] = 359;
+	 EUC_TWFreq[37][37] = 358;	EUC_TWFreq[57][22] = 357;
+	 EUC_TWFreq[41][23] = 356;	EUC_TWFreq[90][66] = 355;
+	 EUC_TWFreq[39][60] = 354;	EUC_TWFreq[38][0] = 353;
+	 EUC_TWFreq[37][87] = 352;	EUC_TWFreq[46][2] = 351;
+	 EUC_TWFreq[38][56] = 350;	EUC_TWFreq[58][11] = 349;
+	 EUC_TWFreq[48][10] = 348;	EUC_TWFreq[74][4] = 347;
+	 EUC_TWFreq[40][42] = 346;	EUC_TWFreq[41][52] = 345;
+	 EUC_TWFreq[61][92] = 344;	EUC_TWFreq[39][50] = 343;
+	 EUC_TWFreq[47][88] = 342;	EUC_TWFreq[88][36] = 341;
+	 EUC_TWFreq[45][73] = 340;	EUC_TWFreq[82][3] = 339;
+	 EUC_TWFreq[61][36] = 338;	EUC_TWFreq[60][33] = 337;
+	 EUC_TWFreq[38][27] = 336;	EUC_TWFreq[35][83] = 335;
+	 EUC_TWFreq[65][24] = 334;	EUC_TWFreq[73][10] = 333;
+	 EUC_TWFreq[41][13] = 332;	EUC_TWFreq[50][27] = 331;
+	 EUC_TWFreq[59][50] = 330;	EUC_TWFreq[42][45] = 329;
+	 EUC_TWFreq[55][19] = 328;	EUC_TWFreq[36][77] = 327;
+	 EUC_TWFreq[69][31] = 326;	EUC_TWFreq[60][7] = 325;
+	 EUC_TWFreq[40][88] = 324;	EUC_TWFreq[57][56] = 323;
+	 EUC_TWFreq[50][50] = 322;	EUC_TWFreq[42][37] = 321;
+	 EUC_TWFreq[38][82] = 320;	EUC_TWFreq[52][25] = 319;
+	 EUC_TWFreq[42][67] = 318;	EUC_TWFreq[48][40] = 317;
+	 EUC_TWFreq[45][81] = 316;	EUC_TWFreq[57][14] = 315;
+	 EUC_TWFreq[42][13] = 314;	EUC_TWFreq[78][0] = 313;
+	 EUC_TWFreq[35][51] = 312;	EUC_TWFreq[41][67] = 311;
+	 EUC_TWFreq[64][23] = 310;	EUC_TWFreq[36][65] = 309;
+	 EUC_TWFreq[48][50] = 308;	EUC_TWFreq[46][69] = 307;
+	 EUC_TWFreq[47][89] = 306;	EUC_TWFreq[41][48] = 305;
+	 EUC_TWFreq[60][56] = 304;	EUC_TWFreq[44][82] = 303;
+	 EUC_TWFreq[47][35] = 302;	EUC_TWFreq[49][3] = 301;
+	 EUC_TWFreq[49][69] = 300;	EUC_TWFreq[45][93] = 299;
+	 EUC_TWFreq[60][34] = 298;	EUC_TWFreq[60][82] = 297;
+	 EUC_TWFreq[61][61] = 296;	EUC_TWFreq[86][42] = 295;
+	 EUC_TWFreq[89][60] = 294;	EUC_TWFreq[48][31] = 293;
+	 EUC_TWFreq[35][75] = 292;	EUC_TWFreq[91][39] = 291;
+	 EUC_TWFreq[53][19] = 290;	EUC_TWFreq[39][72] = 289;
+	 EUC_TWFreq[69][59] = 288;	EUC_TWFreq[41][7] = 287;
+	 EUC_TWFreq[54][13] = 286;	EUC_TWFreq[43][28] = 285;
+	 EUC_TWFreq[36][6] = 284;	EUC_TWFreq[45][75] = 283;
+	 EUC_TWFreq[36][61] = 282;	EUC_TWFreq[38][21] = 281;
+	 EUC_TWFreq[45][14] = 280;	EUC_TWFreq[61][43] = 279;
+	 EUC_TWFreq[36][63] = 278;	EUC_TWFreq[43][30] = 277;
+	 EUC_TWFreq[46][51] = 276;	EUC_TWFreq[68][87] = 275;
+	 EUC_TWFreq[39][26] = 274;	EUC_TWFreq[46][76] = 273;
+	 EUC_TWFreq[36][15] = 272;	EUC_TWFreq[35][40] = 271;
+	 EUC_TWFreq[79][60] = 270;	EUC_TWFreq[46][7] = 269;
+	 EUC_TWFreq[65][72] = 268;	EUC_TWFreq[69][88] = 267;
+	 EUC_TWFreq[47][18] = 266;	EUC_TWFreq[37][0] = 265;
+	 EUC_TWFreq[37][49] = 264;	EUC_TWFreq[67][37] = 263;
+	 EUC_TWFreq[36][91] = 262;	EUC_TWFreq[75][48] = 261;
+	 EUC_TWFreq[75][63] = 260;	EUC_TWFreq[83][87] = 259;
+	 EUC_TWFreq[37][44] = 258;	EUC_TWFreq[73][54] = 257;
+	 EUC_TWFreq[51][61] = 256;	EUC_TWFreq[46][57] = 255;
+	 EUC_TWFreq[55][21] = 254;	EUC_TWFreq[39][66] = 253;
+	 EUC_TWFreq[47][11] = 252;	EUC_TWFreq[52][8] = 251;
+	 EUC_TWFreq[82][81] = 250;	EUC_TWFreq[36][57] = 249;
+	 EUC_TWFreq[38][54] = 248;	EUC_TWFreq[43][81] = 247;
+	 EUC_TWFreq[37][42] = 246;	EUC_TWFreq[40][18] = 245;
+	 EUC_TWFreq[80][90] = 244;	EUC_TWFreq[37][84] = 243;
+	 EUC_TWFreq[57][15] = 242;	EUC_TWFreq[38][87] = 241;
+	 EUC_TWFreq[37][32] = 240;	EUC_TWFreq[53][53] = 239;
+	 EUC_TWFreq[89][29] = 238;	EUC_TWFreq[81][53] = 237;
+	 EUC_TWFreq[75][3] = 236;	EUC_TWFreq[83][73] = 235;
+	 EUC_TWFreq[66][13] = 234;	EUC_TWFreq[48][7] = 233;
+	 EUC_TWFreq[46][35] = 232;	EUC_TWFreq[35][86] = 231;
+	 EUC_TWFreq[37][20] = 230;	EUC_TWFreq[46][80] = 229;
+	 EUC_TWFreq[38][24] = 228;	EUC_TWFreq[41][68] = 227;
+	 EUC_TWFreq[42][21] = 226;	EUC_TWFreq[43][32] = 225;
+	 EUC_TWFreq[38][20] = 224;	EUC_TWFreq[37][59] = 223;
+	 EUC_TWFreq[41][77] = 222;	EUC_TWFreq[59][57] = 221;
+	 EUC_TWFreq[68][59] = 220;	EUC_TWFreq[39][43] = 219;
+	 EUC_TWFreq[54][39] = 218;	EUC_TWFreq[48][28] = 217;
+	 EUC_TWFreq[54][28] = 216;	EUC_TWFreq[41][44] = 215;
+	 EUC_TWFreq[51][64] = 214;	EUC_TWFreq[47][72] = 213;
+	 EUC_TWFreq[62][67] = 212;	EUC_TWFreq[42][43] = 211;
+	 EUC_TWFreq[61][38] = 210;	EUC_TWFreq[76][25] = 209;
+	 EUC_TWFreq[48][91] = 208;	EUC_TWFreq[36][36] = 207;
+	 EUC_TWFreq[80][32] = 206;	EUC_TWFreq[81][40] = 205;
+	 EUC_TWFreq[37][5] = 204;	EUC_TWFreq[74][69] = 203;
+	 EUC_TWFreq[36][82] = 202;	EUC_TWFreq[46][59] = 201;
+	 EUC_TWFreq[38][32] = 200;	EUC_TWFreq[74][2] = 199;
+	 EUC_TWFreq[53][31] = 198;	EUC_TWFreq[35][38] = 197;
+	 EUC_TWFreq[46][62] = 196;	EUC_TWFreq[77][31] = 195;
+	 EUC_TWFreq[55][74] = 194;	EUC_TWFreq[66][6] = 193;
+	 EUC_TWFreq[56][21] = 192;	EUC_TWFreq[54][78] = 191;
+	 EUC_TWFreq[43][51] = 190;	EUC_TWFreq[64][93] = 189;
+	 EUC_TWFreq[92][7] = 188;	EUC_TWFreq[83][89] = 187;
+	 EUC_TWFreq[69][9] = 186;	EUC_TWFreq[45][4] = 185;
+	 EUC_TWFreq[53][9] = 184;	EUC_TWFreq[43][2] = 183;
+	 EUC_TWFreq[35][11] = 182;	EUC_TWFreq[51][25] = 181;
+	 EUC_TWFreq[52][71] = 180;	EUC_TWFreq[81][67] = 179;
+	 EUC_TWFreq[37][33] = 178;	EUC_TWFreq[38][57] = 177;
+	 EUC_TWFreq[39][77] = 176;	EUC_TWFreq[40][26] = 175;
+	 EUC_TWFreq[37][21] = 174;	EUC_TWFreq[81][70] = 173;
+	 EUC_TWFreq[56][80] = 172;	EUC_TWFreq[65][14] = 171;
+	 EUC_TWFreq[62][47] = 170;	EUC_TWFreq[56][54] = 169;
+	 EUC_TWFreq[45][17] = 168;	EUC_TWFreq[52][52] = 167;
+	 EUC_TWFreq[74][30] = 166;	EUC_TWFreq[60][57] = 165;
+	 EUC_TWFreq[41][15] = 164;	EUC_TWFreq[47][69] = 163;
+	 EUC_TWFreq[61][11] = 162;	EUC_TWFreq[72][25] = 161;
+	 EUC_TWFreq[82][56] = 160;	EUC_TWFreq[76][92] = 159;
+	 EUC_TWFreq[51][22] = 158;	EUC_TWFreq[55][69] = 157;
+	 EUC_TWFreq[49][43] = 156;	EUC_TWFreq[69][49] = 155;
+	 EUC_TWFreq[88][42] = 154;	EUC_TWFreq[84][41] = 153;
+	 EUC_TWFreq[79][33] = 152;	EUC_TWFreq[47][17] = 151;
+	 EUC_TWFreq[52][88] = 150;	EUC_TWFreq[63][74] = 149;
+	 EUC_TWFreq[50][32] = 148;	EUC_TWFreq[65][10] = 147;
+	 EUC_TWFreq[57][6] = 146;	EUC_TWFreq[52][23] = 145;
+	 EUC_TWFreq[36][70] = 144;	EUC_TWFreq[65][55] = 143;
+	 EUC_TWFreq[35][27] = 142;	EUC_TWFreq[57][63] = 141;
+	 EUC_TWFreq[39][92] = 140;	EUC_TWFreq[79][75] = 139;
+	 EUC_TWFreq[36][30] = 138;	EUC_TWFreq[53][60] = 137;
+	 EUC_TWFreq[55][43] = 136;	EUC_TWFreq[71][22] = 135;
+	 EUC_TWFreq[43][16] = 134;	EUC_TWFreq[65][21] = 133;
+	 EUC_TWFreq[84][51] = 132;	EUC_TWFreq[43][64] = 131;
+	 EUC_TWFreq[87][91] = 130;	EUC_TWFreq[47][45] = 129;
+	 EUC_TWFreq[65][29] = 128;	EUC_TWFreq[88][16] = 127;
+	 EUC_TWFreq[50][5] = 126;	EUC_TWFreq[47][33] = 125;
+	 EUC_TWFreq[46][27] = 124;	EUC_TWFreq[85][2] = 123;
+	 EUC_TWFreq[43][77] = 122;	EUC_TWFreq[70][9] = 121;
+	 EUC_TWFreq[41][54] = 120;	EUC_TWFreq[56][12] = 119;
+	 EUC_TWFreq[90][65] = 118;	EUC_TWFreq[91][50] = 117;
+	 EUC_TWFreq[48][41] = 116;	EUC_TWFreq[35][89] = 115;
+	 EUC_TWFreq[90][83] = 114;	EUC_TWFreq[44][40] = 113;
+	 EUC_TWFreq[50][88] = 112;	EUC_TWFreq[72][39] = 111;
+	 EUC_TWFreq[45][3] = 110;	EUC_TWFreq[71][33] = 109;
+	 EUC_TWFreq[39][12] = 108;	EUC_TWFreq[59][24] = 107;
+	 EUC_TWFreq[60][62] = 106;	EUC_TWFreq[44][33] = 105;
+	 EUC_TWFreq[53][70] = 104;	EUC_TWFreq[77][90] = 103;
+	 EUC_TWFreq[50][58] = 102;	EUC_TWFreq[54][1] = 101;
+	 EUC_TWFreq[73][19] = 100;	EUC_TWFreq[37][3] = 99;
+	 EUC_TWFreq[49][91] = 98;	EUC_TWFreq[88][43] = 97;
+	 EUC_TWFreq[36][78] = 96;	EUC_TWFreq[44][20] = 95;
+	 EUC_TWFreq[64][15] = 94;	EUC_TWFreq[72][28] = 93;
+	 EUC_TWFreq[70][13] = 92;	EUC_TWFreq[65][83] = 91;
+	 EUC_TWFreq[58][68] = 90;	EUC_TWFreq[59][32] = 89;
+	 EUC_TWFreq[39][13] = 88;	EUC_TWFreq[55][64] = 87;
+	 EUC_TWFreq[56][59] = 86;	EUC_TWFreq[39][17] = 85;
+	 EUC_TWFreq[55][84] = 84;	EUC_TWFreq[77][85] = 83;
+	 EUC_TWFreq[60][19] = 82;	EUC_TWFreq[62][82] = 81;
+	 EUC_TWFreq[78][16] = 80;	EUC_TWFreq[66][8] = 79;
+	 EUC_TWFreq[39][42] = 78;	EUC_TWFreq[61][24] = 77;
+	 EUC_TWFreq[57][67] = 76;	EUC_TWFreq[38][83] = 75;
+	 EUC_TWFreq[36][53] = 74;	EUC_TWFreq[67][76] = 73;
+	 EUC_TWFreq[37][91] = 72;	EUC_TWFreq[44][26] = 71;
+	 EUC_TWFreq[72][86] = 70;	EUC_TWFreq[44][87] = 69;
+	 EUC_TWFreq[45][50] = 68;	EUC_TWFreq[58][4] = 67;
+	 EUC_TWFreq[86][65] = 66;	EUC_TWFreq[45][56] = 65;
+	 EUC_TWFreq[79][49] = 64;	EUC_TWFreq[35][3] = 63;
+	 EUC_TWFreq[48][83] = 62;	EUC_TWFreq[71][21] = 61;
+	 EUC_TWFreq[77][93] = 60;	EUC_TWFreq[87][92] = 59;
+	 EUC_TWFreq[38][35] = 58;	EUC_TWFreq[66][17] = 57;
+	 EUC_TWFreq[37][66] = 56;	EUC_TWFreq[51][42] = 55;
+	 EUC_TWFreq[57][73] = 54;	EUC_TWFreq[51][54] = 53;
+	 EUC_TWFreq[75][64] = 52;	EUC_TWFreq[35][5] = 51;
+	 EUC_TWFreq[49][40] = 50;	EUC_TWFreq[58][35] = 49;
+	 EUC_TWFreq[67][88] = 48;	EUC_TWFreq[60][51] = 47;
+	 EUC_TWFreq[36][92] = 46;	EUC_TWFreq[44][41] = 45;
+	 EUC_TWFreq[58][29] = 44;	EUC_TWFreq[43][62] = 43;
+	 EUC_TWFreq[56][23] = 42;	EUC_TWFreq[67][44] = 41;
+	 EUC_TWFreq[52][91] = 40;	EUC_TWFreq[42][81] = 39;
+	 EUC_TWFreq[64][25] = 38;	EUC_TWFreq[35][36] = 37;
+	 EUC_TWFreq[47][73] = 36;	EUC_TWFreq[36][1] = 35;
+	 EUC_TWFreq[65][84] = 34;	EUC_TWFreq[73][1] = 33;
+	 EUC_TWFreq[79][66] = 32;	EUC_TWFreq[69][14] = 31;
+	 EUC_TWFreq[65][28] = 30;	EUC_TWFreq[60][93] = 29;
+	 EUC_TWFreq[72][79] = 28;	EUC_TWFreq[48][0] = 27;
+	 EUC_TWFreq[73][43] = 26;	EUC_TWFreq[66][47] = 25;
+	 EUC_TWFreq[41][18] = 24;	EUC_TWFreq[51][10] = 23;
+	 EUC_TWFreq[59][7] = 22;	EUC_TWFreq[53][27] = 21;
+	 EUC_TWFreq[86][67] = 20;	EUC_TWFreq[49][87] = 19;
+	 EUC_TWFreq[52][28] = 18;	EUC_TWFreq[52][12] = 17;
+	 EUC_TWFreq[42][30] = 16;	EUC_TWFreq[65][35] = 15;
+	 EUC_TWFreq[46][64] = 14;	EUC_TWFreq[71][7] = 13;
+	 EUC_TWFreq[56][57] = 12;	EUC_TWFreq[56][31] = 11;
+	 EUC_TWFreq[41][31] = 10;	EUC_TWFreq[48][59] = 9;
+	 EUC_TWFreq[63][92] = 8;	EUC_TWFreq[62][57] = 7;
+	 EUC_TWFreq[65][87] = 6;	EUC_TWFreq[70][10] = 5;
+	 EUC_TWFreq[52][40] = 4;	EUC_TWFreq[40][22] = 3;
+	 EUC_TWFreq[65][91] = 2;	EUC_TWFreq[50][25] = 1;
+	 EUC_TWFreq[35][84] = 0;
+	 */
+	KRFreq[31][43] = 600;
+	KRFreq[19][56] = 599;
+	KRFreq[38][46] = 598;
+	KRFreq[3][3] = 597;
+	KRFreq[29][77] = 596;
+	KRFreq[19][33] = 595;
+	KRFreq[30][0] = 594;
+	KRFreq[29][89] = 593;
+	KRFreq[31][26] = 592;
+	KRFreq[31][38] = 591;
+	KRFreq[32][85] = 590;
+	KRFreq[15][0] = 589;
+	KRFreq[16][54] = 588;
+	KRFreq[15][76] = 587;
+	KRFreq[31][25] = 586;
+	KRFreq[23][13] = 585;
+	KRFreq[28][34] = 584;
+	KRFreq[18][9] = 583;
+	KRFreq[29][37] = 582;
+	KRFreq[22][45] = 581;
+	KRFreq[19][46] = 580;
+	KRFreq[16][65] = 579;
+	KRFreq[23][5] = 578;
+	KRFreq[26][70] = 577;
+	KRFreq[31][53] = 576;
+	KRFreq[27][12] = 575;
+	KRFreq[30][67] = 574;
+	KRFreq[31][57] = 573;
+	KRFreq[20][20] = 572;
+	KRFreq[30][31] = 571;
+	KRFreq[20][72] = 570;
+	KRFreq[15][51] = 569;
+	KRFreq[3][8] = 568;
+	KRFreq[32][53] = 567;
+	KRFreq[27][85] = 566;
+	KRFreq[25][23] = 565;
+	KRFreq[15][44] = 564;
+	KRFreq[32][3] = 563;
+	KRFreq[31][68] = 562;
+	KRFreq[30][24] = 561;
+	KRFreq[29][49] = 560;
+	KRFreq[27][49] = 559;
+	KRFreq[23][23] = 558;
+	KRFreq[31][91] = 557;
+	KRFreq[31][46] = 556;
+	KRFreq[19][74] = 555;
+	KRFreq[27][27] = 554;
+	KRFreq[3][17] = 553;
+	KRFreq[20][38] = 552;
+	KRFreq[21][82] = 551;
+	KRFreq[28][25] = 550;
+	KRFreq[32][5] = 549;
+	KRFreq[31][23] = 548;
+	KRFreq[25][45] = 547;
+	KRFreq[32][87] = 546;
+	KRFreq[18][26] = 545;
+	KRFreq[24][10] = 544;
+	KRFreq[26][82] = 543;
+	KRFreq[15][89] = 542;
+	KRFreq[28][36] = 541;
+	KRFreq[28][31] = 540;
+	KRFreq[16][23] = 539;
+	KRFreq[16][77] = 538;
+	KRFreq[19][84] = 537;
+	KRFreq[23][72] = 536;
+	KRFreq[38][48] = 535;
+	KRFreq[23][2] = 534;
+	KRFreq[30][20] = 533;
+	KRFreq[38][47] = 532;
+	KRFreq[39][12] = 531;
+	KRFreq[23][21] = 530;
+	KRFreq[18][17] = 529;
+	KRFreq[30][87] = 528;
+	KRFreq[29][62] = 527;
+	KRFreq[29][87] = 526;
+	KRFreq[34][53] = 525;
+	KRFreq[32][29] = 524;
+	KRFreq[35][0] = 523;
+	KRFreq[24][43] = 522;
+	KRFreq[36][44] = 521;
+	KRFreq[20][30] = 520;
+	KRFreq[39][86] = 519;
+	KRFreq[22][14] = 518;
+	KRFreq[29][39] = 517;
+	KRFreq[28][38] = 516;
+	KRFreq[23][79] = 515;
+	KRFreq[24][56] = 514;
+	KRFreq[29][63] = 513;
+	KRFreq[31][45] = 512;
+	KRFreq[23][26] = 511;
+	KRFreq[15][87] = 510;
+	KRFreq[30][74] = 509;
+	KRFreq[24][69] = 508;
+	KRFreq[20][4] = 507;
+	KRFreq[27][50] = 506;
+	KRFreq[30][75] = 505;
+	KRFreq[24][13] = 504;
+	KRFreq[30][8] = 503;
+	KRFreq[31][6] = 502;
+	KRFreq[25][80] = 501;
+	KRFreq[36][8] = 500;
+	KRFreq[15][18] = 499;
+	KRFreq[39][23] = 498;
+	KRFreq[16][24] = 497;
+	KRFreq[31][89] = 496;
+	KRFreq[15][71] = 495;
+	KRFreq[15][57] = 494;
+	KRFreq[30][11] = 493;
+	KRFreq[15][36] = 492;
+	KRFreq[16][60] = 491;
+	KRFreq[24][45] = 490;
+	KRFreq[37][35] = 489;
+	KRFreq[24][87] = 488;
+	KRFreq[20][45] = 487;
+	KRFreq[31][90] = 486;
+	KRFreq[32][21] = 485;
+	KRFreq[19][70] = 484;
+	KRFreq[24][15] = 483;
+	KRFreq[26][92] = 482;
+	KRFreq[37][13] = 481;
+	KRFreq[39][2] = 480;
+	KRFreq[23][70] = 479;
+	KRFreq[27][25] = 478;
+	KRFreq[15][69] = 477;
+	KRFreq[19][61] = 476;
+	KRFreq[31][58] = 475;
+	KRFreq[24][57] = 474;
+	KRFreq[36][74] = 473;
+	KRFreq[21][6] = 472;
+	KRFreq[30][44] = 471;
+	KRFreq[15][91] = 470;
+	KRFreq[27][16] = 469;
+	KRFreq[29][42] = 468;
+	KRFreq[33][86] = 467;
+	KRFreq[29][41] = 466;
+	KRFreq[20][68] = 465;
+	KRFreq[25][47] = 464;
+	KRFreq[22][0] = 463;
+	KRFreq[18][14] = 462;
+	KRFreq[31][28] = 461;
+	KRFreq[15][2] = 460;
+	KRFreq[23][76] = 459;
+	KRFreq[38][32] = 458;
+	KRFreq[29][82] = 457;
+	KRFreq[21][86] = 456;
+	KRFreq[24][62] = 455;
+	KRFreq[31][64] = 454;
+	KRFreq[38][26] = 453;
+	KRFreq[32][86] = 452;
+	KRFreq[22][32] = 451;
+	KRFreq[19][59] = 450;
+	KRFreq[34][18] = 449;
+	KRFreq[18][54] = 448;
+	KRFreq[38][63] = 447;
+	KRFreq[36][23] = 446;
+	KRFreq[35][35] = 445;
+	KRFreq[32][62] = 444;
+	KRFreq[28][35] = 443;
+	KRFreq[27][13] = 442;
+	KRFreq[31][59] = 441;
+	KRFreq[29][29] = 440;
+	KRFreq[15][64] = 439;
+	KRFreq[26][84] = 438;
+	KRFreq[21][90] = 437;
+	KRFreq[20][24] = 436;
+	KRFreq[16][18] = 435;
+	KRFreq[22][23] = 434;
+	KRFreq[31][14] = 433;
+	KRFreq[15][1] = 432;
+	KRFreq[18][63] = 431;
+	KRFreq[19][10] = 430;
+	KRFreq[25][49] = 429;
+	KRFreq[36][57] = 428;
+	KRFreq[20][22] = 427;
+	KRFreq[15][15] = 426;
+	KRFreq[31][51] = 425;
+	KRFreq[24][60] = 424;
+	KRFreq[31][70] = 423;
+	KRFreq[15][7] = 422;
+	KRFreq[28][40] = 421;
+	KRFreq[18][41] = 420;
+	KRFreq[15][38] = 419;
+	KRFreq[32][0] = 418;
+	KRFreq[19][51] = 417;
+	KRFreq[34][62] = 416;
+	KRFreq[16][27] = 415;
+	KRFreq[20][70] = 414;
+	KRFreq[22][33] = 413;
+	KRFreq[26][73] = 412;
+	KRFreq[20][79] = 411;
+	KRFreq[23][6] = 410;
+	KRFreq[24][85] = 409;
+	KRFreq[38][51] = 408;
+	KRFreq[29][88] = 407;
+	KRFreq[38][55] = 406;
+	KRFreq[32][32] = 405;
+	KRFreq[27][18] = 404;
+	KRFreq[23][87] = 403;
+	KRFreq[35][6] = 402;
+	KRFreq[34][27] = 401;
+	KRFreq[39][35] = 400;
+	KRFreq[30][88] = 399;
+	KRFreq[32][92] = 398;
+	KRFreq[32][49] = 397;
+	KRFreq[24][61] = 396;
+	KRFreq[18][74] = 395;
+	KRFreq[23][77] = 394;
+	KRFreq[23][50] = 393;
+	KRFreq[23][32] = 392;
+	KRFreq[23][36] = 391;
+	KRFreq[38][38] = 390;
+	KRFreq[29][86] = 389;
+	KRFreq[36][15] = 388;
+	KRFreq[31][50] = 387;
+	KRFreq[15][86] = 386;
+	KRFreq[39][13] = 385;
+	KRFreq[34][26] = 384;
+	KRFreq[19][34] = 383;
+	KRFreq[16][3] = 382;
+	KRFreq[26][93] = 381;
+	KRFreq[19][67] = 380;
+	KRFreq[24][72] = 379;
+	KRFreq[29][17] = 378;
+	KRFreq[23][24] = 377;
+	KRFreq[25][19] = 376;
+	KRFreq[18][65] = 375;
+	KRFreq[30][78] = 374;
+	KRFreq[27][52] = 373;
+	KRFreq[22][18] = 372;
+	KRFreq[16][38] = 371;
+	KRFreq[21][26] = 370;
+	KRFreq[34][20] = 369;
+	KRFreq[15][42] = 368;
+	KRFreq[16][71] = 367;
+	KRFreq[17][17] = 366;
+	KRFreq[24][71] = 365;
+	KRFreq[18][84] = 364;
+	KRFreq[15][40] = 363;
+	KRFreq[31][62] = 362;
+	KRFreq[15][8] = 361;
+	KRFreq[16][69] = 360;
+	KRFreq[29][79] = 359;
+	KRFreq[38][91] = 358;
+	KRFreq[31][92] = 357;
+	KRFreq[20][77] = 356;
+	KRFreq[3][16] = 355;
+	KRFreq[27][87] = 354;
+	KRFreq[16][25] = 353;
+	KRFreq[36][33] = 352;
+	KRFreq[37][76] = 351;
+	KRFreq[30][12] = 350;
+	KRFreq[26][75] = 349;
+	KRFreq[25][14] = 348;
+	KRFreq[32][26] = 347;
+	KRFreq[23][22] = 346;
+	KRFreq[20][90] = 345;
+	KRFreq[19][8] = 344;
+	KRFreq[38][41] = 343;
+	KRFreq[34][2] = 342;
+	KRFreq[39][4] = 341;
+	KRFreq[27][89] = 340;
+	KRFreq[28][41] = 339;
+	KRFreq[28][44] = 338;
+	KRFreq[24][92] = 337;
+	KRFreq[34][65] = 336;
+	KRFreq[39][14] = 335;
+	KRFreq[21][38] = 334;
+	KRFreq[19][31] = 333;
+	KRFreq[37][39] = 332;
+	KRFreq[33][41] = 331;
+	KRFreq[38][4] = 330;
+	KRFreq[23][80] = 329;
+	KRFreq[25][24] = 328;
+	KRFreq[37][17] = 327;
+	KRFreq[22][16] = 326;
+	KRFreq[22][46] = 325;
+	KRFreq[33][91] = 324;
+	KRFreq[24][89] = 323;
+	KRFreq[30][52] = 322;
+	KRFreq[29][38] = 321;
+	KRFreq[38][85] = 320;
+	KRFreq[15][12] = 319;
+	KRFreq[27][58] = 318;
+	KRFreq[29][52] = 317;
+	KRFreq[37][38] = 316;
+	KRFreq[34][41] = 315;
+	KRFreq[31][65] = 314;
+	KRFreq[29][53] = 313;
+	KRFreq[22][47] = 312;
+	KRFreq[22][19] = 311;
+	KRFreq[26][0] = 310;
+	KRFreq[37][86] = 309;
+	KRFreq[35][4] = 308;
+	KRFreq[36][54] = 307;
+	KRFreq[20][76] = 306;
+	KRFreq[30][9] = 305;
+	KRFreq[30][33] = 304;
+	KRFreq[23][17] = 303;
+	KRFreq[23][33] = 302;
+	KRFreq[38][52] = 301;
+	KRFreq[15][19] = 300;
+	KRFreq[28][45] = 299;
+	KRFreq[29][78] = 298;
+	KRFreq[23][15] = 297;
+	KRFreq[33][5] = 296;
+	KRFreq[17][40] = 295;
+	KRFreq[30][83] = 294;
+	KRFreq[18][1] = 293;
+	KRFreq[30][81] = 292;
+	KRFreq[19][40] = 291;
+	KRFreq[24][47] = 290;
+	KRFreq[17][56] = 289;
+	KRFreq[39][80] = 288;
+	KRFreq[30][46] = 287;
+	KRFreq[16][61] = 286;
+	KRFreq[26][78] = 285;
+	KRFreq[26][57] = 284;
+	KRFreq[20][46] = 283;
+	KRFreq[25][15] = 282;
+	KRFreq[25][91] = 281;
+	KRFreq[21][83] = 280;
+	KRFreq[30][77] = 279;
+	KRFreq[35][30] = 278;
+	KRFreq[30][34] = 277;
+	KRFreq[20][69] = 276;
+	KRFreq[35][10] = 275;
+	KRFreq[29][70] = 274;
+	KRFreq[22][50] = 273;
+	KRFreq[18][0] = 272;
+	KRFreq[22][64] = 271;
+	KRFreq[38][65] = 270;
+	KRFreq[22][70] = 269;
+	KRFreq[24][58] = 268;
+	KRFreq[19][66] = 267;
+	KRFreq[30][59] = 266;
+	KRFreq[37][14] = 265;
+	KRFreq[16][56] = 264;
+	KRFreq[29][85] = 263;
+	KRFreq[31][15] = 262;
+	KRFreq[36][84] = 261;
+	KRFreq[39][15] = 260;
+	KRFreq[39][90] = 259;
+	KRFreq[18][12] = 258;
+	KRFreq[21][93] = 257;
+	KRFreq[24][66] = 256;
+	KRFreq[27][90] = 255;
+	KRFreq[25][90] = 254;
+	KRFreq[22][24] = 253;
+	KRFreq[36][67] = 252;
+	KRFreq[33][90] = 251;
+	KRFreq[15][60] = 250;
+	KRFreq[23][85] = 249;
+	KRFreq[34][1] = 248;
+	KRFreq[39][37] = 247;
+	KRFreq[21][18] = 246;
+	KRFreq[34][4] = 245;
+	KRFreq[28][33] = 244;
+	KRFreq[15][13] = 243;
+	KRFreq[32][22] = 242;
+	KRFreq[30][76] = 241;
+	KRFreq[20][21] = 240;
+	KRFreq[38][66] = 239;
+	KRFreq[32][55] = 238;
+	KRFreq[32][89] = 237;
+	KRFreq[25][26] = 236;
+	KRFreq[16][80] = 235;
+	KRFreq[15][43] = 234;
+	KRFreq[38][54] = 233;
+	KRFreq[39][68] = 232;
+	KRFreq[22][88] = 231;
+	KRFreq[21][84] = 230;
+	KRFreq[21][17] = 229;
+	KRFreq[20][28] = 228;
+	KRFreq[32][1] = 227;
+	KRFreq[33][87] = 226;
+	KRFreq[38][71] = 225;
+	KRFreq[37][47] = 224;
+	KRFreq[18][77] = 223;
+	KRFreq[37][58] = 222;
+	KRFreq[34][74] = 221;
+	KRFreq[32][54] = 220;
+	KRFreq[27][33] = 219;
+	KRFreq[32][93] = 218;
+	KRFreq[23][51] = 217;
+	KRFreq[20][57] = 216;
+	KRFreq[22][37] = 215;
+	KRFreq[39][10] = 214;
+	KRFreq[39][17] = 213;
+	KRFreq[33][4] = 212;
+	KRFreq[32][84] = 211;
+	KRFreq[34][3] = 210;
+	KRFreq[28][27] = 209;
+	KRFreq[15][79] = 208;
+	KRFreq[34][21] = 207;
+	KRFreq[34][69] = 206;
+	KRFreq[21][62] = 205;
+	KRFreq[36][24] = 204;
+	KRFreq[16][89] = 203;
+	KRFreq[18][48] = 202;
+	KRFreq[38][15] = 201;
+	KRFreq[36][58] = 200;
+	KRFreq[21][56] = 199;
+	KRFreq[34][48] = 198;
+	KRFreq[21][15] = 197;
+	KRFreq[39][3] = 196;
+	KRFreq[16][44] = 195;
+	KRFreq[18][79] = 194;
+	KRFreq[25][13] = 193;
+	KRFreq[29][47] = 192;
+	KRFreq[38][88] = 191;
+	KRFreq[20][71] = 190;
+	KRFreq[16][58] = 189;
+	KRFreq[35][57] = 188;
+	KRFreq[29][30] = 187;
+	KRFreq[29][23] = 186;
+	KRFreq[34][93] = 185;
+	KRFreq[30][85] = 184;
+	KRFreq[15][80] = 183;
+	KRFreq[32][78] = 182;
+	KRFreq[37][82] = 181;
+	KRFreq[22][40] = 180;
+	KRFreq[21][69] = 179;
+	KRFreq[26][85] = 178;
+	KRFreq[31][31] = 177;
+	KRFreq[28][64] = 176;
+	KRFreq[38][13] = 175;
+	KRFreq[25][2] = 174;
+	KRFreq[22][34] = 173;
+	KRFreq[28][28] = 172;
+	KRFreq[24][91] = 171;
+	KRFreq[33][74] = 170;
+	KRFreq[29][40] = 169;
+	KRFreq[15][77] = 168;
+	KRFreq[32][80] = 167;
+	KRFreq[30][41] = 166;
+	KRFreq[23][30] = 165;
+	KRFreq[24][63] = 164;
+	KRFreq[30][53] = 163;
+	KRFreq[39][70] = 162;
+	KRFreq[23][61] = 161;
+	KRFreq[37][27] = 160;
+	KRFreq[16][55] = 159;
+	KRFreq[22][74] = 158;
+	KRFreq[26][50] = 157;
+	KRFreq[16][10] = 156;
+	KRFreq[34][63] = 155;
+	KRFreq[35][14] = 154;
+	KRFreq[17][7] = 153;
+	KRFreq[15][59] = 152;
+	KRFreq[27][23] = 151;
+	KRFreq[18][70] = 150;
+	KRFreq[32][56] = 149;
+	KRFreq[37][87] = 148;
+	KRFreq[17][61] = 147;
+	KRFreq[18][83] = 146;
+	KRFreq[23][86] = 145;
+	KRFreq[17][31] = 144;
+	KRFreq[23][83] = 143;
+	KRFreq[35][2] = 142;
+	KRFreq[18][64] = 141;
+	KRFreq[27][43] = 140;
+	KRFreq[32][42] = 139;
+	KRFreq[25][76] = 138;
+	KRFreq[19][85] = 137;
+	KRFreq[37][81] = 136;
+	KRFreq[38][83] = 135;
+	KRFreq[35][7] = 134;
+	KRFreq[16][51] = 133;
+	KRFreq[27][22] = 132;
+	KRFreq[16][76] = 131;
+	KRFreq[22][4] = 130;
+	KRFreq[38][84] = 129;
+	KRFreq[17][83] = 128;
+	KRFreq[24][46] = 127;
+	KRFreq[33][15] = 126;
+	KRFreq[20][48] = 125;
+	KRFreq[17][30] = 124;
+	KRFreq[30][93] = 123;
+	KRFreq[28][11] = 122;
+	KRFreq[28][30] = 121;
+	KRFreq[15][62] = 120;
+	KRFreq[17][87] = 119;
+	KRFreq[32][81] = 118;
+	KRFreq[23][37] = 117;
+	KRFreq[30][22] = 116;
+	KRFreq[32][66] = 115;
+	KRFreq[33][78] = 114;
+	KRFreq[21][4] = 113;
+	KRFreq[31][17] = 112;
+	KRFreq[39][61] = 111;
+	KRFreq[18][76] = 110;
+	KRFreq[15][85] = 109;
+	KRFreq[31][47] = 108;
+	KRFreq[19][57] = 107;
+	KRFreq[23][55] = 106;
+	KRFreq[27][29] = 105;
+	KRFreq[29][46] = 104;
+	KRFreq[33][0] = 103;
+	KRFreq[16][83] = 102;
+	KRFreq[39][78] = 101;
+	KRFreq[32][77] = 100;
+	KRFreq[36][25] = 99;
+	KRFreq[34][19] = 98;
+	KRFreq[38][49] = 97;
+	KRFreq[19][25] = 96;
+	KRFreq[23][53] = 95;
+	KRFreq[28][43] = 94;
+	KRFreq[31][44] = 93;
+	KRFreq[36][34] = 92;
+	KRFreq[16][34] = 91;
+	KRFreq[35][1] = 90;
+	KRFreq[19][87] = 89;
+	KRFreq[18][53] = 88;
+	KRFreq[29][54] = 87;
+	KRFreq[22][41] = 86;
+	KRFreq[38][18] = 85;
+	KRFreq[22][2] = 84;
+	KRFreq[20][3] = 83;
+	KRFreq[39][69] = 82;
+	KRFreq[30][29] = 81;
+	KRFreq[28][19] = 80;
+	KRFreq[29][90] = 79;
+	KRFreq[17][86] = 78;
+	KRFreq[15][9] = 77;
+	KRFreq[39][73] = 76;
+	KRFreq[15][37] = 75;
+	KRFreq[35][40] = 74;
+	KRFreq[33][77] = 73;
+	KRFreq[27][86] = 72;
+	KRFreq[36][79] = 71;
+	KRFreq[23][18] = 70;
+	KRFreq[34][87] = 69;
+	KRFreq[39][24] = 68;
+	KRFreq[26][8] = 67;
+	KRFreq[33][48] = 66;
+	KRFreq[39][30] = 65;
+	KRFreq[33][28] = 64;
+	KRFreq[16][67] = 63;
+	KRFreq[31][78] = 62;
+	KRFreq[32][23] = 61;
+	KRFreq[24][55] = 60;
+	KRFreq[30][68] = 59;
+	KRFreq[18][60] = 58;
+	KRFreq[15][17] = 57;
+	KRFreq[23][34] = 56;
+	KRFreq[20][49] = 55;
+	KRFreq[15][78] = 54;
+	KRFreq[24][14] = 53;
+	KRFreq[19][41] = 52;
+	KRFreq[31][55] = 51;
+	KRFreq[21][39] = 50;
+	KRFreq[35][9] = 49;
+	KRFreq[30][15] = 48;
+	KRFreq[20][52] = 47;
+	KRFreq[35][71] = 46;
+	KRFreq[20][7] = 45;
+	KRFreq[29][72] = 44;
+	KRFreq[37][77] = 43;
+	KRFreq[22][35] = 42;
+	KRFreq[20][61] = 41;
+	KRFreq[31][60] = 40;
+	KRFreq[20][93] = 39;
+	KRFreq[27][92] = 38;
+	KRFreq[28][16] = 37;
+	KRFreq[36][26] = 36;
+	KRFreq[18][89] = 35;
+	KRFreq[21][63] = 34;
+	KRFreq[22][52] = 33;
+	KRFreq[24][65] = 32;
+	KRFreq[31][8] = 31;
+	KRFreq[31][49] = 30;
+	KRFreq[33][30] = 29;
+	KRFreq[37][15] = 28;
+	KRFreq[18][18] = 27;
+	KRFreq[25][50] = 26;
+	KRFreq[29][20] = 25;
+	KRFreq[35][48] = 24;
+	KRFreq[38][75] = 23;
+	KRFreq[26][83] = 22;
+	KRFreq[21][87] = 21;
+	KRFreq[27][71] = 20;
+	KRFreq[32][91] = 19;
+	KRFreq[25][73] = 18;
+	KRFreq[16][84] = 17;
+	KRFreq[25][31] = 16;
+	KRFreq[17][90] = 15;
+	KRFreq[18][40] = 14;
+	KRFreq[17][77] = 13;
+	KRFreq[17][35] = 12;
+	KRFreq[23][52] = 11;
+	KRFreq[23][35] = 10;
+	KRFreq[16][5] = 9;
+	KRFreq[23][58] = 8;
+	KRFreq[19][60] = 7;
+	KRFreq[30][32] = 6;
+	KRFreq[38][34] = 5;
+	KRFreq[23][4] = 4;
+	KRFreq[23][1] = 3;
+	KRFreq[27][57] = 2;
+	KRFreq[39][38] = 1;
+	KRFreq[32][33] = 0;
+
+	JPFreq[3][74] = 600;
+	JPFreq[3][45] = 599;
+	JPFreq[3][3] = 598;
+	JPFreq[3][24] = 597;
+	JPFreq[3][30] = 596;
+	JPFreq[3][42] = 595;
+	JPFreq[3][46] = 594;
+	JPFreq[3][39] = 593;
+	JPFreq[3][11] = 592;
+	JPFreq[3][37] = 591;
+	JPFreq[3][38] = 590;
+	JPFreq[3][31] = 589;
+	JPFreq[3][41] = 588;
+	JPFreq[3][5] = 587;
+	JPFreq[3][10] = 586;
+	JPFreq[3][75] = 585;
+	JPFreq[3][65] = 584;
+	JPFreq[3][72] = 583;
+	JPFreq[37][91] = 582;
+	JPFreq[0][27] = 581;
+	JPFreq[3][18] = 580;
+	JPFreq[3][22] = 579;
+	JPFreq[3][61] = 578;
+	JPFreq[3][14] = 577;
+	JPFreq[24][80] = 576;
+	JPFreq[4][82] = 575;
+	JPFreq[17][80] = 574;
+	JPFreq[30][44] = 573;
+	JPFreq[3][73] = 572;
+	JPFreq[3][64] = 571;
+	JPFreq[38][14] = 570;
+	JPFreq[33][70] = 569;
+	JPFreq[3][1] = 568;
+	JPFreq[3][16] = 567;
+	JPFreq[3][35] = 566;
+	JPFreq[3][40] = 565;
+	JPFreq[4][74] = 564;
+	JPFreq[4][24] = 563;
+	JPFreq[42][59] = 562;
+	JPFreq[3][7] = 561;
+	JPFreq[3][71] = 560;
+	JPFreq[3][12] = 559;
+	JPFreq[15][75] = 558;
+	JPFreq[3][20] = 557;
+	JPFreq[4][39] = 556;
+	JPFreq[34][69] = 555;
+	JPFreq[3][28] = 554;
+	JPFreq[35][24] = 553;
+	JPFreq[3][82] = 552;
+	JPFreq[28][47] = 551;
+	JPFreq[3][67] = 550;
+	JPFreq[37][16] = 549;
+	JPFreq[26][93] = 548;
+	JPFreq[4][1] = 547;
+	JPFreq[26][85] = 546;
+	JPFreq[31][14] = 545;
+	JPFreq[4][3] = 544;
+	JPFreq[4][72] = 543;
+	JPFreq[24][51] = 542;
+	JPFreq[27][51] = 541;
+	JPFreq[27][49] = 540;
+	JPFreq[22][77] = 539;
+	JPFreq[27][10] = 538;
+	JPFreq[29][68] = 537;
+	JPFreq[20][35] = 536;
+	JPFreq[41][11] = 535;
+	JPFreq[24][70] = 534;
+	JPFreq[36][61] = 533;
+	JPFreq[31][23] = 532;
+	JPFreq[43][16] = 531;
+	JPFreq[23][68] = 530;
+	JPFreq[32][15] = 529;
+	JPFreq[3][32] = 528;
+	JPFreq[19][53] = 527;
+	JPFreq[40][83] = 526;
+	JPFreq[4][14] = 525;
+	JPFreq[36][9] = 524;
+	JPFreq[4][73] = 523;
+	JPFreq[23][10] = 522;
+	JPFreq[3][63] = 521;
+	JPFreq[39][14] = 520;
+	JPFreq[3][78] = 519;
+	JPFreq[33][47] = 518;
+	JPFreq[21][39] = 517;
+	JPFreq[34][46] = 516;
+	JPFreq[36][75] = 515;
+	JPFreq[41][92] = 514;
+	JPFreq[37][93] = 513;
+	JPFreq[4][34] = 512;
+	JPFreq[15][86] = 511;
+	JPFreq[46][1] = 510;
+	JPFreq[37][65] = 509;
+	JPFreq[3][62] = 508;
+	JPFreq[32][73] = 507;
+	JPFreq[21][65] = 506;
+	JPFreq[29][75] = 505;
+	JPFreq[26][51] = 504;
+	JPFreq[3][34] = 503;
+	JPFreq[4][10] = 502;
+	JPFreq[30][22] = 501;
+	JPFreq[35][73] = 500;
+	JPFreq[17][82] = 499;
+	JPFreq[45][8] = 498;
+	JPFreq[27][73] = 497;
+	JPFreq[18][55] = 496;
+	JPFreq[25][2] = 495;
+	JPFreq[3][26] = 494;
+	JPFreq[45][46] = 493;
+	JPFreq[4][22] = 492;
+	JPFreq[4][40] = 491;
+	JPFreq[18][10] = 490;
+	JPFreq[32][9] = 489;
+	JPFreq[26][49] = 488;
+	JPFreq[3][47] = 487;
+	JPFreq[24][65] = 486;
+	JPFreq[4][76] = 485;
+	JPFreq[43][67] = 484;
+	JPFreq[3][9] = 483;
+	JPFreq[41][37] = 482;
+	JPFreq[33][68] = 481;
+	JPFreq[43][31] = 480;
+	JPFreq[19][55] = 479;
+	JPFreq[4][30] = 478;
+	JPFreq[27][33] = 477;
+	JPFreq[16][62] = 476;
+	JPFreq[36][35] = 475;
+	JPFreq[37][15] = 474;
+	JPFreq[27][70] = 473;
+	JPFreq[22][71] = 472;
+	JPFreq[33][45] = 471;
+	JPFreq[31][78] = 470;
+	JPFreq[43][59] = 469;
+	JPFreq[32][19] = 468;
+	JPFreq[17][28] = 467;
+	JPFreq[40][28] = 466;
+	JPFreq[20][93] = 465;
+	JPFreq[18][15] = 464;
+	JPFreq[4][23] = 463;
+	JPFreq[3][23] = 462;
+	JPFreq[26][64] = 461;
+	JPFreq[44][92] = 460;
+	JPFreq[17][27] = 459;
+	JPFreq[3][56] = 458;
+	JPFreq[25][38] = 457;
+	JPFreq[23][31] = 456;
+	JPFreq[35][43] = 455;
+	JPFreq[4][54] = 454;
+	JPFreq[35][19] = 453;
+	JPFreq[22][47] = 452;
+	JPFreq[42][0] = 451;
+	JPFreq[23][28] = 450;
+	JPFreq[46][33] = 449;
+	JPFreq[36][85] = 448;
+	JPFreq[31][12] = 447;
+	JPFreq[3][76] = 446;
+	JPFreq[4][75] = 445;
+	JPFreq[36][56] = 444;
+	JPFreq[4][64] = 443;
+	JPFreq[25][77] = 442;
+	JPFreq[15][52] = 441;
+	JPFreq[33][73] = 440;
+	JPFreq[3][55] = 439;
+	JPFreq[43][82] = 438;
+	JPFreq[27][82] = 437;
+	JPFreq[20][3] = 436;
+	JPFreq[40][51] = 435;
+	JPFreq[3][17] = 434;
+	JPFreq[27][71] = 433;
+	JPFreq[4][52] = 432;
+	JPFreq[44][48] = 431;
+	JPFreq[27][2] = 430;
+	JPFreq[17][39] = 429;
+	JPFreq[31][8] = 428;
+	JPFreq[44][54] = 427;
+	JPFreq[43][18] = 426;
+	JPFreq[43][77] = 425;
+	JPFreq[4][61] = 424;
+	JPFreq[19][91] = 423;
+	JPFreq[31][13] = 422;
+	JPFreq[44][71] = 421;
+	JPFreq[20][0] = 420;
+	JPFreq[23][87] = 419;
+	JPFreq[21][14] = 418;
+	JPFreq[29][13] = 417;
+	JPFreq[3][58] = 416;
+	JPFreq[26][18] = 415;
+	JPFreq[4][47] = 414;
+	JPFreq[4][18] = 413;
+	JPFreq[3][53] = 412;
+	JPFreq[26][92] = 411;
+	JPFreq[21][7] = 410;
+	JPFreq[4][37] = 409;
+	JPFreq[4][63] = 408;
+	JPFreq[36][51] = 407;
+	JPFreq[4][32] = 406;
+	JPFreq[28][73] = 405;
+	JPFreq[4][50] = 404;
+	JPFreq[41][60] = 403;
+	JPFreq[23][1] = 402;
+	JPFreq[36][92] = 401;
+	JPFreq[15][41] = 400;
+	JPFreq[21][71] = 399;
+	JPFreq[41][30] = 398;
+	JPFreq[32][76] = 397;
+	JPFreq[17][34] = 396;
+	JPFreq[26][15] = 395;
+	JPFreq[26][25] = 394;
+	JPFreq[31][77] = 393;
+	JPFreq[31][3] = 392;
+	JPFreq[46][34] = 391;
+	JPFreq[27][84] = 390;
+	JPFreq[23][8] = 389;
+	JPFreq[16][0] = 388;
+	JPFreq[28][80] = 387;
+	JPFreq[26][54] = 386;
+	JPFreq[33][18] = 385;
+	JPFreq[31][20] = 384;
+	JPFreq[31][62] = 383;
+	JPFreq[30][41] = 382;
+	JPFreq[33][30] = 381;
+	JPFreq[45][45] = 380;
+	JPFreq[37][82] = 379;
+	JPFreq[15][33] = 378;
+	JPFreq[20][12] = 377;
+	JPFreq[18][5] = 376;
+	JPFreq[28][86] = 375;
+	JPFreq[30][19] = 374;
+	JPFreq[42][43] = 373;
+	JPFreq[36][31] = 372;
+	JPFreq[17][93] = 371;
+	JPFreq[4][15] = 370;
+	JPFreq[21][20] = 369;
+	JPFreq[23][21] = 368;
+	JPFreq[28][72] = 367;
+	JPFreq[4][20] = 366;
+	JPFreq[26][55] = 365;
+	JPFreq[21][5] = 364;
+	JPFreq[19][16] = 363;
+	JPFreq[23][64] = 362;
+	JPFreq[40][59] = 361;
+	JPFreq[37][26] = 360;
+	JPFreq[26][56] = 359;
+	JPFreq[4][12] = 358;
+	JPFreq[33][71] = 357;
+	JPFreq[32][39] = 356;
+	JPFreq[38][40] = 355;
+	JPFreq[22][74] = 354;
+	JPFreq[3][25] = 353;
+	JPFreq[15][48] = 352;
+	JPFreq[41][82] = 351;
+	JPFreq[41][9] = 350;
+	JPFreq[25][48] = 349;
+	JPFreq[31][71] = 348;
+	JPFreq[43][29] = 347;
+	JPFreq[26][80] = 346;
+	JPFreq[4][5] = 345;
+	JPFreq[18][71] = 344;
+	JPFreq[29][0] = 343;
+	JPFreq[43][43] = 342;
+	JPFreq[23][81] = 341;
+	JPFreq[4][42] = 340;
+	JPFreq[44][28] = 339;
+	JPFreq[23][93] = 338;
+	JPFreq[17][81] = 337;
+	JPFreq[25][25] = 336;
+	JPFreq[41][23] = 335;
+	JPFreq[34][35] = 334;
+	JPFreq[4][53] = 333;
+	JPFreq[28][36] = 332;
+	JPFreq[4][41] = 331;
+	JPFreq[25][60] = 330;
+	JPFreq[23][20] = 329;
+	JPFreq[3][43] = 328;
+	JPFreq[24][79] = 327;
+	JPFreq[29][41] = 326;
+	JPFreq[30][83] = 325;
+	JPFreq[3][50] = 324;
+	JPFreq[22][18] = 323;
+	JPFreq[18][3] = 322;
+	JPFreq[39][30] = 321;
+	JPFreq[4][28] = 320;
+	JPFreq[21][64] = 319;
+	JPFreq[4][68] = 318;
+	JPFreq[17][71] = 317;
+	JPFreq[27][0] = 316;
+	JPFreq[39][28] = 315;
+	JPFreq[30][13] = 314;
+	JPFreq[36][70] = 313;
+	JPFreq[20][82] = 312;
+	JPFreq[33][38] = 311;
+	JPFreq[44][87] = 310;
+	JPFreq[34][45] = 309;
+	JPFreq[4][26] = 308;
+	JPFreq[24][44] = 307;
+	JPFreq[38][67] = 306;
+	JPFreq[38][6] = 305;
+	JPFreq[30][68] = 304;
+	JPFreq[15][89] = 303;
+	JPFreq[24][93] = 302;
+	JPFreq[40][41] = 301;
+	JPFreq[38][3] = 300;
+	JPFreq[28][23] = 299;
+	JPFreq[26][17] = 298;
+	JPFreq[4][38] = 297;
+	JPFreq[22][78] = 296;
+	JPFreq[15][37] = 295;
+	JPFreq[25][85] = 294;
+	JPFreq[4][9] = 293;
+	JPFreq[4][7] = 292;
+	JPFreq[27][53] = 291;
+	JPFreq[39][29] = 290;
+	JPFreq[41][43] = 289;
+	JPFreq[25][62] = 288;
+	JPFreq[4][48] = 287;
+	JPFreq[28][28] = 286;
+	JPFreq[21][40] = 285;
+	JPFreq[36][73] = 284;
+	JPFreq[26][39] = 283;
+	JPFreq[22][54] = 282;
+	JPFreq[33][5] = 281;
+	JPFreq[19][21] = 280;
+	JPFreq[46][31] = 279;
+	JPFreq[20][64] = 278;
+	JPFreq[26][63] = 277;
+	JPFreq[22][23] = 276;
+	JPFreq[25][81] = 275;
+	JPFreq[4][62] = 274;
+	JPFreq[37][31] = 273;
+	JPFreq[40][52] = 272;
+	JPFreq[29][79] = 271;
+	JPFreq[41][48] = 270;
+	JPFreq[31][57] = 269;
+	JPFreq[32][92] = 268;
+	JPFreq[36][36] = 267;
+	JPFreq[27][7] = 266;
+	JPFreq[35][29] = 265;
+	JPFreq[37][34] = 264;
+	JPFreq[34][42] = 263;
+	JPFreq[27][15] = 262;
+	JPFreq[33][27] = 261;
+	JPFreq[31][38] = 260;
+	JPFreq[19][79] = 259;
+	JPFreq[4][31] = 258;
+	JPFreq[4][66] = 257;
+	JPFreq[17][32] = 256;
+	JPFreq[26][67] = 255;
+	JPFreq[16][30] = 254;
+	JPFreq[26][46] = 253;
+	JPFreq[24][26] = 252;
+	JPFreq[35][10] = 251;
+	JPFreq[18][37] = 250;
+	JPFreq[3][19] = 249;
+	JPFreq[33][69] = 248;
+	JPFreq[31][9] = 247;
+	JPFreq[45][29] = 246;
+	JPFreq[3][15] = 245;
+	JPFreq[18][54] = 244;
+	JPFreq[3][44] = 243;
+	JPFreq[31][29] = 242;
+	JPFreq[18][45] = 241;
+	JPFreq[38][28] = 240;
+	JPFreq[24][12] = 239;
+	JPFreq[35][82] = 238;
+	JPFreq[17][43] = 237;
+	JPFreq[28][9] = 236;
+	JPFreq[23][25] = 235;
+	JPFreq[44][37] = 234;
+	JPFreq[23][75] = 233;
+	JPFreq[23][92] = 232;
+	JPFreq[0][24] = 231;
+	JPFreq[19][74] = 230;
+	JPFreq[45][32] = 229;
+	JPFreq[16][72] = 228;
+	JPFreq[16][93] = 227;
+	JPFreq[45][13] = 226;
+	JPFreq[24][8] = 225;
+	JPFreq[25][47] = 224;
+	JPFreq[28][26] = 223;
+	JPFreq[43][81] = 222;
+	JPFreq[32][71] = 221;
+	JPFreq[18][41] = 220;
+	JPFreq[26][62] = 219;
+	JPFreq[41][24] = 218;
+	JPFreq[40][11] = 217;
+	JPFreq[43][57] = 216;
+	JPFreq[34][53] = 215;
+	JPFreq[20][32] = 214;
+	JPFreq[34][43] = 213;
+	JPFreq[41][91] = 212;
+	JPFreq[29][57] = 211;
+	JPFreq[15][43] = 210;
+	JPFreq[22][89] = 209;
+	JPFreq[33][83] = 208;
+	JPFreq[43][20] = 207;
+	JPFreq[25][58] = 206;
+	JPFreq[30][30] = 205;
+	JPFreq[4][56] = 204;
+	JPFreq[17][64] = 203;
+	JPFreq[23][0] = 202;
+	JPFreq[44][12] = 201;
+	JPFreq[25][37] = 200;
+	JPFreq[35][13] = 199;
+	JPFreq[20][30] = 198;
+	JPFreq[21][84] = 197;
+	JPFreq[29][14] = 196;
+	JPFreq[30][5] = 195;
+	JPFreq[37][2] = 194;
+	JPFreq[4][78] = 193;
+	JPFreq[29][78] = 192;
+	JPFreq[29][84] = 191;
+	JPFreq[32][86] = 190;
+	JPFreq[20][68] = 189;
+	JPFreq[30][39] = 188;
+	JPFreq[15][69] = 187;
+	JPFreq[4][60] = 186;
+	JPFreq[20][61] = 185;
+	JPFreq[41][67] = 184;
+	JPFreq[16][35] = 183;
+	JPFreq[36][57] = 182;
+	JPFreq[39][80] = 181;
+	JPFreq[4][59] = 180;
+	JPFreq[4][44] = 179;
+	JPFreq[40][54] = 178;
+	JPFreq[30][8] = 177;
+	JPFreq[44][30] = 176;
+	JPFreq[31][93] = 175;
+	JPFreq[31][47] = 174;
+	JPFreq[16][70] = 173;
+	JPFreq[21][0] = 172;
+	JPFreq[17][35] = 171;
+	JPFreq[21][67] = 170;
+	JPFreq[44][18] = 169;
+	JPFreq[36][29] = 168;
+	JPFreq[18][67] = 167;
+	JPFreq[24][28] = 166;
+	JPFreq[36][24] = 165;
+	JPFreq[23][5] = 164;
+	JPFreq[31][65] = 163;
+	JPFreq[26][59] = 162;
+	JPFreq[28][2] = 161;
+	JPFreq[39][69] = 160;
+	JPFreq[42][40] = 159;
+	JPFreq[37][80] = 158;
+	JPFreq[15][66] = 157;
+	JPFreq[34][38] = 156;
+	JPFreq[28][48] = 155;
+	JPFreq[37][77] = 154;
+	JPFreq[29][34] = 153;
+	JPFreq[33][12] = 152;
+	JPFreq[4][65] = 151;
+	JPFreq[30][31] = 150;
+	JPFreq[27][92] = 149;
+	JPFreq[4][2] = 148;
+	JPFreq[4][51] = 147;
+	JPFreq[23][77] = 146;
+	JPFreq[4][35] = 145;
+	JPFreq[3][13] = 144;
+	JPFreq[26][26] = 143;
+	JPFreq[44][4] = 142;
+	JPFreq[39][53] = 141;
+	JPFreq[20][11] = 140;
+	JPFreq[40][33] = 139;
+	JPFreq[45][7] = 138;
+	JPFreq[4][70] = 137;
+	JPFreq[3][49] = 136;
+	JPFreq[20][59] = 135;
+	JPFreq[21][12] = 134;
+	JPFreq[33][53] = 133;
+	JPFreq[20][14] = 132;
+	JPFreq[37][18] = 131;
+	JPFreq[18][17] = 130;
+	JPFreq[36][23] = 129;
+	JPFreq[18][57] = 128;
+	JPFreq[26][74] = 127;
+	JPFreq[35][2] = 126;
+	JPFreq[38][58] = 125;
+	JPFreq[34][68] = 124;
+	JPFreq[29][81] = 123;
+	JPFreq[20][69] = 122;
+	JPFreq[39][86] = 121;
+	JPFreq[4][16] = 120;
+	JPFreq[16][49] = 119;
+	JPFreq[15][72] = 118;
+	JPFreq[26][35] = 117;
+	JPFreq[32][14] = 116;
+	JPFreq[40][90] = 115;
+	JPFreq[33][79] = 114;
+	JPFreq[35][4] = 113;
+	JPFreq[23][33] = 112;
+	JPFreq[19][19] = 111;
+	JPFreq[31][41] = 110;
+	JPFreq[44][1] = 109;
+	JPFreq[22][56] = 108;
+	JPFreq[31][27] = 107;
+	JPFreq[32][18] = 106;
+	JPFreq[27][32] = 105;
+	JPFreq[37][39] = 104;
+	JPFreq[42][11] = 103;
+	JPFreq[29][71] = 102;
+	JPFreq[32][58] = 101;
+	JPFreq[46][10] = 100;
+	JPFreq[17][30] = 99;
+	JPFreq[38][15] = 98;
+	JPFreq[29][60] = 97;
+	JPFreq[4][11] = 96;
+	JPFreq[38][31] = 95;
+	JPFreq[40][79] = 94;
+	JPFreq[28][49] = 93;
+	JPFreq[28][84] = 92;
+	JPFreq[26][77] = 91;
+	JPFreq[22][32] = 90;
+	JPFreq[33][17] = 89;
+	JPFreq[23][18] = 88;
+	JPFreq[32][64] = 87;
+	JPFreq[4][6] = 86;
+	JPFreq[33][51] = 85;
+	JPFreq[44][77] = 84;
+	JPFreq[29][5] = 83;
+	JPFreq[46][25] = 82;
+	JPFreq[19][58] = 81;
+	JPFreq[4][46] = 80;
+	JPFreq[15][71] = 79;
+	JPFreq[18][58] = 78;
+	JPFreq[26][45] = 77;
+	JPFreq[45][66] = 76;
+	JPFreq[34][10] = 75;
+	JPFreq[19][37] = 74;
+	JPFreq[33][65] = 73;
+	JPFreq[44][52] = 72;
+	JPFreq[16][38] = 71;
+	JPFreq[36][46] = 70;
+	JPFreq[20][26] = 69;
+	JPFreq[30][37] = 68;
+	JPFreq[4][58] = 67;
+	JPFreq[43][2] = 66;
+	JPFreq[30][18] = 65;
+	JPFreq[19][35] = 64;
+	JPFreq[15][68] = 63;
+	JPFreq[3][36] = 62;
+	JPFreq[35][40] = 61;
+	JPFreq[36][32] = 60;
+	JPFreq[37][14] = 59;
+	JPFreq[17][11] = 58;
+	JPFreq[19][78] = 57;
+	JPFreq[37][11] = 56;
+	JPFreq[28][63] = 55;
+	JPFreq[29][61] = 54;
+	JPFreq[33][3] = 53;
+	JPFreq[41][52] = 52;
+	JPFreq[33][63] = 51;
+	JPFreq[22][41] = 50;
+	JPFreq[4][19] = 49;
+	JPFreq[32][41] = 48;
+	JPFreq[24][4] = 47;
+	JPFreq[31][28] = 46;
+	JPFreq[43][30] = 45;
+	JPFreq[17][3] = 44;
+	JPFreq[43][70] = 43;
+	JPFreq[34][19] = 42;
+	JPFreq[20][77] = 41;
+	JPFreq[18][83] = 40;
+	JPFreq[17][15] = 39;
+	JPFreq[23][61] = 38;
+	JPFreq[40][27] = 37;
+	JPFreq[16][48] = 36;
+	JPFreq[39][78] = 35;
+	JPFreq[41][53] = 34;
+	JPFreq[40][91] = 33;
+	JPFreq[40][72] = 32;
+	JPFreq[18][52] = 31;
+	JPFreq[35][66] = 30;
+	JPFreq[39][93] = 29;
+	JPFreq[19][48] = 28;
+	JPFreq[26][36] = 27;
+	JPFreq[27][25] = 26;
+	JPFreq[42][71] = 25;
+	JPFreq[42][85] = 24;
+	JPFreq[26][48] = 23;
+	JPFreq[28][15] = 22;
+	JPFreq[3][66] = 21;
+	JPFreq[25][24] = 20;
+	JPFreq[27][43] = 19;
+	JPFreq[27][78] = 18;
+	JPFreq[45][43] = 17;
+	JPFreq[27][72] = 16;
+	JPFreq[40][29] = 15;
+	JPFreq[41][0] = 14;
+	JPFreq[19][57] = 13;
+	JPFreq[15][59] = 12;
+	JPFreq[29][29] = 11;
+	JPFreq[4][25] = 10;
+	JPFreq[21][42] = 9;
+	JPFreq[23][35] = 8;
+	JPFreq[33][1] = 7;
+	JPFreq[4][57] = 6;
+	JPFreq[17][60] = 5;
+	JPFreq[25][19] = 4;
+	JPFreq[22][65] = 3;
+	JPFreq[42][29] = 2;
+	JPFreq[27][66] = 1;
+	JPFreq[26][89] = 0;
+
+}
diff --git a/media/libstagefright/vendor/al_libc/SinoDetect.h b/media/libstagefright/vendor/al_libc/SinoDetect.h
new file mode 100755
index 0000000..e0df5ba
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/SinoDetect.h
@@ -0,0 +1,72 @@
+#ifndef _SINODETECT_H
+#define _SINODETECT_H
+
+/*
+ SinoDetect
+ C++ class to detect encoding of an unsigned char* array
+ Works for
+ Chinese:  GB, GBK, HZ, Big5, Big5+, EUC-TW, ISO 2022-CN
+ Korean:   EUC-KR, Cp949, ISO 2022-KR
+ Japanese: EUC-JP, SJIS, ISO 2022-JP
+ General:  UTF-8, UTF-16
+ Written by Erik Peterson, erik@mandarintools.com
+ Last update July, 2006
+ License fee required for commercial use
+ */
+class SinoDetect {
+
+public:
+	/*  enum Encodings { GB2312, GBK, GB18030, HZ,
+	 BIG5, BIG5PLUS, EUC_TW, ISO_2022_CN,
+	 EUC_KR, CP949, ISO_2022_KR, JOHAB,
+	 EUC_JP, SJIS, ISO_2022_JP,
+	 UTF8, UTF16,
+	 ASCII, OTHER, TOTAL_ENCODINGS };
+	 */
+	enum Encodings {
+		GBK, BIG5, EUC_KR, EUC_JP, SJIS, OTHER, TOTAL_ENCODINGS
+	};
+
+	SinoDetect();
+	~SinoDetect();
+
+//	int detect_encoding(FILE *srcfile);
+	int detect_encoding(unsigned char* rawtext);
+
+private:
+
+	// Frequency tables to hold the GB, Big5, and EUC-TW character
+	// frequencies
+	int GBFreq[94][94];
+	int GBKFreq[126][191];
+	int Big5Freq[94][158];
+	//  int Big5PFreq[126][191];
+	//  int EUC_TWFreq[94][94];
+	int KRFreq[94][94];
+	int JPFreq[94][94];
+
+	//int UnicodeFreq[94][128];
+
+	void initialize_frequencies();
+
+	//  int gb2312_probability(unsigned char* rawtext);
+	int gbk_probability(unsigned char* rawtext);
+	//  int gb18030_probability(unsigned char* rawtext);
+	//  int hz_probability(unsigned char* rawtext);
+	int big5_probability(unsigned char* rawtext);
+	//  int big5plus_probability(unsigned char* rawtext);
+	//  int euc_tw_probability(unsigned char* rawtext);
+	//  int iso_2022_cn_probability(unsigned char* rawtext);
+	//  int utf8_probability(unsigned char* rawtext);
+	//  int utf16_probability(unsigned char* rawtext);
+	//  int ascii_probability(unsigned char* rawtext);
+	int euc_kr_probability(unsigned char* rawtext);
+	//  int cp949_probability(unsigned char* rawtext);
+	//  int iso_2022_kr_probability(unsigned char* rawtext);
+	int sjis_probability(unsigned char* rawtext);
+	int euc_jp_probability(unsigned char* rawtext);
+	//  int iso_2022_jp_probability(unsigned char* rawtext);
+
+};
+
+#endif
diff --git a/media/libstagefright/vendor/al_libc/al_detect.cpp b/media/libstagefright/vendor/al_libc/al_detect.cpp
new file mode 100755
index 0000000..0859992
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/al_detect.cpp
@@ -0,0 +1,40 @@
+#define LOG_TAG             "AL_DETECT"
+#include <utils/Log.h>
+
+
+#include <actal_posix_dev.h>
+#include "SinoDetect.h"
+
+/*
+ * return 0 if no illegal bytes, else -1
+ * */
+int actal_encode_detect(const char *src, char *encoding) {
+	int sd_encoding = SinoDetect::OTHER;
+	SinoDetect sd;
+
+	if ((src == NULL) || (strlen(src) == 0)) {
+		return -1;
+	}
+
+	sd_encoding = sd.detect_encoding((unsigned char*) src);
+	switch (sd_encoding) {
+	case SinoDetect::BIG5:
+		strcpy(encoding, "Big5");
+		break;
+	case SinoDetect::EUC_KR:
+		strcpy(encoding, "EUC-KR");
+		break;
+	case SinoDetect::EUC_JP:
+		strcpy(encoding, "EUC-JP");
+		break;
+	case SinoDetect::SJIS:
+		strcpy(encoding, "shift-jis");
+		break;
+	case SinoDetect::GBK:
+	default:
+		strcpy(encoding, "gbk");
+		break;
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/media/libstagefright/vendor/al_libc/al_libc.c b/media/libstagefright/vendor/al_libc/al_libc.c
new file mode 100755
index 0000000..8018e04
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/al_libc.c
@@ -0,0 +1,598 @@
+/*******************************************************************************
+ *                              这里填写项目名
+ *                            Module: 这里填写模块名
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file
+ *******************************************************************************/
+/*!
+ * \file     libc.c
+ * \brief    提供平台差异C库的实现
+ * \author   kkli
+ * \par      GENERAL DESCRIPTION:
+ *               这里对文件进行描述
+ * \par      EXTERNALIZED FUNCTIONS:
+ *               这里描述调用到外面的模块
+ * \version 1.0
+ * \date  2009/1/1
+ *******************************************************************************/
+
+#define LOG_TAG             "AL_LIBC"
+#ifdef ANDROID
+#include <utils/Log.h>
+#endif
+#ifndef ANDROID
+#define ALOGV(fmt, args...) do{printf("V " fmt "\n", ##args);}while(0)
+#define ALOGD(fmt, args...) do{printf("D " fmt "\n", ##args);}while(0)
+#define ALOGI(fmt, args...) do{printf("I " fmt "\n", ##args);}while(0)
+#define ALOGW(fmt, args...) do{printf("W " fmt "\n", ##args);}while(0)
+#define ALOGE(fmt, args...) do{printf("E " fmt "\n", ##args);}while(0)
+#endif
+
+#include "actal_posix_dev.h"
+#include <ion/ion.h>
+
+#define ALIGN_BYTES         4096
+#define ALIGN_MASK          (ALIGN_BYTES - 1)
+
+#define PRINT_BUF_SIZE      1024
+struct actal_mem  {
+	int fd;
+	struct ion_handle * handle;
+	int len;
+	void *ptr;
+	int map_fd;
+	int phy_add;
+	struct actal_mem *next;
+};
+
+static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
+static int s_fd = 0;
+static int s_pid = 0;
+static struct actal_mem *s_top_p = NULL, *s_current_p = NULL;
+#define _ALSP_DEBUG_
+int actal_printf(const char *format, ...) 
+{
+#ifdef _ALSP_DEBUG_
+	va_list arg;
+	char printbuf[PRINT_BUF_SIZE];
+	int done;
+
+	va_start(arg, format);
+	done = vsnprintf(printbuf, PRINT_BUF_SIZE, format, arg);
+	ALOGV("%s", printbuf);
+	va_end(arg);
+
+	return done;
+#else
+	return 0;
+#endif
+}
+int actal_error(const char *format, ...) 
+{
+	va_list arg;
+	char printbuf[PRINT_BUF_SIZE];
+	int done;
+
+	va_start(arg, format);
+	done = vsnprintf(printbuf, PRINT_BUF_SIZE, format, arg);
+	ALOGE("%s", printbuf);
+	va_end(arg);
+
+	return done;
+}
+int actal_info(const char *format, ...) 
+{
+#ifdef _ALSP_RELEASE_    
+	return 0;
+#else
+	va_list arg;
+	char printbuf[PRINT_BUF_SIZE];
+	int done;
+
+	va_start(arg, format);
+	done = vsnprintf(printbuf, PRINT_BUF_SIZE, format, arg);
+	ALOGI("%s", printbuf);
+	va_end(arg);
+
+	return done;
+#endif    
+}
+
+void actal_printf_list()
+{
+	if(s_top_p == NULL)
+	{
+		ALOGD("list null");
+		return;
+	}
+    struct actal_mem * user_p = s_top_p;
+    while(user_p->next!=NULL)
+    {
+        user_p = user_p->next;
+        ALOGD("ptr = %x phy = %x len = %d", (unsigned int)user_p->ptr, user_p->phy_add, user_p->len);
+    }
+    ALOGD("list end");
+}
+
+int actal_get_phyaddr(void *ptr)
+{
+    int align = 0, phy_add = 0;
+    struct actal_mem * user_p;
+
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return 0;
+    }
+
+    user_p = s_top_p->next;
+    while(user_p != NULL)
+    {
+        align = (int)ptr - (int)user_p->ptr;
+        if((user_p->ptr <= ptr) && (align < user_p->len))
+        {
+            // ALOGD("getphy: ptr = %X, phy_add = %X, align = %d\n", (unsigned int)ptr, user_p->phy_add + align, align);
+            phy_add = user_p->phy_add + align;
+			break;
+        }
+        user_p = user_p->next;
+    }
+	
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+        return 0;
+    }
+
+	if(phy_add == 0)
+	{
+		actal_error("error!,phy_add not found. ptr = %X\n", ptr);
+	}
+    return phy_add;
+}
+
+void * actal_get_virtaddr(int phy)
+{
+    int align = 0;
+    struct actal_mem * user_p;
+	void * virt_add = NULL;
+
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return NULL;
+    }
+
+    user_p = s_top_p->next;
+    while(user_p != NULL)
+    {
+        align = phy - user_p->phy_add;
+        if((user_p->phy_add <= phy) && (align < user_p->len))
+        {
+            // ALOGD("getvir: ptr = %X, phy_add = %X, align = %d\n", (int)user_p->ptr + (int)align, phy, align);
+            virt_add = (void*)((int)user_p->ptr + (int)align);
+			break;
+        }
+        user_p = user_p->next;
+    }
+	
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+        return NULL;
+    }
+
+	if(NULL == virt_add)
+	{
+		actal_error("error!,phy_add not found. phy = %X\n", phy);
+	}
+    return virt_add;
+}
+
+void *actal_malloc(int size)
+{
+    void *ptr = NULL;
+
+    ptr = (void *)malloc(size);
+
+    actal_printf("malloc : ptr = %#X, size = %#X\n", (int)ptr, size);
+    return (void *)((int)ptr);
+}
+//
+void actal_free(void *ptr)
+{
+    actal_printf("free : add = %#X\n", (int)ptr);
+
+    free((void *)((int)ptr));
+
+}
+
+void check_pid()
+{
+	struct actal_mem * user_p;
+	// int ret = 0;
+	
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return ;
+    }
+
+	if(s_pid != getpid())
+	{
+		ALOGD("PID changed, reopen ion device");
+		ALOGD("parent pid = %d, fd = %d", s_pid, s_fd);
+		if(s_top_p != NULL)
+		{
+			s_current_p = s_top_p->next;
+			while((user_p = s_current_p) != NULL)
+			{
+				s_current_p = user_p->next;
+				// ret = ion_free(user_p->fd, user_p->handle);
+				munmap(user_p->ptr, user_p->len);
+				// close(user_p->map_fd);
+				free(user_p);
+				user_p = NULL;
+			}
+			s_top_p->next = NULL;
+			s_current_p = s_top_p;
+		}
+		ion_close(s_fd);
+		s_fd = ion_open();
+		s_pid = getpid();
+		ALOGD("new pid = %d, fd = %d", s_pid, s_fd);
+	}
+	
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+        return ;
+    }
+}
+
+void *actal_malloc_wt(int size, int *phy_add)
+{
+	int prot = PROT_READ | PROT_WRITE;
+	int map_flags = MAP_SHARED;
+	struct ion_handle *handle;
+	int map_fd, ret;
+    void *ptr;
+
+	if(size <= 0)
+	{
+		ALOGE("size must be positive\n");
+		return -EINVAL;
+	}
+
+	check_pid();
+
+    if (size & ALIGN_MASK)
+    {
+        //4k对齐
+        size += (ALIGN_BYTES - (size & ALIGN_MASK));
+    }
+
+    struct actal_mem * user_p;
+
+	user_p = (struct actal_mem*)malloc(sizeof(struct actal_mem));
+	user_p->next = NULL;
+	
+
+	ret = ion_alloc(s_fd, size, 0, 1, 3, &handle);
+	if(ret < 0) {
+		return NULL;
+	}
+		
+	ret = ion_map(s_fd , handle, size, prot, map_flags, 0, (unsigned char **)&ptr, &map_fd);
+
+	user_p->handle = handle;
+    user_p->len = size;
+    user_p->fd = s_fd;
+	user_p->ptr = ptr;
+	user_p->map_fd = map_fd;
+
+    ret = ion_phys(s_fd, handle, (long unsigned int *)phy_add);
+    if(ret < 0)
+    {
+        actal_error("get phy_addr error!\n");
+        return NULL;
+    }
+
+    user_p->phy_add = *phy_add;
+
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return NULL;
+    }
+
+	if(s_top_p == NULL)  //处理头结点，头结点置空
+	{
+		s_current_p = s_top_p = (struct actal_mem*)malloc(sizeof(struct actal_mem));
+		s_top_p->fd = 0;
+		s_top_p->ptr = NULL;
+		s_top_p->map_fd = 0;
+		s_top_p->handle = NULL;
+		s_top_p->len = 0;
+		s_top_p->phy_add = 0;
+	}
+	
+	s_current_p->next = user_p;
+    s_current_p = user_p;
+	
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+        return NULL;
+    }
+
+    // ALOGD("malloc_wt: ptr = %#X, phy_add = %#X, handle = %x, size = %d\n", (unsigned int)ptr, *phy_add, handle, size);
+    return (void *)ptr;
+}
+//
+void actal_free_wt(void *ptr)
+{
+    actal_free_uncache(ptr);
+}
+void actal_cache_op(void *ptr, int len, int cmd)
+{
+    int ret, align;
+    struct actal_mem *user_p, *parent_p;
+
+	if(len <= 0)
+	{
+		ALOGE("size must be positive\n");
+		return;
+	}
+
+	check_pid();
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return ;
+    }
+    user_p = s_top_p;
+    while(user_p->next != NULL)
+    {
+        parent_p = user_p;
+        user_p = user_p->next;
+		align = (int)ptr - (int)user_p->ptr;
+		if((user_p->ptr <= ptr) && (align < user_p->len))
+        // if(user_p->ptr == ptr)
+        {
+			if(len > (user_p->len - align))
+			{
+				ALOGE("invalid len");
+				ALOGE("we got ptr = %x, len = %d, match meory ptr = %x len = %d", (unsigned int)ptr, len, (unsigned int)user_p->ptr, user_p->len);
+			}
+			else
+			{
+				ret = ion_cache(user_p->fd, user_p->handle, cmd, ptr, align, len);
+				// ALOGD("cache flush: ptr = %#X, handle = %x, size = %d\n", (unsigned int)ptr, user_p->handle, user_p->len);
+			}
+			goto UNLOCK_MUTEX;
+        }
+    }
+    actal_error("cannot find ptr in list_flush\n");
+    UNLOCK_MUTEX:
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+    }
+	return ;
+}
+
+void actal_cache_flush(void *ptr, int len)
+{
+	actal_cache_op(ptr, len, ION_IOC_CLEAN_CACHES);
+}
+
+void actal_cache_env(void *ptr, int len)
+{
+	actal_cache_op(ptr, len, ION_IOC_INV_CACHES);
+}
+
+void *actal_malloc_uncache(int size, int *phy_add)
+{
+	int prot = PROT_READ | PROT_WRITE;
+	int map_flags = MAP_SHARED;
+	struct ion_handle *handle;
+	int map_fd, ret;
+    void *ptr;
+	
+	if(size <= 0)
+	{
+		ALOGE("size must be positive\n");
+		return -EINVAL;
+	}
+
+	check_pid();
+	// actal_printf_list();
+	// actal_error("s_fd = %d\n", s_fd);
+    if (size & ALIGN_MASK)
+    {
+        //4k对齐
+        size += (ALIGN_BYTES - (size & ALIGN_MASK));
+    }
+
+    struct actal_mem * user_p;
+
+	user_p = (struct actal_mem*)malloc(sizeof(struct actal_mem));
+	user_p->next = NULL;
+	
+
+	ret = ion_alloc(s_fd, size, 0, 1, 0, &handle);
+	if(ret < 0) {
+		return NULL;
+	}
+		
+	// ALOGD("handle :%#X\n", handle);
+
+	ret = ion_map(s_fd , handle, size, prot, map_flags, 0, (unsigned char **)&ptr, &map_fd);
+
+	user_p->handle = handle;
+    user_p->len = size;
+    user_p->fd = s_fd;
+	user_p->ptr = ptr;
+	user_p->map_fd = map_fd;
+
+    ret = ion_phys(s_fd, handle, (long unsigned int *)phy_add);
+    if(ret < 0)
+    {
+        actal_error("get phy_addr error!\n");
+        return NULL;
+    }
+
+    user_p->phy_add = *phy_add;
+
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return NULL;
+    }
+
+	if(s_top_p == NULL)  //处理头结点，头结点置空
+	{
+		s_current_p = s_top_p = (struct actal_mem*)malloc(sizeof(struct actal_mem));
+		s_top_p->fd = 0;
+		s_top_p->ptr = NULL;
+		s_top_p->map_fd = 0;
+		s_top_p->handle = NULL;
+		s_top_p->len = 0;
+		s_top_p->phy_add = 0;
+	}
+	
+	s_current_p->next = user_p;
+    s_current_p = user_p;
+	
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+        return NULL;
+    }
+
+    // ALOGD("malloc_uncache: ptr = %#X, phy_add = %#X, size = %d\n", (unsigned int)ptr, *phy_add, size);
+    return (void *)ptr;
+}
+//
+void actal_free_uncache(void *ptr)
+{
+    int ret;
+    struct actal_mem *user_p, *parent_p;
+
+	check_pid();
+	//避免线程冲突
+	if (pthread_mutex_lock(&mutex) != 0)
+    {
+		ALOGE("get mutex failed");
+        return ;
+    }
+    user_p = s_top_p;
+    while(user_p->next != NULL)
+    {
+        parent_p = user_p;
+        user_p = user_p->next;
+        if(user_p->ptr == ptr)
+        {
+            ret = ion_free(user_p->fd, user_p->handle);
+            munmap(ptr, user_p->len);
+            close(user_p->map_fd);
+            // ALOGD("free uncache len = %d, ptr = %#X, handle = %#X\n",user_p->len, (unsigned int)user_p->ptr, (unsigned int)user_p->handle);
+            parent_p->next = user_p->next;
+            if(user_p == s_current_p)
+            {
+                s_current_p = parent_p;
+            }
+            free(user_p);
+			goto UNLOCK_MUTEX;
+        }
+    }
+    actal_error("cannot find ptr in list\n");
+    UNLOCK_MUTEX:
+	if (pthread_mutex_unlock(&mutex) != 0)
+    {
+		ALOGE("free mutex failed");
+    }
+	return ;
+}
+void *actal_malloc_dma(int size, int *phy_add)
+{
+    actal_error("actal_malloc_dma unsupport now, use uncache instead\n");
+    return actal_malloc_uncache(size, phy_add);
+}
+//
+void actal_free_dma(void *ptr)
+{
+    actal_error("actal_malloc_dma unsupport now, use uncache instead\n");
+    actal_free_uncache(ptr);
+}
+int64_t actal_get_ts() 
+{
+	return 0;
+}
+int actal_get_icinfo() 
+{
+	return 0x03;
+}
+//
+void *actal_memcpy(void *dst, const void *src, int length) 
+{
+	return memcpy(dst, src, length);
+}
+//
+void *actal_memset(void *dst, int v, int length) 
+{
+	return memset(dst, v, length);
+}
+//
+void actal_dump(int *address, int len) 
+{
+	int i = 0;
+	for (i = 0; i < len; i++) 
+	{
+		if ((i % 8) == 0) 
+		{
+			ALOGI("\n%#08X: ", (int) address);
+		}
+		ALOGI("%08X ", *address);
+		address++;
+	}
+
+	ALOGI("\n");
+}
+//
+void actal_sleep_ms(int msec) 
+{
+	struct timespec tv;
+
+	if (msec <= 0) 
+	{
+		return;
+	}
+
+	tv.tv_sec = msec / 1000;
+	tv.tv_nsec = (msec % 1000) * 1000000;
+	nanosleep(&tv, NULL);
+}
+static int __attribute__((constructor)) so_init(void) 
+{
+	s_fd = ion_open();
+	s_pid = getpid();
+	ALOGD("pid = %d", s_pid);
+	return 0;
+}
+static int __attribute__((destructor)) so_exit(void) 
+{
+	ion_close(s_fd);
+	return 0;
+}
diff --git a/media/libstagefright/vendor/al_libc/al_uconv.c b/media/libstagefright/vendor/al_libc/al_uconv.c
new file mode 100755
index 0000000..bbcfd56
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/al_uconv.c
@@ -0,0 +1,75 @@
+#define LOG_TAG             "AL_UCONV"
+#include <utils/Log.h>
+#include "uconv_dev.h"
+#include "unicode/ucnv.h"
+#include "unicode/ustring.h"
+
+/*
+ * return 0 if no illegal bytes, else -1
+ * */
+int actal_check_utf8(const char *utf8, int length) {
+	int i = 0;
+	unsigned char ch;
+	const char *pt = utf8;
+
+	while (i < length) {
+		// Switch on the high four bits.
+		ch = pt[i++];
+		if ((ch & 0x80) == 0) {
+			// Bit pattern 0xxx0000. No need for any extra bytes.
+			continue;
+		} else if (((ch & 0xc0) == 0x80) || ((ch & 0xf0) == 0xf0)) {
+			// Bit pattern 10xx or 1111, which are illegal start bytes.
+			return -1;
+		} else {
+			// if Bit pattern 1110, there are two additional bytes.
+			// if Bit pattern 110x, there is one additional byte.
+			if ((ch & 0xe0) == 0xe0) {
+				ch = pt[i++];
+				if ((ch & 0xc0) != 0x80) {
+					return -1;
+				}
+			}
+
+			ch = pt[i++];
+			if ((ch & 0xc0) != 0x80) {
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int actal_convert_ucnv(char *from_charset, char *to_charset, const char *inbuf, int inlen,
+		char *outbuf, int outlen) {
+    int ret = 0;
+    char *pout = outbuf;
+    UErrorCode status = U_ZERO_ERROR;
+
+    UConverter *conv = ucnv_open(from_charset, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("could not create UConverter for %s\n", from_charset);
+        return -1;
+    }
+    UConverter *destConv = ucnv_open(to_charset, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("could not create UConverter for  for %s\n", to_charset);
+        ucnv_close(conv);
+        return -1;
+    }
+
+    ucnv_convertEx(destConv, conv, &pout, pout + outlen,
+            &inbuf, inbuf + inlen, NULL, NULL, NULL, NULL, TRUE, TRUE, &status);
+    if (U_FAILURE(status)) {
+        ALOGE("ucnv_convertEx failed: %d\n", status);
+		ret = -1;
+    } else {
+		// zero terminate
+        *pout = 0;
+    }
+
+    ucnv_close(conv);
+    ucnv_close(destConv);
+    return ret;
+}
diff --git a/media/libstagefright/vendor/al_libc/ion.c b/media/libstagefright/vendor/al_libc/ion.c
new file mode 100755
index 0000000..22d12ea
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/ion.c
@@ -0,0 +1,153 @@
+/*
+ *  ion.c
+ *
+ * Memory Allocator functions for ion
+ *
+ *   Copyright 2011 Google, Inc
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+
+#define LOG_TAG "ion"
+#include <cutils/log.h>
+
+#include <linux/asoc_ion.h>
+#include "ion.h"
+
+int ion_open()
+{
+        int fd = open("/dev/ion", O_RDWR);
+        if (fd < 0)
+                ALOGE("open /dev/ion failed!\n");
+        return fd;
+}
+
+int ion_close(int fd)
+{
+        return close(fd);
+}
+
+static int ion_ioctl(int fd, int req, void *arg)
+{
+        int ret = ioctl(fd, req, arg);
+        if (ret < 0) {
+                ALOGE("ioctl %d failed with code %d: %s\n", req,
+                       ret, strerror(errno));
+                return -errno;
+        }
+        return ret;
+}
+
+int ion_alloc(int fd, size_t len, size_t align, unsigned int flags,
+              struct ion_handle **handle)
+{
+        int ret;
+        struct ion_allocation_data data = {
+                .len = len,
+                .align = align,
+                .flags = flags,
+        };
+
+        ret = ion_ioctl(fd, ION_IOC_ALLOC, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
+        return ret;
+}
+
+int ion_free(int fd, struct ion_handle *handle)
+{
+        struct ion_handle_data data = {
+                .handle = handle,
+        };
+        return ion_ioctl(fd, ION_IOC_FREE, &data);
+}
+
+int ion_map(int fd, struct ion_handle *handle, size_t length, int prot,
+            int flags, off_t offset, unsigned char **ptr, int *map_fd)
+{
+        struct ion_fd_data data = {
+                .handle = handle,
+        };
+        int ret = ion_ioctl(fd, ION_IOC_MAP, &data);
+        if (ret < 0)
+                return ret;
+        *map_fd = data.fd;
+        if (*map_fd < 0) {
+                ALOGE("map ioctl returned negative fd\n");
+                return -EINVAL;
+        }
+        *ptr = mmap(NULL, length, prot, flags, *map_fd, offset);
+        if (*ptr == MAP_FAILED) {
+                ALOGE("mmap failed: %s\n", strerror(errno));
+                return -errno;
+        }
+        return ret;
+}
+
+int ion_share(int fd, struct ion_handle *handle, int *share_fd)
+{
+        int map_fd;
+        struct ion_fd_data data = {
+                .handle = handle,
+        };
+        int ret = ion_ioctl(fd, ION_IOC_SHARE, &data);
+        if (ret < 0)
+                return ret;
+        *share_fd = data.fd;
+        if (*share_fd < 0) {
+                ALOGE("map ioctl returned negative fd\n");
+                return -EINVAL;
+        }
+        return ret;
+}
+
+int ion_import(int fd, int share_fd, struct ion_handle **handle)
+{
+        struct ion_fd_data data = {
+                .fd = share_fd,
+        };
+        int ret = ion_ioctl(fd, ION_IOC_IMPORT, &data);
+        if (ret < 0)
+                return ret;
+        *handle = data.handle;
+        return ret;
+}
+
+int ion_phys(int fd, struct ion_handle *handle, unsigned long *phys)
+{
+        int ret;
+
+        struct asoc_ion_phys_data phys_data = {
+                .handle = handle,
+        };
+
+        struct ion_custom_data data = {
+                .cmd = ASOC_ION_GET_PHY,
+                .arg = (unsigned long)&phys_data,
+        };
+
+        ret = ion_ioctl(fd, ION_IOC_CUSTOM, &data);
+        if (ret < 0)
+                return ret;
+
+        *phys = phys_data.phys_addr;
+
+        return ret;
+}
diff --git a/media/libstagefright/vendor/al_libc/ion.h b/media/libstagefright/vendor/al_libc/ion.h
new file mode 100755
index 0000000..25bd320
--- /dev/null
+++ b/media/libstagefright/vendor/al_libc/ion.h
@@ -0,0 +1,33 @@
+/*
+ *  ion.c
+ *
+ * Memory Allocator functions for ion
+ *
+ *   Copyright 2011 Google, Inc
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+#include <linux/ion.h>
+
+int ion_open();
+int ion_close(int fd);
+int ion_alloc(int fd, size_t len, size_t align, unsigned int flags,
+              struct ion_handle **handle);
+int ion_alloc_tiler(int fd, size_t w, size_t h, int fmt, unsigned int flags,
+		    struct ion_handle **handle, size_t *stride);
+int ion_free(int fd, struct ion_handle *handle);
+int ion_map(int fd, struct ion_handle *handle, size_t length, int prot,
+            int flags, off_t offset, unsigned char **ptr, int *map_fd);
+int ion_share(int fd, struct ion_handle *handle, int *share_fd);
+int ion_import(int fd, int share_fd, struct ion_handle **handle);
+int ion_phys(int fd, struct ion_handle *handle, unsigned long *phys);
diff --git a/media/libstagefright/vendor/mmminfo/Android.mk b/media/libstagefright/vendor/mmminfo/Android.mk
new file mode 100755
index 0000000..20fd403
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/Android.mk
@@ -0,0 +1,21 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    aac_check.c \
+	dts_check.c \
+ 	format_check.c \
+ 	mp3_check.c \
+ 	rm_check.c \
+ 	ts_check.c \
+ 	wma_check.c
+
+LOCAL_C_INCLUDES := \
+        $(LOCAL_PATH)/include \
+        $(call include-path-for, alsp) \
+        $(TOP)/frameworks/av/include/alsp/inc \
+        $(TOP)/system/core/include/ion
+
+LOCAL_MODULE := libmmminfo
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/vendor/mmminfo/Makefile b/media/libstagefright/vendor/mmminfo/Makefile
new file mode 100755
index 0000000..a3f55ef
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/Makefile
@@ -0,0 +1,50 @@
+ALSPDIR := $(shell ../../config.make)
+
+include $(ALSPDIR)/ALSP.mk
+include $(ALSPDIR)/Config
+
+#定义当前的程序名
+PROG := $(ENGINE12NAME)
+PROGCC := $(patsubst %.so,$(DDIR)/%.a,$(PROG))
+
+#中间输出结果目录
+DDIR := $(CURDIR)/release
+
+CFLAGS += -I$(ALSPINCLUDE)
+CFLAGS += -O2
+
+SUBDIRS :=
+
+SOURCES := $(wildcard *.c)
+ASMSOURCES := $(wildcard *.S)
+OBJS := $(patsubst %.c,$(DDIR)/%.o,$(SOURCES))
+ASMOBJS := $(patsubst %.S,$(DDIR)/%.o,$(ASMSOURCES))
+
+all: makedir clean $(PROG)
+
+#创建DDIR目录
+makedir:
+	@if ! [ -d $(DDIR) ]; \
+	then echo "mkdir "$(DDIR) && mkdir $(DDIR); \
+	fi
+
+#创建目标文件, 并拷贝到lib目录下
+$(PROG): $(SUBDIRS) $(OBJS) $(ASMOBJS) 
+	$(LD) $(ENGINE12LDOPTION) $(DDIR)/*.o $(ENGINE12LINKS) -o $(DDIR)/$@ -Map $(DDIR)/$@.map
+	$(OBJDUMP) -D $(DDIR)/$@ >$(DDIR)/$@.lst
+	mv $(DDIR)/$@ $(ALSPLIBMMMDIR)
+	
+$(OBJS) : $(DDIR)/%.o:%.c
+	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
+
+$(ASMOBJS):$(DDIR)/%.o:%.S	
+	$(CC) -c $(CFLAGS) $(CPPFLAGS) -D_ASSEMBLER_ $< -o $@
+	
+$(SUBDIRS):
+	$(MAKE) -C $@
+
+clean:
+	cd $(DDIR) && $(RM)  *.o *.lst *.a $(PROG) $(PROG).exe $(PROG).bin *.so
+
+.PHONY: all clean mkdir 
+.PHONY: $(SUBDIRS)
diff --git a/media/libstagefright/vendor/mmminfo/aac_check.c b/media/libstagefright/vendor/mmminfo/aac_check.c
new file mode 100755
index 0000000..234f1bd
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/aac_check.c
@@ -0,0 +1,505 @@
+#include "format_check.h"
+    
+int aacflag(storage_io_t *input)
+{
+    int rtval = 0;
+    int ftyp = 0;
+    int moov = 0;
+    int trak = 0;
+    int mdia = 0;
+    int hdlr = 0;
+    int vide = 0;
+    int soun = 0;
+
+    unsigned char tmpbuf[4] = {0};
+    int boxsize = 0;
+
+    int readlen = 0;
+    int boxtype = 0;
+    int sizemoov = 0;
+    int is_audio = 0;
+
+    ftyp = ('p'<< 24) | ('y'<< 16) | ('t'<< 8) | ('f');
+    moov = ('v'<< 24) | ('o'<< 16) | ('o'<< 8) | ('m');
+    trak = ('k'<< 24) | ('a'<< 16) | ('r'<< 8) | ('t');
+    mdia = ('a'<< 24) | ('i'<< 16) | ('d'<< 8) | ('m');
+    hdlr = ('r'<< 24) | ('l'<< 16) | ('d'<< 8) | ('h');
+    vide = ('e'<< 24) | ('d'<< 16) | ('i'<< 8) | ('v');
+    soun = ('n'<< 24) | ('u'<< 16) | ('o'<< 8) | ('s');
+
+    is_audio = FALSE;
+
+    readlen = input->read(tmpbuf, 1, 4, input);
+    if (readlen != 4)
+    {
+        return FALSE;
+    }
+
+    boxsize = (((int)tmpbuf[0] << 24)|((int)tmpbuf[1] << 16))  \
+              | (((int)tmpbuf[2] << 8) | (tmpbuf[3]));
+
+    readlen = input->read(&boxtype, 1, 4, input);
+    if (readlen != 4)
+    {
+        return FALSE;
+    }
+
+    if (boxtype != ftyp)
+    {
+        return FALSE;
+    }
+
+    boxsize -= 8;
+
+    if (boxsize > 0)
+    {
+        rtval = input->seek(input, boxsize, SEEK_CUR);
+        if (rtval != 0)
+        {
+            return FALSE;
+        }
+    }
+    else
+    {
+        return FALSE;
+    }
+
+    while(1)
+    {
+        readlen = input->read(tmpbuf, 1, 4, input);
+        if (readlen != 4)
+        {
+            return FALSE;
+        }
+
+        boxsize = ((int)tmpbuf[0] << 24)|((int)tmpbuf[1] << 16)    \
+                  | ((int)tmpbuf[2] << 8) | ((int)tmpbuf[3]);
+
+        readlen = input->read(&boxtype, 1, 4, input);
+        if (readlen != 4)
+        {
+            return FALSE;
+        }
+
+        if ((boxtype == moov)||(boxtype == trak)||
+                (boxtype == mdia))
+
+        {
+            if (boxtype == moov)
+            {
+                sizemoov = boxsize;
+            }
+
+            boxsize -= 8;
+            sizemoov -= 8;
+
+            continue;
+        }
+        else if (boxtype == hdlr)
+        {
+            readlen = input->read(tmpbuf, 1, 4, input);
+            if (readlen != 4)
+            {
+                return FALSE;
+            }
+            readlen = input->read(&boxtype, 1, 4, input);
+            if (readlen != 4)
+            {
+                return FALSE;
+            }
+
+            readlen = input->read(&boxtype, 1, 4, input);
+            if (readlen != 4)
+            {
+                return FALSE;
+            }
+
+            if (boxtype == vide)
+            {
+                rtval = input->seek(input, 0, SEEK_SET);
+                if (rtval != 0)
+                {
+                    return FALSE;
+                }
+                return FALSE;
+            }
+
+            if (boxtype == soun)
+            {
+                is_audio = TRUE;
+            }
+
+            sizemoov -= boxsize;
+
+            if (sizemoov == 0)
+            {
+                break;
+            }
+
+            boxsize -= 20;
+
+            if (boxsize >= 0)
+            {
+                rtval = input->seek(input, boxsize, SEEK_CUR);
+                if (rtval != 0)
+                {
+                    return FALSE;
+                }
+            }
+            else
+            {
+                return FALSE;
+            }
+        }
+        else
+        {
+            sizemoov -= boxsize;
+
+            if (sizemoov == 0)
+            {
+                break;
+            }
+
+            boxsize -= 8;
+
+            if (boxsize >= 0)
+            {
+                rtval = input->seek(input, boxsize, SEEK_CUR);
+                if (rtval != 0)
+                {
+                    return FALSE;
+                }
+            }
+            else
+            {
+                return FALSE;
+            }
+        }
+    }
+
+    rtval = input->seek(input, 0, SEEK_SET);
+    if (rtval != 0)
+    {
+        return FALSE;
+    }
+    return is_audio;
+}
+
+#define ATOM_MOOV   0x766f6f6d
+#define ATOM_TRAK   0x6b617274
+#define ATOM_MDIA   0x6169646d
+#define ATOM_MINF   0x666e696d
+#define ATOM_STBL   0x6c627473
+#define ATOM_STSD   0x64737473
+#define ATOM_MP4A   0x6134706d
+#define ATOM_ESDS   0x73647365
+#define ATOM_ALAC   0x63616c61
+#define ATOM_AMR    0x726d6173
+#define ATOM_AWB    0x62776173
+/*
+    parse an atom, and compare with the input type
+    if not equal skip current atom till equal
+Note:
+    align_atom只能用于同级的atom之间的对齐
+*/
+static int align_atom(storage_io_t *input, int type)
+{
+    unsigned char tmpbuf[4]; /* current atom size(bytes) */
+    int size;
+    int value;
+    int read_count = 0;
+
+    while (1)
+    {
+        input->read(&tmpbuf, 1, 4, input);
+        size = (((int)tmpbuf[0] << 24)|((int)tmpbuf[1] << 16))  \
+               | (((int)tmpbuf[2] << 8) | (tmpbuf[3]));
+        read_count = input->read(&value, 1, 4, input);
+        if (read_count == 0)
+        {
+            return -1;
+        }
+
+        if (value == type)
+        {
+            break;
+        }
+        if(size >= 8) {
+        input->seek(input, size - 8, SEEK_CUR); /* 8 = bytes already read in current atom */
+        }
+        else {
+            return -1;
+        }
+    }
+    return size;
+}
+static int read_descr_length(storage_io_t *input, int *length)
+{
+    unsigned char b;
+    char numBytes = 0;
+    int value = 0, len = 0;
+    do
+    {
+        len = input->read(&b, 1, 1, input);
+        if(len != 1)
+        {
+            *length = 0;
+            return -1;
+        }
+        numBytes++;
+        value = (value << 7) | (b & 0x7F);
+    }
+    while ((b & 0x80) && numBytes < 4);
+    *length = value;
+    return numBytes;
+}
+int aacplusflag(storage_io_t *input)
+{
+    int rtval = 0, value = 0, tmp = 0, yl = 0, tmp_offset = 0;
+    rtval = input->seek(input, 0, SEEK_SET);
+    if (rtval != 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_MOOV);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_TRAK);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_MDIA);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_MINF);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_STBL);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    rtval = align_atom(input, ATOM_STSD);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+    input->seek(input, 8, SEEK_CUR);
+    tmp_offset = input->tell(input);
+    rtval = align_atom(input, ATOM_MP4A);
+    if (rtval >= 0)
+    {
+        return 2;
+    }
+    else
+    {
+        input->seek(input, tmp_offset, SEEK_SET);
+        rtval = align_atom(input, ATOM_ALAC);
+        if (rtval >= 0)
+        {
+            return 1;
+        }
+        else
+        {
+            input->seek(input, tmp_offset, SEEK_SET);
+            rtval = align_atom(input, ATOM_AMR);
+            if (rtval >= 0)
+            {
+                return 3;
+            }
+            else
+            {
+                input->seek(input, tmp_offset, SEEK_SET);
+                rtval = align_atom(input, ATOM_AWB);
+                if (rtval >= 0)
+                { 
+                return 4;
+                }
+            return -1;
+            }
+        }
+    }
+
+    input->seek(input, 28, SEEK_CUR);
+    rtval = align_atom(input, ATOM_ESDS);
+    if (rtval < 0)
+    {
+        return -1;
+    }
+
+    input->seek(input, 4, SEEK_CUR);
+    yl = input->read(&value, 1, 1, input);
+    if(yl != 1)
+    {
+        return -1;
+    }
+    if (value == 3)
+    {
+        read_descr_length(input, &tmp);
+        if (tmp < 20)
+        {
+            return -1;
+        }
+        input->seek(input, 4, SEEK_CUR);
+    }
+    else
+    {
+        input->seek(input, 3, SEEK_CUR);
+    }
+    read_descr_length(input, &tmp);
+    if (tmp < 13)
+    {
+        return -1;
+    }
+    input->seek(input, 14, SEEK_CUR);
+    yl = read_descr_length(input, &tmp);
+    if(yl < 0)
+    {
+        return -1;
+    }
+    else
+    {
+        unsigned char config, object_type;
+        yl = input->read(&config, 1, 1, input);
+        if(yl != 1)
+        {
+            return -1;
+        }
+        object_type = config >> 3; /* high 5 bit */
+        if (object_type == 5)
+        {
+            return TRUE;
+        }
+        else
+        {
+            yl = input->read(&config, 1, 1, input);
+            if(yl != 1)
+            {
+                return -1;
+            }
+            if (config & 0x2)
+            {
+                return -1;
+            }
+            if ((tmp * 8 - 16) > 16)
+            {
+                short syncExtensionType;
+                yl = input->read(&tmp, 1, 2, input);
+                if(yl != 2)
+                {
+                    return -1;
+                }
+                syncExtensionType = ((tmp & 0xff) << 3) | ((tmp >> 13) & 0x7);
+                if (syncExtensionType == 0x2b7)
+                {
+                    unsigned char tmp_OTi = (tmp >> 8) & 0x1f;
+                    if (tmp_OTi == 5)
+                    {
+                        return TRUE;
+                    }
+                }
+                return FALSE;
+            }
+            else
+            {
+                return FALSE;
+            }
+        }
+    }
+}
+
+int adts_aac_check(storage_io_t *input)
+{
+    int rtval = 0;
+    unsigned char header[10];
+
+    rtval = input->seek(input, 0, SEEK_SET);
+    if (rtval != 0)
+    {
+        return -1;
+    }
+
+    rtval = input->read(header, 1, 10, input);
+    if (rtval != 10)
+    {
+        return -1;
+    }
+    if (!memcmp(header, "ID3", 3))
+    {
+        int tagsize;
+        /* high bit is not used */
+        tagsize = (header[6] << 21) | (header[7] << 14)
+                  | (header[8] <<  7) | (header[9] << 0);
+
+        input->seek(input, tagsize, SEEK_CUR);
+        /* ID3 size */
+        tagsize += 10;
+        /* get another 10bytes for format decision */
+        rtval = input->read(header, 1, 10, input);
+        if (rtval != 10)
+        {
+            return -1;
+        }
+    }
+
+    if ((header[0] == 0xFF) && ((header[1] & 0xF6) == 0xF0))
+    {
+        int config, object_type, sf_index;
+        int frame_length;
+
+        config = header[2];
+        object_type = (config >> 6) + 1;  // 2bit
+        if (object_type > 2)
+        {
+            return FALSE;
+        }
+
+        sf_index = (config >> 2) & 0xf;   // 4bit
+        if (sf_index >= 12)
+        {
+            return FALSE;
+        }
+
+        frame_length = ((((unsigned int)header[3] & 0x3)) << 11)
+                       | ((unsigned int)header[4] << 3)
+                       | ((unsigned int)header[5] >> 5);
+
+        frame_length -= 10;
+        if (frame_length > 0)
+        {
+            input->seek(input, frame_length, SEEK_CUR);
+        }
+        else
+        {
+            return FALSE;
+        }
+
+        /* one more frame verify */
+        rtval = input->read(header, 1, 10, input);
+        if (rtval != 10)
+        {
+            return -1;
+        }
+        if ((header[0] == 0xFF) && ((header[1] & 0xF6) == 0xF0))
+        {
+            return TRUE;
+        }
+        else
+        {
+            return FALSE;
+        }
+    }
+    else
+    {
+        return -1;
+    }
+
+    return TRUE;
+}
diff --git a/media/libstagefright/vendor/mmminfo/dts_check.c b/media/libstagefright/vendor/mmminfo/dts_check.c
new file mode 100755
index 0000000..431fc22
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/dts_check.c
@@ -0,0 +1,99 @@
+
+#include "format_check.h"
+
+#define PAGE_SIZE  512
+#define HEADER_SIZE  6
+
+
+//判断DTS同步标志
+static int32_t dca_syncinfo (uint8_t * buf)
+{
+    /* 14 bits and little endian bitstream */
+    if (buf[0]==(uint8_t)0xff && buf[1]==(uint8_t)0x1f && buf[2]==(uint8_t)0x00
+            && buf[3]==(uint8_t)0xe8 && (buf[4]&((uint8_t)0xf0))==(uint8_t)0xf0
+            && buf[5]==(uint8_t)0x07)
+    {
+        return 1;
+    }
+
+    /* 14 bits and big endian bitstream */
+    if (buf[0]==(uint8_t)0x1f && buf[1]==(uint8_t)0xff && buf[2]==(uint8_t)0xe8
+            && buf[3]==(uint8_t)0x00 && buf[4]==(uint8_t)0x07 && (buf[5]&0xf0)==(uint8_t)0xf0)
+    {
+        return 1;
+    }
+
+    /* 16 bits and little endian bitstream */
+    if (buf[0]==(uint8_t)0xfe && buf[1]==(uint8_t)0x7f && buf[2]==(uint8_t)0x01
+            && buf[3]==(uint8_t)0x80)
+    {
+        return 1;
+    }
+
+    /* 16 bits and big endian bitstream */
+    if (buf[0]==(uint8_t)0x7f && buf[1]==(uint8_t)0xfe && buf[2]==(uint8_t)0x80
+            && buf[3]==(uint8_t)0x01)
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static INLINE uint32_t getbytes(storage_io_t *storage_io, int8_t *buffer, int32_t bytes)
+{
+    int32_t temp;
+
+    temp = storage_io->read(buffer, sizeof(int8_t), bytes, storage_io);
+    if(temp != bytes)
+    {
+        return -1;
+    }
+    return temp;
+}
+
+int32_t dts_check(storage_io_t *storage_io)
+//static int32_t dts_flag(void *handle)
+{
+    int32_t  i= 0, ret = 0;
+    uint8_t  header_buff[PAGE_SIZE+HEADER_SIZE];
+    uint8_t  *buff_ptr=header_buff;
+
+    storage_io->seek(storage_io, 0, SEEK_SET);
+    ret = getbytes(storage_io,header_buff, PAGE_SIZE+HEADER_SIZE);
+    if(ret < 0)
+    {
+        return -1;
+    }
+    for (i=0; i<PAGE_SIZE;i++)
+    {
+        if ( dca_syncinfo (buff_ptr) )
+        {
+            return 1; //"确认DTS文件格式";
+        }
+        buff_ptr++;
+    }
+
+    actal_memcpy(header_buff, header_buff+PAGE_SIZE, HEADER_SIZE);
+    ret = getbytes(storage_io,header_buff+HEADER_SIZE, PAGE_SIZE);
+    if(ret < 0)
+    {
+        return -1;
+    }
+    buff_ptr = header_buff;
+
+    for (i=0; i<PAGE_SIZE; i++)
+    {
+        if ( dca_syncinfo (buff_ptr) )
+        {
+            return 1; //"确认DTS文件格式";
+        }
+        buff_ptr++;
+    }
+
+    return 0; //"确认非DTS格式";
+}
+
+
+
+
+
diff --git a/media/libstagefright/vendor/mmminfo/format_check.c b/media/libstagefright/vendor/mmminfo/format_check.c
new file mode 100755
index 0000000..b403e07
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/format_check.c
@@ -0,0 +1,464 @@
+/*
+********************************************************************************
+*                       NOYA(MAYA)---mmm_dct/mmm_mtp
+*                (c) Copyright 2002-2006, Actions Co,Ld.
+*                        All Right Reserved
+*
+* FileName: Check_format.c     Author:  yangyongdong        2008/07/15
+* Description:
+              1. 定义了检查文件格式的接口
+* Others:         // 其它内容的说明
+* History:        // 修改历史记录列表
+*      <author>    <time>       <version >    <desc>
+*         yyd     2008/07/15     1.0         build this file
+********************************************************************************
+*/
+#include "format_check.h"
+
+//char static inline  tolower(char toLower)
+//{
+//    if ((toLower >= 'A') && (toLower <= 'Z'))
+//    {
+//        return (char)(toLower + 0x20);
+//    }
+//    return toLower;
+//}
+//
+//
+//int static inline  strtolow(char * str)
+//{
+//    int i, tmp = strlen(str);
+//    for(i=0;i<tmp;i++)
+//    {
+//        tolower(str[i]);
+//    }
+//    return 0;
+//}
+
+/*! \page format_check      format_check()
+*
+* \par  format_check()
+*  - 功能描述 \n
+*       格式识别函数，根据文件内容判断文件格式.               \n
+*       目前支持的格式有：mp3, wma, ogg, fla(c), aac, ape, wav, mpc, aif(f), ra, aa  \n
+*       视频：wmv, avi, swf, mp4, rm, flv, dat, mpg, amv, asf  \n
+*       图片：jpg, gif, bmp, tif, png  \n
+*  - 函数原型 \n
+*       int format_check(storage_io_t* input, char* ext) \n
+*  - 输入参数描述 \n
+*       input DD 中间件打开的文件句柄。 \n \n
+*  - 输出参数描述 \n
+*       ext DD 文件格式，为小写的字符串(ASCII) \n
+*       返回0为成功；-1为失败，失败时ext为随机值。
+*  - 示例与说明 \n
+* \code
+*   char ext[4];
+*   int pre_audio, ret;
+*   int (*format_check)(storage_io_t* input, char* ext);
+*   pre_audio = dlopen("pre_aud.so", RTLD_LAZY);
+*   format_check = dlsym(pre_audio,"format_check");
+*   ***********打开文件****************
+*   ret = format_check(input, ext);
+*   if(ret < 0)
+*   {
+*       prinrf("file format err!!\n");
+*       return -1;
+*   }
+* \endcode
+*/
+int format_check(storage_io_t* input, const char* mime)
+{
+    int ret = 0, flag = 0, len = 5;
+    unsigned int* tmp;
+    char *ext = (char *)mime;
+    char buf[16];    
+    
+    tmp = (unsigned int*)buf;
+    if ((ext == NULL) || (input == NULL))
+    {
+        actal_error("format_check Err:buffer is empty!\n");
+        return -1;
+    }
+    //    input->seek(input,0,SEEK_END);
+    //    file_len = input->tell(input);
+//    file_len = get_filesize_storage_io(input);
+    input->seek(input,0,SEEK_SET);
+    len = input->read(buf, 1, 16, input);
+    if(len < 16)
+    {
+        actal_error("format_check read file header Err %x\n",len);
+        return -1;
+    }
+    while((tmp[0] & 0xffffff) == 0x334449)
+    {
+        int tagsize;
+        /* high bit is not used */
+        if(((buf[6]|buf[7]|buf[8]|buf[9]) & 0x80) == 0x80)
+        {
+            actal_error("Bad ID3, skip ID3..\n");
+            break;
+        }
+        
+        tagsize =( (buf[6] << 21) | (buf[7] << 14)
+                   | (buf[8] <<  7) | (buf[9] ));
+        flag += (tagsize+10);
+        
+//        if(file_len < flag)
+//        {
+//            ret = -1;
+//            actal_error("format check Err!(ID3) %d  ext:%s\n",__LINE__,ext);
+//            goto ErrEXit;
+//        }
+//        
+        input->seek(input, flag, SEEK_SET);
+        /* get another 10bytes for format decision */
+        len = input->read(buf, 1, 10, input);
+        if(len != 10)
+        {
+            actal_error("format_check read ID3 Err\n");
+            return -1;
+        }
+    }
+    if(flag > 0)
+    {
+        if ((tmp[0] &0xffffff )== 0x2b504d)
+        {
+            strcpy(ext, PARSER_EXT_MPC);
+        }
+        else if (tmp[0] == 0x43614c66)
+        {
+            strcpy(ext, PARSER_EXT_FLAC);
+        }
+        else if (tmp[0] == 0x2043414d)
+        {
+            strcpy(ext, PARSER_EXT_APE);
+        }
+        else if (adts_aac_check(input) == 1)
+        {
+            strcpy(ext, PARSER_EXT_AAC);
+        }
+        else
+        {
+            
+            input->seek(input, flag, SEEK_SET);
+            flag = mp3check(input);     //0 is mp3
+            if ( flag == 0)
+            {
+                strcpy(ext, PARSER_EXT_MP3);
+                printf("format check other1 ext:%s\n",ext);
+                goto ErrEXit;
+            }
+            else
+            {
+                ret = -1;
+                actal_error("format check1 Err!(ID3)  ext:%s\n",ext);
+                goto ErrEXit;
+            }
+        }
+        printf("format_check ID3  ext:%s\n",ext);
+        goto ErrEXit;
+    }
+    else if (tmp[0] == 0x75B22630)
+    {
+        input->seek(input,0,SEEK_SET);
+        flag = wmaflag(input);
+        if (flag == 0)
+        {
+            strcpy(ext, "wmv");
+        }
+        else if (flag == 1)
+        {
+            strcpy(ext, PARSER_EXT_WMA);
+        }
+        else
+        {
+            actal_error("format_check read ASF header Err\n");
+            return -1;
+        }        
+        goto ErrEXit;
+    }
+    //"oggs"?" 0x4f,0x67,0x67,0x53"
+    else if (tmp[0] == 0x5367674f)
+    {
+        input->seek(input,28,SEEK_SET);
+        len = input->read(tmp, 1, 4,input);
+        if(len != 4)
+        {
+            actal_error("format_check read SPX header Err\n");
+            return -1;
+        }
+        if (tmp[0] == 0x65657053)
+        {
+            strcpy(ext, "SPX");
+        }
+        else if(tmp[0] == 0x726f7601) //0x726f7601
+        {
+            strcpy(ext, PARSER_EXT_OGG);
+						
+        }
+        else 
+        {
+        		strcpy(ext, "ogm");
+        }
+        goto ErrEXit;
+    }
+    else if((tmp[2] & 0xffffff) == 0x564d41)
+    {
+//        strcpy(ext, "amv");
+//        ALOGD("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+        ret = -1;
+        goto ErrEXit;
+    }
+    //"RIFF"?" 0x52,0x49,0x46,0x46"
+    else if (tmp[0] == 0x46464952)
+    {
+        char sExt[4];
+        sExt[0] = (buf[8] >= 'a') ? (buf[8] - 32) : buf[8]; // 32 = 'a' - 'A'
+        sExt[1] = (buf[9] >= 'a') ? (buf[9] - 32) : buf[9];
+        sExt[2] = (buf[10] >= 'a') ? (buf[10] - 32) : buf[10];
+        sExt[3] = 0x20;
+
+        if (memcmp(sExt, "AVI", 3) == 0)
+        {
+            strcpy(ext, "avi");
+        }
+        else if (strncmp(&buf[8], "CDXAfmt", 7) == 0)
+        {
+            strcpy(ext, "mpg");
+        }
+        else
+        {
+            flag = dts_check(input);
+            if (flag == 1)
+            {
+                strcpy(ext, PARSER_EXT_DTS);
+                actal_printf("format_check DTS 1th\n");
+            }
+            else
+            {
+                strcpy(ext, PARSER_EXT_WAV);
+            }
+        }
+        goto ErrEXit;
+    }
+    //"ftyp"?" 0x66,0x74,0x79,0x70"
+    else if (tmp[1] == 0x70797466)
+    {
+        input->seek(input,0,SEEK_SET);
+        if (aacflag(input) == 0)
+        {
+            /* TODO: 01.m4a 音频文件被误判为视频 */
+            strcpy(ext, "mp4");
+            actal_printf("format_check aacflag\n");
+        }
+        else
+        {
+            int is_plus = aacplusflag(input);
+            if (is_plus <= 0)
+            {
+                ret = -1;
+                goto ErrEXit;
+            }
+
+            if (is_plus == 1 )
+            {
+                strcpy(ext, PARSER_EXT_ALAC);
+            }
+            else
+            {
+                strcpy(ext, PARSER_EXT_AAC);
+                
+            }
+        }
+        actal_printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+        goto ErrEXit;
+    }
+    //".RMF"?" 0x2E,0x52,0x4D,0x46"
+    else if (tmp[0] == 0x464d522e)
+    {
+        input->seek(input,0,SEEK_SET);
+        flag = rm_check(input);
+        if (flag == 1)
+        {
+            strcpy(ext, PARSER_EXT_RMA);
+        }
+        else
+        {
+            strcpy(ext, "rm");
+        }
+        goto ErrEXit;
+    }
+    else if ((tmp[0] &0xffffff )== 0x2b504d)
+    {
+        strcpy(ext, PARSER_EXT_MPC);
+        goto ErrEXit;
+    }
+    else if (((tmp[0] & 0xffff) == 0x770b) ||((tmp[0] & 0xffff) == 0x0b77))
+    {
+        strcpy(ext, PARSER_EXT_AC3);
+        goto ErrEXit;
+    }
+    else if (tmp[0] == 0x36759057)
+    {
+        strcpy(ext, PARSER_EXT_AA);
+        goto ErrEXit;
+    }
+//    else if ((tmp[0] & 0xffffff) == 0x61722e)
+//    {
+//        strcpy(ext, "rm");
+//        goto ErrEXit;
+//    }
+    else if ((tmp[0] & 0xfffffff) == 0x1564c46)
+    {
+        strcpy(ext, "flv");
+        goto ErrEXit;
+    }
+    else if ((tmp[0] == 0xba010000) || (tmp[0] == 0xb3010000))
+    {
+        strcpy(ext, "mpg");
+        goto ErrEXit;
+    }    
+//    else if (tmp[0] == 0x4d412123 && buf[4] == 0x52 && buf[5] == 0x0a)
+    else if (tmp[0] == 0x4d412123 )
+    {
+        strcpy(ext, PARSER_EXT_AMR);
+        goto ErrEXit;
+    }
+    else if (tmp[0] == 0xa3df451a)
+    {
+        strcpy(ext, "mkv");
+        goto ErrEXit;
+    }
+    /*
+    //"ftyp" " 0x66,0x74,0x79,0x70"
+    0x70797466
+    //"moov" " 0x6d,0x6f,0x6f,0x76"
+    0x766f6f6d
+    //"mdat" " 0x6d,0x64,0x61,0x74"
+    0x7461646d
+    //"moof" " 0x6d,0x6f,0x6f,0x66"
+    0x666f6f6d
+    //"mfra" " 0x6d,0x66,0x72,0x61"
+    0x6172666d
+    //"pdin" " 0x70,0x64,0x69,0x6e"
+    0x6e696470
+    //"free" " 0x66,0x72,0x65,0x65"
+    0x65657266
+    //"skip" " 0x73,0x6b,0x69,0x70"
+    0x70696b73
+    //"meta" " 0x6d,0x65,0x74,0x61"
+    0x6174656d
+    */
+    if ( (tmp[1] == 0x70797466)
+        ||(tmp[1] == 0x766f6f6d)
+        ||(tmp[1] == 0x7461646d)
+        ||(tmp[1] == 0x666f6f6d)
+        ||(tmp[1] == 0x6172666d)
+        ||(tmp[1] == 0x6e696470)
+        ||(tmp[1] == 0x65657266)
+        ||(tmp[1] == 0x70696b73)
+        ||(tmp[1] == 0x6174656d)
+        ||(tmp[1] == 0x746f6e70)
+        ||(tmp[1] == 0x65646977))
+    {
+        strcpy(ext, "mp4");
+        goto ErrEXit;
+    }
+ 
+    //APE:"MAC "?" 0x4D,0x41,0x43,0x20"
+    if (tmp[0] == 0x2043414d)
+    {
+        strcpy(ext, PARSER_EXT_APE);
+        goto ErrEXit;
+    }
+    //fLaC"?" 0x66,0x4c,0x61,0x43"
+    else if (tmp[0] == 0x43614c66)
+    {
+        strcpy(ext, PARSER_EXT_FLAC);
+        goto ErrEXit;
+    }
+    else if (!(memcmp(buf, "FWS", 3)) || !(memcmp(buf, "CWS", 3)))
+    {
+        //strcpy(ext, "swf");
+        ret = -1;
+        goto ErrEXit;
+    }
+    else if (!(memcmp(buf, "FORM", 4)))
+    {
+        strcpy(ext, PARSER_EXT_AIFF);
+        goto ErrEXit;
+    }
+//    else if((tmp[0] & 0xffff) == 0xd8ff)
+//    {
+//        strcpy(ext, "jpg");
+//
+//        printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+//        goto ErrEXit;
+//    }
+//    else if((tmp[0] & 0xffffff) == 0x464947)
+//    {
+//        strcpy(ext, "gif");
+//
+//        printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+//        goto ErrEXit;
+//    }
+//
+//    else if((tmp[0] & 0xffff) == 0x4d42)
+//    {
+//        strcpy(ext, "bmp");
+//
+//        printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+//        goto ErrEXit;
+//    }
+//    else if((tmp[0] & 0xffff == 0x4d4d) || (tmp[0] & 0xffff == 0x4141))
+//    {
+//        strcpy(ext, "tif");
+//
+//        printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+//        goto ErrEXit;
+//    }
+//    else if(tmp[1] == 0x474e5089)
+//    {
+//        strcpy(ext, "png");
+//
+//        printf("%s %d  ext:%s\n",__FILE__,__LINE__,ext);
+//        goto ErrEXit;
+//    }
+    else
+    {
+        input->seek(input,0,SEEK_SET);
+        flag = mp3check(input);     //0 is mp3
+        if ( flag == 0)
+        {
+            strcpy(ext, PARSER_EXT_MP3);
+            actal_printf("format check other ext:%s\n",ext);
+            goto ErrEXit;
+        }
+        input->seek(input,0,SEEK_SET);
+        if(ts_check(input) == 1)
+        {
+            strcpy(ext, "ts");
+            goto ErrEXit;
+        }
+        input->seek(input,0,SEEK_SET);
+        flag = adts_aac_check(input);     //1 is aac
+        if (flag == 1)
+        {
+            strcpy(ext, PARSER_EXT_AAC);
+            actal_printf("format check other ext:%s\n",ext);
+            goto ErrEXit;
+        }
+        flag = dts_check(input);
+        if (flag == 1)
+        {
+            strcpy(ext, PARSER_EXT_DTS);
+            actal_printf("format check other ext:%s\n",ext);
+            goto ErrEXit;
+        }       
+        ret = -1;
+        actal_error("format undistinguish!!  ext:%s\n",ext);
+    }
+ErrEXit:
+    actal_printf("format_Check  ext:%s\n",ext);
+    return ret;
+}
diff --git a/media/libstagefright/vendor/mmminfo/format_check.h b/media/libstagefright/vendor/mmminfo/format_check.h
new file mode 100755
index 0000000..f658037
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/format_check.h
@@ -0,0 +1,29 @@
+#ifndef __FORMAT_CHECK_H__
+#define __FORMAT_CHECK_H__
+
+#include "actal_posix_dev.h"
+#include "format_dev.h"
+#define LOG_TAG "format_check"
+#include <utils/Log.h>
+#include<dlfcn.h>
+#define actal_printf ALOGD
+#define actal_error ALOGE
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int mpccheck(storage_io_t  *input);
+int mp3check(storage_io_t *input);
+int aacflag(storage_io_t *input);
+int wmaflag(storage_io_t *input);
+int aacplusflag(storage_io_t *input);
+int adts_aac_check(storage_io_t *input);
+int dts_check(storage_io_t  *input);
+int rm_check(storage_io_t *input);
+int ts_check(storage_io_t *input);
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __FORMAT_CHECK_H__
diff --git a/media/libstagefright/vendor/mmminfo/getinfo.c b/media/libstagefright/vendor/mmminfo/getinfo.c
new file mode 100755
index 0000000..892d2d2
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/getinfo.c
@@ -0,0 +1,230 @@
+/*******************************************************************************
+ *                                GL5003
+ *                            Module: getinfo
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved.
+ *
+ * History:
+ *      <author>    <time>           <version >             <desc>
+ *       yyd     2010-02-21 10:00     1.0             build this file
+*******************************************************************************/
+/*!
+ * \file     getinfo.c
+ * \brief    获取媒体文件信息
+ * \author   yyd
+ * \par      GENERAL DESCRIPTION:
+ *               通过格式识别函数，加载对应的parser库，获取媒体文件信息
+ * \par      EXTERNALIZED FUNCTIONS:
+ *               格式parser库, libalc.so,
+ * \version 1.0
+ * \date  2010/2/21
+*******************************************************************************/
+#include "getinfo.h"
+#include "mmm_getinfo.h"
+static void *(* func_handle)(void);
+static void *plib_handle;//插件库句柄
+
+
+int my_strrchr(const char *p, char tmp)
+{
+    int i = 0,len = strlen(p);
+    for (i = len; len > 0; i--)
+    {
+        if (p[i] == tmp)
+        {
+            return i;
+        }
+    }
+    return -1;
+}
+
+int mmm_info_getfileinfo(char *filename, mmm_info_file_info_t *info)
+{
+    int ret = 0;
+    int file_extension;
+    char ext[8];
+    char plib_name[20] = {""};
+    void *parser_handle;//插件库句柄
+    stream_input_t *stream_input = NULL;
+    storage_io_t *storage_io = NULL;
+    int t1 = actal_get_ts();
+    actal_printf("WARNNING: mmm_info_getfileinfo is slow!!!\n");
+    if (stream_input == NULL)
+    {
+        stream_input = stream_input_open(READ_FLAG, 1 << 16);
+        if (stream_input == NULL)
+        {
+            return -1;
+        }
+
+        storage_io = stream_input_get_storageio(stream_input);
+        if (storage_io == NULL)
+        {
+            ret = -1;
+            goto err_exit1;
+        }
+    }
+
+    actal_memset(info, 0, sizeof(mmm_info_file_info_t));
+
+    ret = (int)stream_input_init(stream_input,filename);
+    if (ret <= 0)
+    {
+        actal_error("\n%s %d  %s ret: %x;\n",__func__,__LINE__,filename,ret);
+        ret = -1;
+        goto err_exit1;
+    }
+    file_extension = my_strrchr(filename, '.') + 1;
+    memcpy(ext,&filename[file_extension],8);
+    ret = format_check(storage_io,ext);
+    if (ret < 0)
+    {
+        actal_printf("format_check Err: %s %s \n",filename,ext);
+        goto err_exit2;
+    }
+    /*format_check 返回小写为视频，大写为音频*/
+    if (ext[0] > 0x5a)
+    {
+        demux_plugin_t *demux_info;//插件库信息：插件函数入口
+        media_info_t media_info;
+
+        strcat(plib_name, "avd_");
+        strcat(plib_name,ext);
+        strcat(plib_name, LIBPOSTFIX);
+        plib_handle = dlopen(plib_name, RTLD_LAZY);
+        if (plib_handle == NULL)
+        {
+            actal_error("%s dlopen %s err\n",__FILE__,plib_name);
+            ret = -1;
+            goto err_exit2;
+        }
+        func_handle = dlsym(plib_handle,"get_plugin_info");
+        if (func_handle == NULL)
+        {
+            ret = -1;
+            goto err_exit3;
+        }
+        demux_info = (demux_plugin_t *)func_handle();
+        if (demux_info == NULL)
+        {
+            actal_error("%s dlsym %s err\n",__FILE__,plib_name);
+            ret = -1;
+            goto err_exit3;
+        }
+        parser_handle = (void *)demux_info->open(stream_input,&media_info);
+        if (parser_handle == NULL)
+        {
+            ret = -1;
+            goto err_exit3;
+        }
+        demux_info->dispose(parser_handle);
+        
+        info->total_time = media_info.total_time;
+        actal_memcpy(&info->format,ext,8);
+        info->is_video = 1;
+        info->audio_bitrate = media_info.parser_audio[0].audio_bitrate;
+        actal_memcpy(info->audio_format, &media_info.parser_audio[0],16);
+        actal_memcpy(info->video_format, &media_info.parser_video,24);
+        info->video_bitrate = media_info.parser_video.video_bitrate;
+        info->drm_flag = media_info.parser_drm.drm_flag;
+        actal_printf("******Get Media Info.*******\n");
+        actal_printf("   filename     : %s use: %dms\n",filename, actal_get_ts()-t1);
+        actal_printf("   total time   : %dms \n",info->total_time);
+        actal_printf("   file format  : %s \n",info->format);
+        actal_printf("   is_video     : %d \n",info->is_video);
+        actal_printf("   audio format : %s \n",info->audio_format);
+        actal_printf("   sample_rate  : %dhz\n",info->sample_rate);
+        actal_printf("   channels     : %d \n",info->channels);
+        actal_printf("   audiobitrate : %dkbps\n",info->audio_bitrate);
+        actal_printf("   video_format : %s \n",info->video_format);
+        // actal_printf("   file w: %d h:%d\n",info->width, info->height);
+        // actal_printf("   frame_rate   : %d \n",info->frame_rate);
+        // actal_printf("   video_bitrate: %dbps \n",info->video_bitrate);
+    }
+    else
+    {
+        music_parser_plugin_t *plugin_info;
+        music_info_t music_info;
+        strcat(plib_name, "ap");
+        strcat(plib_name, ext);
+        strcat(plib_name, LIBPOSTFIX);
+        plib_handle = dlopen(plib_name, RTLD_LAZY);
+        if (plib_handle == NULL)
+        {
+            actal_error("%s: %s\n", __FILE__, dlerror());
+            ret = -1;
+            goto err_exit2;
+        }
+
+        func_handle = dlsym(plib_handle, "get_plugin_info");
+        if (func_handle == NULL)
+        {
+            actal_error("%s: %s\n", __FILE__, dlerror());
+            ret = -1;
+            goto err_exit3;
+        }
+
+        plugin_info = (music_parser_plugin_t *)func_handle();
+        if (plugin_info == NULL)
+        {
+            ret = -1;
+            goto err_exit3;
+        }
+        parser_handle = plugin_info->open(storage_io);
+        if (parser_handle == NULL)
+        {
+            ret = -1;
+            goto err_exit3;
+        }
+        plugin_info->parser_header(parser_handle, &music_info);
+        plugin_info->close(parser_handle);
+
+        info->total_time = music_info.total_time*1000;
+        actal_memcpy(&info->format, ext, 8);
+        info->is_video = 0;
+        actal_memcpy(info->audio_format, music_info.extension,8);
+        info->audio_bitrate = music_info.avg_bitrate;
+        info->sample_rate = music_info.sample_rate;
+        info->channels = music_info.channels;
+        //  info->drm_flag = music_info.drm_type;
+        actal_printf("******Get Media Info.*******\n");
+        actal_printf("   filename     : %s use: %dms\n",filename, actal_get_ts()-t1);
+        actal_printf("   total time   : %dms \n",info->total_time);
+        actal_printf("   file format  : %s \n",info->format);
+        actal_printf("   is_video     : %d \n",info->is_video);
+        actal_printf("   audio format : %s \n",info->audio_format);
+        actal_printf("   sample_rate  : %dhz\n",info->sample_rate);
+        actal_printf("   channels     : %d \n",info->channels);
+        actal_printf("   audiobitrate : %dbps\n",info->audio_bitrate);
+        // actal_printf("   video_format : %s \n",info->video_format);
+        // actal_printf("   file w: %d h:%d\n",info->width, info->height);
+        // actal_printf("   frame_rate   : %d \n",info->frame_rate);
+        // actal_printf("   video_bitrate: %dbps \n",info->video_bitrate);
+    }
+
+err_exit3:
+    dlclose(plib_handle);
+    plib_handle = NULL;
+err_exit2:
+    stream_input_fini(stream_input);
+err_exit1:
+    if (stream_input != NULL)
+    {
+        stream_input_dispose(stream_input);
+        stream_input = NULL;
+    }
+    return ret;
+}
+
+DL_EXPORT_SYMBOL(mmm_info_getfileinfo);
+DL_EXPORT_SYMBOL(format_check);
+int __attribute__((constructor)) so_init(void)
+{
+    return 0;
+}
+
+int __attribute__((destructor)) so_exit(void)
+{
+
+    return 0;
+}
diff --git a/media/libstagefright/vendor/mmminfo/getinfo.h b/media/libstagefright/vendor/mmminfo/getinfo.h
new file mode 100755
index 0000000..8634d73
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/getinfo.h
@@ -0,0 +1,10 @@
+/* 用到parser线程所需包含的头文件 */
+#include "actal_posix_dev.h"
+#include "storage_dev.h"
+/* 文件名后缀接口 */
+#include "format_dev.h"
+#include "mmm_mp.h"
+#include "ALdec_plugin.h"
+#include "music_parser_lib_dev.h"
+#include "lib_name_dev.h"
+
diff --git a/media/libstagefright/vendor/mmminfo/mp3_check.c b/media/libstagefright/vendor/mmminfo/mp3_check.c
new file mode 100755
index 0000000..f72713a
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/mp3_check.c
@@ -0,0 +1,302 @@
+/**mp3check.c*/
+//#define chrisdebug
+
+#ifdef chrisdebug
+#include  < stdio.h>
+#include  < stdlib.h>
+#include  < string.h>
+extern FILE *File_BitStream;
+#include "mp3check.h"
+#else
+#include "format_check.h"
+#endif
+
+#define VMIPS
+
+#ifdef VMIPS
+typedef int RCHAR;
+typedef int RSHORT;
+typedef unsigned int RUSHORT;
+typedef unsigned int RUBYTE;
+typedef int DWORD;
+typedef unsigned int UDWORD;
+#else
+typedef char RCHAR;
+typedef short RSHORT;
+typedef unsigned short RUSHORT;
+typedef unsigned char RUBYTE;
+#endif
+
+#define BS_PAGE_SIZE 512
+#define ID3_TAG (0x494433)
+#define MP3_HEADORA (0xFE0C0F)
+#define BS_PAGEMAX_ERRORNUM (600)
+#define SYNC_HEAD_MAXCOUNT 48
+#define SYNC_HEAD_MAXSAMECOUNT 3
+
+#ifdef VMIPS
+static RSHORT m_getpage(storage_io_t *input,RUBYTE *pbs)
+{
+    unsigned char bytebs[BS_PAGE_SIZE];
+    RSHORT i;
+#else
+static RSHORT m_getpage(storage_io_t *input,RUBYTE *bytebs)
+{
+#endif
+    RSHORT len;
+#ifdef chrisdebug
+    len = fread(bytebs,1,BS_PAGE_SIZE,File_BitStream);
+#else
+    len = input->read(bytebs, 1, BS_PAGE_SIZE, input);
+    if(len !=  BS_PAGE_SIZE)
+    {
+        return -1;
+    }
+#endif
+#ifdef VMIPS
+    for (i = 0; i < len; i++)
+    {
+        pbs[i] = ((UDWORD)bytebs[i])&0xff;
+    }
+#endif
+    return len;
+}
+static DWORD m_seekpos(storage_io_t  *input,DWORD len,DWORD original)
+{
+    DWORD r;
+#ifdef chrisdebug
+    if (original == SEEK_SET)
+        original = SEEK_SET;
+    else
+        original = SEEK_CUR;
+    r = fseek(File_BitStream,len,original);
+#else
+    r = input->seek(input, len, original);
+#endif
+    return r;
+}
+static RUSHORT mp3_getframesize(UDWORD curframehead)
+{
+    RUSHORT curframesize,t;
+    RUBYTE mpeg_lsf,mpeg_ver,mpeglayer,padding;
+    RUSHORT bitrate,samplerate,samplerate_table[3] = {44100,48000,32000};
+    /* 1: MPEG-1, 0: MPEG-2 LSF*/
+    RUSHORT table_bitrate[2][3][15]  =
+    {
+        {
+            {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256},
+            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
+            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160}
+        },
+        {
+            {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
+            {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
+            {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
+        }
+    };
+    mpeg_ver = (RUBYTE)(curframehead>>19)&0x3;
+    mpeg_lsf = (mpeg_ver&0x1);
+    if (mpeg_ver == 0)
+    {
+        mpeg_ver = 2;
+    }
+    else
+    {
+        mpeg_ver = 3-mpeg_ver;
+    }
+    mpeglayer = 4-((RUBYTE)(curframehead>>17)&0x3);
+    t = (RUBYTE)(curframehead>>10)&0x3;
+    samplerate = samplerate_table[t];
+    samplerate = samplerate>>mpeg_ver;
+    t = (RUBYTE)(curframehead>>12)&0xF;
+    bitrate = table_bitrate[mpeg_lsf][mpeglayer-1][t];
+    padding = (RUBYTE)(curframehead>>9)&0x1;
+    if (mpeglayer == 3)
+    {
+        curframesize = (144000*(UDWORD)bitrate)/(UDWORD)samplerate;
+        if (mpeg_lsf == 0)
+        {
+            curframesize = curframesize>>1;
+        }
+        curframesize = curframesize+padding;
+    }
+    else if (mpeglayer == 2)
+    {
+        curframesize = (144000*(UDWORD)bitrate)/(UDWORD)samplerate;
+        curframesize = curframesize+padding;
+    }
+    else //lay1
+    {
+        curframesize = (12000*(UDWORD)bitrate)/(UDWORD)samplerate;
+        curframesize = curframesize+padding;
+        curframesize = curframesize << 2;
+    }
+    return curframesize;
+}
+
+int mp3check(storage_io_t *input)
+{
+    RUSHORT mp3_readpagescount = 0;
+    RUBYTE ID3_TAGFlag = 0;
+    UDWORD Sync_HeadValue[SYNC_HEAD_MAXCOUNT] = {0};
+    RUBYTE Sync_HeadCount = 0;
+    RUSHORT FrameSize[SYNC_HEAD_MAXCOUNT] = {0};
+    UDWORD FramePos[SYNC_HEAD_MAXCOUNT] = {0};
+    UDWORD tvalue = 0;
+    RUBYTE *pbs = 0,bs[BS_PAGE_SIZE+4] = {0};
+    DWORD curframepos = 0, breakpos = 0;
+    RSHORT bslen = 0,readbslen = 0;
+    RCHAR i = 0,Sync_HeadFindFlag = 0;
+    UDWORD lastheadvalue = 0, curframehead = 0;
+
+    //init
+    for (i = 0; i < SYNC_HEAD_MAXCOUNT; i++)
+    {
+        Sync_HeadValue[i] = 0xFFFFFF;
+    }
+    //lastheadvalue = 0;
+    breakpos = 0;
+    //start
+    bslen = m_getpage(input,bs);
+    if (bslen <= 10)
+    {
+        return 1;
+    }
+    breakpos += (DWORD)bslen;
+    pbs = bs;
+    //ID3 find
+//    if (ID3_TAGFlag == 0)
+//    {
+    tvalue = ((UDWORD)bs[0] << 16)+((UDWORD)bs[1] << 8)+(UDWORD)bs[2];
+    if (ID3_TAG == tvalue)
+    {
+        breakpos = (((DWORD)bs[6] << 21)+((DWORD)bs[7] << 14)+((DWORD)bs[8] << 7)+(DWORD)bs[9]); //id3len
+        breakpos = breakpos+10;
+        curframepos = m_seekpos(input, breakpos,SEEK_SET);
+        //if(curframepos! = 0)
+        //    return 1;
+        curframepos = (DWORD)bslen - breakpos;
+        if (curframepos < 0)
+        {
+            bslen = -1;
+        }
+        else
+        {
+            bslen = curframepos;
+        }
+        pbs = bs + (UDWORD)breakpos;
+    }
+    ID3_TAGFlag = 1;
+//    }
+    while (1)
+    {
+        //sync head
+        while (bslen>0)
+        {
+            if ((*pbs) != 0xFF)
+            {
+                pbs++;
+                bslen--;
+                continue;
+            }//if 0xff head
+            pbs++;
+            bslen--;
+            if (bslen < 3)
+            {
+                for (i = 0; i < bslen; i++)
+                {
+                    bs[i] = *pbs;
+                    pbs++;
+                }
+                readbslen = m_getpage(input,bs+bslen);
+                if (readbslen <= 0)
+                {
+                    return -1;
+                }
+                breakpos += (DWORD)readbslen;
+                bslen += readbslen;
+                pbs = bs;
+            }
+            curframehead = ((UDWORD)pbs[0] << 16)+((UDWORD)pbs[1] << 8)+(UDWORD)pbs[2]; //24bit head
+
+            {
+                if ((curframehead&0xE00000) != 0xE00000)//sync
+                {
+                    continue;
+                }
+                if ((curframehead&0x180000) == 0x080000)//ver reserved
+                {
+                    continue;
+                }
+                if ((curframehead&0x060000) == 0x000000)//layer reserved
+                {
+                    continue;
+                }
+                if ((curframehead&0x00F000) == 0x00F000)//bitrate reserved
+                {
+                    continue;
+                }
+                //if((curframehead&0x00F000) == 0x000000)//bitrate free
+                //    continue;
+                if ((curframehead&0x000C00) == 0x000C00)//samplerate reserved
+                {
+                    continue;
+                }
+                //if((curframehead&0x000003) == 0x000002)//emphasis reserved
+                //    continue;
+                tvalue = curframehead&MP3_HEADORA;
+                curframepos = breakpos - (DWORD)bslen; //curframepos
+                for (i = (Sync_HeadFindFlag - 1); i >= 0; i--)
+                {
+                    if (tvalue == Sync_HeadValue[i])
+                    {
+                        if (((UDWORD)curframepos - FramePos[i]) != FrameSize[i])
+                        {
+                            continue;
+                        }
+                        curframepos = (DWORD)FramePos[i];
+                        Sync_HeadCount++;
+                        if (Sync_HeadCount == SYNC_HEAD_MAXSAMECOUNT)
+                        {
+                            lastheadvalue = tvalue;
+                            return 0;
+                        }
+                    }
+                }
+                //if(lastheadvalue == 0)
+                {
+                    Sync_HeadCount = 0;
+                    if (Sync_HeadFindFlag < SYNC_HEAD_MAXCOUNT)
+                    {
+                        Sync_HeadValue[Sync_HeadFindFlag] = tvalue;
+                        FramePos[Sync_HeadFindFlag] = (UDWORD)breakpos - (UDWORD)bslen;
+                        FrameSize[Sync_HeadFindFlag] = mp3_getframesize(curframehead);
+                        Sync_HeadFindFlag++;
+                        continue;
+                    }
+                    else
+                    {
+                        //lastheadvalue = Sync_HeadValue[0];
+                        Sync_HeadFindFlag = 0;
+                        continue;
+                    }
+                }
+            }
+        }//while sync head
+        bslen = m_getpage(input,bs);
+        if (bslen <= 0)
+        {
+            return -1;
+        }
+        breakpos += (DWORD)bslen;
+        pbs = bs;
+        mp3_readpagescount++;
+        if (mp3_readpagescount>BS_PAGEMAX_ERRORNUM)
+        {
+            return 1;
+        }
+    }//while(1)
+
+    return 1;
+}
+
diff --git a/media/libstagefright/vendor/mmminfo/rm_check.c b/media/libstagefright/vendor/mmminfo/rm_check.c
new file mode 100755
index 0000000..093ba46
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/rm_check.c
@@ -0,0 +1,240 @@
+#include "format_check.h"
+
+typedef unsigned char BYTE;
+typedef unsigned short UINT16;
+typedef unsigned int UINT32;
+typedef int INT32;
+typedef INT32 HX_RESULT;
+
+void rm_pack32(UINT32 ulValue, BYTE** ppBuf, UINT32* pulLen) {
+	if (ppBuf && pulLen && *pulLen >= 4) {
+		BYTE* pBuf = *ppBuf;
+		pBuf[0] = (BYTE) ((ulValue & 0xFF000000) >> 24);
+		pBuf[1] = (BYTE) ((ulValue & 0x00FF0000) >> 16);
+		pBuf[2] = (BYTE) ((ulValue & 0x0000FF00) >> 8);
+		pBuf[3] = (BYTE) (ulValue & 0x000000FF);
+		*ppBuf += 4;
+		*pulLen -= 4;
+	}
+}
+
+void rm_pack16(UINT16 usValue, BYTE** ppBuf, UINT32* pulLen) {
+	if (ppBuf && pulLen && *pulLen >= 2) {
+		BYTE* pBuf = *ppBuf;
+		pBuf[0] = (BYTE) ((usValue & 0x0000FF00) >> 8);
+		pBuf[1] = (BYTE) (usValue & 0x000000FF);
+		*ppBuf += 2;
+		*pulLen -= 2;
+	}
+}
+
+void rm_pack8(BYTE ucValue, BYTE** ppBuf, UINT32* pulLen) {
+	if (ppBuf && pulLen && *pulLen > 0) {
+		BYTE* pBuf = *ppBuf;
+		pBuf[0] = (BYTE) ucValue;
+		*ppBuf += 1;
+		*pulLen -= 1;
+	}
+}
+
+UINT32 rm_unpack32(BYTE** ppBuf, UINT32* pulLen) {
+	UINT32 ulRet = 0;
+
+	if (ppBuf && pulLen && *pulLen >= 4) {
+		BYTE* pBuf = *ppBuf;
+		ulRet = (pBuf[0] << 24) | (pBuf[1] << 16) | (pBuf[2] << 8) | pBuf[3];
+		*ppBuf += 4;
+		*pulLen -= 4;
+	}
+
+	return ulRet;
+}
+
+UINT16 rm_unpack16(BYTE** ppBuf, UINT32* pulLen) {
+	UINT16 usRet = 0;
+
+	if (ppBuf && pulLen && *pulLen >= 2) {
+		BYTE* pBuf = *ppBuf;
+		usRet = (pBuf[0] << 8) | pBuf[1];
+		*ppBuf += 2;
+		*pulLen -= 2;
+	}
+
+	return usRet;
+}
+
+BYTE rm_unpack8(BYTE** ppBuf, UINT32* pulLen) {
+	BYTE ucRet = 0;
+
+	if (ppBuf && pulLen && *pulLen > 0) {
+		BYTE* pBuf = *ppBuf;
+		ucRet = pBuf[0];
+		*ppBuf += 1;
+		*pulLen -= 1;
+	}
+
+	return ucRet;
+}
+
+/* 区分RM文件中是否含有视频，如果包含视频返回0，单纯音频则返回1*/
+int rm_check(storage_io_t *input) {
+	int rt = 0;
+	char buf[2048];
+	int size;
+	unsigned char *pBuf;
+	unsigned int ulLen;
+	int stream_name_sz;
+	int mime_type_sz;
+	int type_spec_sz;
+	int audio_tag = 0;
+	int video_tag = 0;
+	char mime_type = 0;
+	int num_headers = 0;
+	int i;
+	int bDone = 0;
+	//is .RMF
+	rt = input->read(buf, 1, 4, input);
+	//rt = fread(buf,1,4,fp);
+	if (rt != 4) {
+		goto end;
+	}
+	if (*(unsigned int *) buf != 0x464d522e) {
+		goto end;
+	}
+	rt = input->read(buf, 1, 4, input);
+	//rt = fread(buf,1,4,fp);//size
+	if (rt != 4) {
+		goto end;
+	}
+	pBuf = buf;
+	ulLen = 4;
+	size = rm_unpack32(&pBuf, &ulLen) - 8;
+	rt = input->read(buf, 1, size, input);
+	//rt = fread(buf,1,size,fp);
+	if (rt != size) {
+		goto end;
+	}
+	pBuf = buf + 6;
+	ulLen = size - 6;
+	num_headers = rm_unpack32(&pBuf, &ulLen);
+
+	for (i = 0; (i < num_headers) && (!bDone); i++) {
+		pkt_start: rt = input->read(buf, 1, 4, input);
+		//rt = fread(buf,1,4,fp);
+		if (rt != 4) {
+			break;
+		}
+		if (*(unsigned int *) buf == 0x504f5250)//is PROP
+		{
+			rt = input->read(buf, 1, 4, input);
+			//rt = fread(buf,1,4,fp);//size
+			if (rt != 4) {
+				break;
+			}
+			pBuf = buf;
+			ulLen = 4;
+			size = rm_unpack32(&pBuf, &ulLen) - 8;
+			rt = input->read(buf, 1, size, input);
+			//rt = fread(buf,1,size,fp);
+			if (rt != size) {
+				break;
+			}
+		} else if (*(unsigned int *) buf == 0x5250444d)//is MDPR
+		{
+			rt = input->read(buf, 1, 4, input);
+			//rt = fread(buf,1,4,fp);
+			if (rt != 4) {
+				break;
+			}
+			pBuf = buf;
+			ulLen = 4;
+			size = rm_unpack32(&pBuf, &ulLen) - 8;
+			rt = input->read(buf, 1, size, input);
+			// rt = fread(buf,1,size,fp);
+			if (rt != size) {
+				break;
+			}
+			pBuf = buf;
+			ulLen = size;
+
+			if (ulLen >= 33) {
+				pBuf += 32;
+				ulLen -= 32;
+				stream_name_sz = rm_unpack8(&pBuf, &ulLen);
+				if (ulLen >= (UINT32) stream_name_sz + 1) {
+					pBuf += stream_name_sz;
+					ulLen -= stream_name_sz;
+					mime_type_sz = rm_unpack8(&pBuf, &ulLen);
+					if (ulLen >= (UINT32) mime_type_sz + 4) {
+						mime_type = rm_unpack8(&pBuf, &ulLen);
+						pBuf += (mime_type_sz - 1);
+						ulLen -= (mime_type_sz - 1);
+						type_spec_sz = rm_unpack32(&pBuf, &ulLen);
+						if (ulLen >= (UINT32) type_spec_sz) {
+							if (mime_type == 97) {
+								audio_tag = 1;
+								goto pkt_start;
+							} else if (mime_type == 118) {
+								video_tag = 1;
+								goto pkt_start;
+							}
+						}
+					}
+				}
+			}
+
+		} else if (*(unsigned int *) buf == 0x544e4f43)//CONT
+		{
+			rt = input->read(buf, 1, 4, input);
+			//rt = fread(buf,1,4,fp);//size
+			if (rt != 4) {
+				break;
+			}
+			pBuf = buf;
+			ulLen = 4;
+			size = rm_unpack32(&pBuf, &ulLen) - 8;
+			rt = input->read(buf, 1, size, input);
+			//rt = fread(buf,1,size,fp);
+			if (rt != size) {
+				break;
+			}
+		} else if (*(unsigned int *) buf == 0x41544144)//DATA
+		{
+			bDone = 1;
+		} else {
+			rt = input->read(buf, 1, 4, input);
+			//rt = fread(buf,1,4,fp);//size
+			if (rt != 4) {
+				break;
+			}
+			pBuf = buf;
+			ulLen = 4;
+			size = rm_unpack32(&pBuf, &ulLen) - 8;
+			rt = input->read(buf, 1, size, input);
+			//rt = fread(buf,1,size,fp);
+			if (rt != size) {
+				break;
+			}
+		}
+
+	}
+
+	if (audio_tag == 1) {
+		if (video_tag == 1) {
+			//printf("is rm\n");
+			return 0;
+		} else {
+			//printf("is ra\n");
+			return 1;
+		}
+	} else {
+		if (video_tag == 1) {
+			return 0;
+		} else {
+			return -1;
+		}
+	}
+
+	return 0;
+	end: return -1;
+}
diff --git a/media/libstagefright/vendor/mmminfo/ts_check.c b/media/libstagefright/vendor/mmminfo/ts_check.c
new file mode 100755
index 0000000..c5f1ea5
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/ts_check.c
@@ -0,0 +1,68 @@
+#define TS_FEC_PACKET_SIZE 204
+#define TS_DVHS_PACKET_SIZE 192
+#define TS_PACKET_SIZE 188
+#define TS_MAX_PACKET_SIZE 204
+
+#define NULL 0
+
+#include "format_check.h"
+
+static int analyze(const unsigned char *buf, int size, int packet_size, int *index){
+    int stat[TS_MAX_PACKET_SIZE];
+    int i;
+    int x=0;
+    int best_score=0;
+
+    memset(stat, 0, packet_size*sizeof(int));
+
+    for(x=i=0; i<size-3; i++){
+        if(buf[i] == 0x47 && !(buf[i+1] & 0x80) && (buf[i+3] & 0x30)){
+            stat[x]++;
+            if(stat[x] > best_score){
+                best_score= stat[x];
+                if(index) *index= x;
+            }
+        }
+
+        x++;
+        if(x == packet_size) x= 0;
+    }
+
+    return best_score;
+}
+
+/* autodetect fec presence. Must have at least 1024 bytes  */
+static int get_packet_size(const unsigned char *buf, int size)
+{
+    int score, fec_score, dvhs_score;
+
+    if (size < (TS_FEC_PACKET_SIZE * 5 + 1))
+        return -1;
+
+    score    = analyze(buf, size, TS_PACKET_SIZE, NULL);
+    dvhs_score    = analyze(buf, size, TS_DVHS_PACKET_SIZE, NULL);
+    fec_score= analyze(buf, size, TS_FEC_PACKET_SIZE, NULL);
+   //printf("score: %d, dvhs_score: %d, fec_score: %d \n", score, dvhs_score, fec_score);
+
+    if     (score > fec_score && score > dvhs_score) return TS_PACKET_SIZE;
+    else if(dvhs_score > score && dvhs_score > fec_score) return TS_DVHS_PACKET_SIZE;
+    else if(score < fec_score && dvhs_score < fec_score) return TS_FEC_PACKET_SIZE;
+    else                       return -1;
+}
+
+int ts_check(storage_io_t *input)
+{
+	unsigned char tsbuf[2048];
+	int tssize;
+	int readnum;
+	
+	input->seek(input, 0, SEEK_SET);
+	readnum = input->read((int)tsbuf, 1, 2048, input);
+	if (readnum != 2048)
+		return 0;
+	tssize = get_packet_size(tsbuf, 2048);
+	if (tssize != -1)
+		return 1;
+	return 0;
+}
+
diff --git a/media/libstagefright/vendor/mmminfo/wma_check.c b/media/libstagefright/vendor/mmminfo/wma_check.c
new file mode 100755
index 0000000..6286fdc
--- /dev/null
+++ b/media/libstagefright/vendor/mmminfo/wma_check.c
@@ -0,0 +1,154 @@
+
+#include "format_check.h"
+
+int wmaflag(storage_io_t *input)
+{
+	int rtval = 0, count = 0;
+	int is_audio;
+	unsigned int *guidp1;
+	unsigned int *guidp2;
+#ifdef WIN32
+	__int64 headerobjectsize;
+	__int64 objectsize;
+#else
+	long long headerobjectsize;
+	long long objectsize;
+#endif
+	int readlen;
+	unsigned char guidbuf[16];
+	unsigned char headerobject[16] = {0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c};
+	unsigned char streamobject[16] = {0x91,0x07,0xdc,0xb7,0xb7,0xa9,0xcf,0x11,0x8e,0xe6,0x00,0xc0,0x0c,0x20,0x53,0x65};
+	unsigned char audioobject[16]  = {0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+	int streamcounter;
+
+	is_audio = 0;
+	readlen = input->read(&guidbuf[0], 1, 16,input);
+	if (readlen != 16)
+	{
+		return -1;
+	}
+
+	guidp2 = (unsigned int *)&guidbuf[0];
+	guidp1 = (unsigned int *)&headerobject[0];
+
+	if (*guidp1 != *guidp2)
+	{
+		return -1;
+	}
+	if (*(guidp1 + 1) != *(guidp2 + 1))
+	{
+		return -1;
+	}
+	if (*(guidp1 + 2) != *(guidp2 + 2))
+	{
+		return -1;
+	}
+	if (*(guidp1 + 3) != *(guidp2 + 3))
+	{
+		return -1;
+	}
+
+	readlen = input->read(&headerobjectsize, 1, 8,input);
+	if (readlen != 8)
+	{
+		return -1;
+	}
+
+	if (headerobjectsize < 30)
+	{
+		return -1;
+	}
+
+	rtval = input->seek(input, 6, SEEK_CUR);
+	if (rtval != 0)
+	{
+		return -1;
+	}
+
+	headerobjectsize -= 30;
+
+	streamcounter = 0;
+
+	while(headerobjectsize > 0)
+	{
+	    if(count++ > 100)
+	        break;
+		readlen = input->read(&guidbuf[0], 1, 16,input);
+		if (readlen != 16)
+		{
+			return -1;
+		}
+
+		readlen = input->read(&objectsize, 1, 8,input);
+		if ((readlen != 8) || (objectsize < 0))
+		{
+			return -1;
+		}
+
+		guidp2 = (unsigned int *)&guidbuf[0];
+		guidp1 = (unsigned int *)&streamobject[0];
+
+		if ((*guidp1 == *guidp2)&&(*(guidp1 + 1) == *(guidp2 + 1))               \
+		    &&(*(guidp1 + 2) == *(guidp2 + 2))&&(*(guidp1 + 3) == *(guidp2 + 3)))
+		{
+			streamcounter++;
+			readlen = input->read(&guidbuf[0], 1, 16,input);
+			if (readlen != 16)
+			{
+				return -1;
+			}
+			guidp2 = (unsigned int *)&guidbuf[0];
+			guidp1 = (unsigned int *)&audioobject[0];
+			if ((*guidp1 == *guidp2)&&(*(guidp1 + 1) == *(guidp2 + 1))              \
+			    &&(*(guidp1 + 2) == *(guidp2 + 2))&&(*(guidp1 + 3) == *(guidp2 + 3)))
+			{
+//			    int audio_tag = 0;
+				is_audio = 1;
+//				rtval = input->seek(input, 38, SEEK_CUR);
+//            	if (rtval != 0)
+//            	{
+//            		return 0;
+//            	}
+//            	
+//            	readlen = input->read(&audio_tag, 1, 2,input);
+//            	if (readlen != 2)
+//    			{
+//    				return 0;
+//    			}
+//            	if(audio_tag == 0x163)
+//            	{
+//            	    is_audio = 2;
+//            	}
+//            	else if(audio_tag == 0x162)
+//            	{
+//            	    is_audio = 3;
+//            	}
+//            	rtval = input->seek(input, -40, SEEK_CUR);
+            	//return is_audio;
+			}
+			headerobjectsize -= 16;
+			objectsize -= 16;
+		}
+
+		rtval = input->seek(input, (int)objectsize - 24, SEEK_CUR);
+		if (rtval != 0)
+		{
+		    printf("wma_check seek err!!\n");
+			return -1;
+		}
+		headerobjectsize -= objectsize;
+	}
+    if(streamcounter == 0)
+    {
+        return -1;
+    }
+	else if (streamcounter == 1)
+	{
+		return is_audio;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
diff --git a/media/libstagefright/vendor/plugin_link/Android.mk b/media/libstagefright/vendor/plugin_link/Android.mk
new file mode 100755
index 0000000..3c03bb3
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/Android.mk
@@ -0,0 +1,66 @@
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+ifeq (true, false)
+LOCAL_SRC_FILES:=               \
+    link_decoder.c
+    
+LOCAL_MODULE:= link_decoder
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    link_parser.c
+
+LOCAL_MODULE:= link_parser
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    link_encoder.c
+
+LOCAL_MODULE:= link_encoder
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    link_video_decoder.c
+
+LOCAL_MODULE:= link_video_decoder
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES:=               \
+    link_video_parser.c
+
+LOCAL_MODULE:= link_video_parser
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+define build-static-lib
+	$(shell echo $(TARGET_OUT_INTERMEDIATES)/STATIC_LIBRARIES/$(1)_intermediates/$(1))
+endef
+define build-static-lib-dir
+	$(shell mkdir -p $(TARGET_OUT_INTERMEDIATES)/STATIC_LIBRARIES/$(1)_intermediates/;echo  $(TARGET_OUT_INTERMEDIATES)/STATIC_LIBRARIES/$(1)_intermediates/)
+endef
+define find-obj-subdir
+	$(shell echo $(TARGET_OUT_INTERMEDIATES)/STATIC_LIBRARIES/$(1)_intermediates/*.o)
+endef
+MY_LDFLAGS=-EL -r
+
+MY_SRC= $(call find-obj-subdir,link_decoder) 
+$(shell $(TARGET_LD) $(MY_SRC) $(MY_LDFLAGS) -o $(LOCAL_PATH)/liblink_decoder.a)
+MY_SRC= $(call find-obj-subdir,link_parser) 
+$(shell $(TARGET_LD) $(MY_SRC) $(MY_LDFLAGS) -o $(LOCAL_PATH)/liblink_parser.a)
+MY_SRC= $(call find-obj-subdir,link_encoder) 
+$(shell $(TARGET_LD) $(MY_SRC) $(MY_LDFLAGS) -o $(LOCAL_PATH)/liblink_encoder.a)
+MY_SRC= $(call find-obj-subdir,link_video_decoder) 
+$(shell $(TARGET_LD) $(MY_SRC) $(MY_LDFLAGS) -o $(LOCAL_PATH)/liblink_video_decoder.a)
+MY_SRC= $(call find-obj-subdir,link_video_parser) 
+$(shell $(TARGET_LD) $(MY_SRC) $(MY_LDFLAGS) -o $(LOCAL_PATH)/liblink_video_parser.a)
+endif
+
+LOCAL_PREBUILT_LIBS := liblink_decoder.a liblink_parser.a liblink_video_decoder.a liblink_video_parser.a liblink_encoder.a
+LOCAL_MODULE_TAGS := eng
+include $(BUILD_MULTI_PREBUILT)
diff --git a/media/libstagefright/vendor/plugin_link/liblink_decoder.a b/media/libstagefright/vendor/plugin_link/liblink_decoder.a
new file mode 100755
index 0000000000000000000000000000000000000000..9b16831fa276d97aed89012155c9c4600120cbf8
GIT binary patch
literal 2944
zcmbVO&2Jk;6o2Dgr%mj*`Dkg=(%?c0Nkw+k5*n#3X+8>RpcE-kgaoRy_HLY2>|JZU
zPEt`s)hkH+0~~v(#DN~liNAm|{1cVnfW!rXD8IKm6OT8cAf7z?zJBxG+j%py{`}1w
zZwVntk)TQHYD5qF5>I|MVUzR%jgz>(dyO_*D>*so(W6KAK7pL-rnnDTydj<c#B$;r
zhK-3;i70~SJ|n|4C)siQBYuj!nfHSj(y%yN8Z8*5Q>9_CCT{f&^*vtd`)&#4<t(~d
zG)k8WmkX~HS4W4%h*%gPGLBH8KxEER>RTPXTD*cJ`3czP3&vr@f01)y5UpdJ$EbU8
zrPb)v{h;Cp8zC%2&tY^?Tvt*O`15-n6H-e29y;mz4jei9n4jX0(jeY1S$ZtE*od5_
zw-ZKNZQI$lo1W`CcEhi>W2f$IM1FlUwzs{&4I^8Y*YJZaB7Rm}uNJyqWYyBv<&$EK
zF~rW9;*6a$kjUN)o1WbWYfi&nT>fD7y_@gbTU!m^uD9oAE;zOmxKZf4<aAsg!D>CL
z@V|;f`8~C*+`Ls@F3(yQt=;K*7}gtJ`NGV3{AMneCtHyhc@58LdsF*+u(G^-sXU4K
zQ~zZ;@rpkM;q~v9ii3%+I>J8g{Q6L8Ij1)JFcEKctW|=~0R$5<KPLGZ<^Y{#eu!v_
zIT}CBJWuo*bKvKhBkq#qH>5p@kKSZCm%?}^=De4fZ%TfYc|Xw!sW0+jbUdf(lQ;)4
zKR3NdeFKLU4~zcXfKe19=23A>95+tjc%96hGRDnUWq6<uCL_t(^%;a0)W}Fyt!pp{
z1!-guj+{nD&#L1z(xB#Ly_C_1dhQ*QetjxiBylE<Lc;R)=t|>NWq)_hP;zehy}9Qj
zc)yps-~@L$qh}A(L`)OzzTJ4>0jX4yepEWajvu&{TB}uQMKeT}>s34Tic_sd-ZojW
zw;PjH3!6<3mzq^=x5-*ud)IQ}IP$BV*n^H^AZN8Y)%Z?ppDn;e(Svg$C#d(DlqF5y
zj-xa#=kj)acQ>iT%3gL!Zmw~^C!HBP)o091lO@-t6@;;8;lxhk0;_H5Z-raI)Ai(T
zA*;QKDiI%&;&+;f?mDrfb?VvT5xBYMe8!m4?^Y`FGrh-&t^ve29QTB>IQB7(WAL8)
zH{6fFWb^XAQ>4BRKfu5^RmXw?NUrjJ1s!thzO*lZa~&#<;=jPA=0K$D80#!ZQa<KN
zX4gZE4_T0;eD6S4GQ0l5(9ezX&1G;CaGc}`k`%52UCHd4hf-!ilJZ5+mCUZ&P`YQi
z>l=h!#|2P6m9dy9-#sbg3?}phj_;++jBz~pZfCA=56~DJx*~-;4S{7vKLJ-(3b^XW
zw~+Z}T)<%Z4LI%_|5IQL57xiH&~bkP$M4HH-n$C-B!eqrBd){7IKH73ZUwR)uK}FO
z%XWq1Z<LOUH5}jI3djFZblhFwRDJkYwTBBbxGyyv?|&7qAB(5Q`&!G(Uj~I6%itbp
z@i@Q2{SI00$7A3QqL*NVtEGI5dtE8uD#jHEXu%%+3|twu)3ETJ!g)FWENpP?Q4!z$
VwLPsHkN;QbxZA+J4Vxk*{tYLYQZE1i

literal 0
HcmV?d00001

diff --git a/media/libstagefright/vendor/plugin_link/liblink_encoder.a b/media/libstagefright/vendor/plugin_link/liblink_encoder.a
new file mode 100755
index 0000000000000000000000000000000000000000..0d9d8a135b5f1abcd64add174eab837299ac2e9d
GIT binary patch
literal 2944
zcmbVO&2Jk;6o2Ej-6nS2e6+M_X>cKhq$0a%360d2G#`aDP>K{NLITxUdne8+_O7*F
zC#fi+;tCS~0LLCGaUh3s;xFI~|3oD?AaOw;%J1#&*yBx95Ko?cU%!3xX5PG6fBxpJ
zw}cR+NYE7ZG@?iO$dj9k*c81$6C`f#-Jq@3Y9@JUe}DhMCy--3E8c)CHt{%-01jgr
z@h!u~#aiMmf@eM>Bb#M|IQbDjMJ}6jy%5rfIA0no7^O3%5wR}r<cIT*m-F8*BfX4C
z*NaB!O5tkZmEzjih!_=%gG9zLDinyaa}@j5#;zByVUpY=><b0sDB{0}5of&t=^{p5
zhLu*MQ+K_J>uvh55Iu*{LvdbFO5o3TJyFuoh<F`3>H01l8Ty!?;?L3$))#F(He755
zc2n;9!FJoScdVv#T-$26)plst<!0d4w?b=2dX67hNqP;}+a}^?MS3;gk%3u@OP7n1
zHO3J;lNINzjDd;lj^p|O_N~s^@|)6X_%*v>Ev<a8_TKIHt?liGYt`HHvzKhk_ME_X
z9a_D8r@T_0GcTKaGj-puH)Q$J>_z-$FPEoUfed6r+HE;a|7#UkXWt?Y)L?aG<w|)9
zNlgEj9HI(51!4L3OU0qSif}c!@*Bf=fG()RK0?Gt9eWkwGXTLv%=s8IKgS%P^URMB
zO*2Q~XPD=RUSkg20&~P&PWY|F9>qs((wtLaJQH(1OU$<tew_IL(WyjV;%2m^U3E!Z
zfS8+~S)%;lk)@+zATwwb#c1}pI3Z3Nr_f%fGiQv6?5jz5pbsY_nziRM2n*E6h<2@K
zFbD~0WDr_TBcpHE(Ty~ud08)|^x?jHCriIQO-hvDvNQ$>+uNrrjdzv(y?2JAzU6gu
z%}24mmwVs{cQvJ_n`ttnN$0?gaA+e{Dp5Tu9dFn5oJy_Ls<eVxBGZx8PQ7ARtAX4h
zGn9KFnKi%Jl(^K)YP(J5()zom9fpBh?Sv9KdMSCU)v1Q}S_f<%E{Z;!9oSyI-=r+@
z^zAT+<MLc`&vo{qOw4qnMRRkG2R-qdp<R8(oAG4PwP|{OC{1+i3@)(Rw!SJfyVUjQ
z${@47g)9*tlH&K8k?z=`tySvT;xV|n=G<dU@pmhh`5E8iL^l9p9NImiG>&~t6BvBv
z{tfpNFzI>qn_qn&eoSyGk45M@sd>MK5pwH`#JLF0d8jyw{|cLW2O{0X*kB<c<zud7
zc0I!QkcEVl?;Yq$X4l^sdfzDDd<r)S$7y~cA%&|zS2DX6pp;oiNcjTjN@mwxD7{|p
z`G#QEaUPUUlUU4@??ED?2P1j{#}A3jjBz~pZfCA=4^bEkx*~-;3xQ=tKLb}*3b?Ar
zcaZsJT*P4d9XPHV|5IQL57xiL&~bkO$LnPrpIwD}lEM{n5I10B9N*9iw+dO0*8on<
z%XWq1Z<LM;H5}jI3djFZbliR5RDSqZ)x~)!+*cZo&%cT{fX&n6eWT6GUj~I6PvIVF
z@pyiP`vbCGkH^3rMlZn#S4;UA_qtNRRg7y8P=YS~0$drkv#{`;!t?U{bFjhHr6Ruj
V>s_rEkN;QbxVyl;4Vxk*{sYVGQZfJl

literal 0
HcmV?d00001

diff --git a/media/libstagefright/vendor/plugin_link/liblink_parser.a b/media/libstagefright/vendor/plugin_link/liblink_parser.a
new file mode 100755
index 0000000000000000000000000000000000000000..4c902a21adf49cf62e0d7db9dc3af5a2f2ce2d67
GIT binary patch
literal 2952
zcmbVO&2Jk;6o2Dgr%mj*`Dkg=(%?c0Nkw+k5*k#hG#`aDP>Lu7AwW25d*iHPuUG4J
z>LL&kR}Szea6-M214x{>bLPUI00$(vfsiP_w>vLhJB0#2dG>w%cHYdqnOT4I!p#?z
zQY26`O<jv<e;|%z=VLKVkI^Kl8=dR49js;aOZ)r#d+$O|Y*W1kUA?b^e<w0(nrRbi
zT{H5KnGeY@&F469@-2R<teN%v2->JRUl`9Bg)@awbz5x=j0}9WGVt{ZhL^GETHYvJ
z$vvNYD!)EHs>amP5Rq|=aycS%o|4%5__h31B*{*}znC+QqW{M^CmPWv+C{XQ8<m23
zyXN^N&);goL-Yt*m&N0XhXncPLBxcXfaj4$+TKMVLvQm_{ZSak{Nkm@f~&32X}EWq
z;ZDnTcI}2+^&GqIm0OWhbGJgTwjJ5Ku3v42wjN&H^LL2&Sqhx6<%U)zsa!T5t1*GD
zGp0IcXAI=Ax0?;ut~V=A-CkaOWBt`zuiHC2b<eJ~7UnKFw&PdBrdK^Q|3<szRdj-$
zg;~3`QCuy~TbHfQY^~X>)!pKyxr_MCT`o=sp&Pn&*J-&k^uH#Csi)^fYpbhQiqptB
z^KVjOeR<XI16YF(3i;vKhARfgxcZwTiG4vf{3sD`cPv=U&wvCMu{@#WIhG)uXL*EZ
zh9!zW%Q8#!3`_7AS)$(+EpKXn+&>D`FL@};XRze`#ImO4ah8Kbr?kDy2hwq!vPbFy
z)a=6SG7StJSw5-;GebsRjhV;Q33bvqg(G%4bH<o7pVr-j{a_ez)^5xoOfUr_UbU{n
zAPgu4gK+FpFnU%UCz6I!QML<x_DIj&W74npkM%H28iUQXOOV)N@v3rMmo?V7Zai<U
z`55NMbrUd;>m-QZ>)m)$5l#JvLs2TlB`LN2JDy)HRf3=tgmXkz)h)McC8t~t-CeRG
zw-b?7X*L=z?l!C3YLT^k`xVQHqR=b1BNsN#kA5p?m!rGEA)k-?qKD^%j$i9_i6=?l
zio&E{&gFKzY9}6v)qm&3xp|C-BgvbQQ~rlHlVtJjY5C2_wQy`_agSAY(zC)kyJ<VV
zCdg`SW0dG0n#jA2*seN}Bb9o%<bA_+=X1tLzF&#X&*VNQx(*WaaO7k3^Ek$sMB{z;
zFy8mz^ylThCy?*NcW^LI#<3&>EhX=#u%QPZYyT1?k3;$q`7?a-4ph2<w#kZy#8`^X
zp?hd=vZ5iemtl*}p+C`{WJN<_3$R7!&=ic*n!`e3rIgP8MFfhhXb3NaEjowZgV8<D
z-PkbvX`T-w{g*>xd%8ay!Wcgy@U7NaFprzu6T<rfg|V5SA-uCtSQq>NUQrB4smGVl
z`F31FWBdjl*Ny)%Fozr4pP;3Ayuo<B%;UW)yr24bBj9bq$2`8Jg|`Mh-CqEn<Ym9`
z_&b&6by7UO#fA4yA8!vl86W;#9q{}<-e)Nu?|<oU5Q~@2`*|uae;tH3(Z{=&>W}ja
z?|10wdVB-kgYX2L2n7;j-m_vrN*`CDpi~F=1-v4BXW`*Hh4XU$dH4`IzzDwm8wXam
RKmKo#=DFa#1fM|EzW`;0Q_}zd

literal 0
HcmV?d00001

diff --git a/media/libstagefright/vendor/plugin_link/liblink_video_decoder.a b/media/libstagefright/vendor/plugin_link/liblink_video_decoder.a
new file mode 100755
index 0000000000000000000000000000000000000000..531d9e926fa11bbfb07bdece074763bfab86a0d6
GIT binary patch
literal 2964
zcmbVOOK%%h6h7Bur%CL%c{Gr;w78H$QZ+Ma35`^$G)@X>pcJW4gapDFdv2Uj>=|o3
zNnHVI#0rT8TNeC)E)Zk^I~K5H%^zUPq6>B)B+7U0%#ClHKr4=X=R1#Y&OP@zzW?gY
z*MtzHMbI>LEutU#R3taAV49w#GbC<wuG3~~HIu%yx3{<Z0rbSqiZ*mHod*96GU6+y
zSz;|^6o8pe$jWBF=74xlJ#*QdAH=Xn#JS>F-YT9dj)>dhPTz3fcgua>FQdGSP1g!m
z@k;)c{ELOPu@NyUmIjHe<CM=6W#=i0t&LqPTtz3jDfk!jRzLDT$9<v^t)pE;tIN33
zYHZj2pyCG`Av{D+p><hYmnsSP%zh*bEfF4vDW?4q0vU4oDgG)BVU%j>G2vn(a+~sQ
z7;Uv3cgJZ;&v%`MUv0;3U2a5veKU4;WZ;F7la|-;gDoO{R(5<(h80iNLQh6^Em^>v
zDtTN`CM(W584H~`n_*Krjj-l6obt*$Yj53p+u7P`_)fjOFn7sy+`x-M-=qIk3#vV$
zl+{~zN-L##`?B4ct%qT~AxoF$F5)+LxisC1WF#BXZOfTM6R*aEAst+e)s>YirD-Ic
zd6Jx%XP*5>5KP0z#ln!X;Znje-UaK!iG5yg{1GDF_Lwup&wvCMF^;ErmJy_LjK_#(
z7_kXv8FNH0F@nFyh`h@w-c0=}KUSz0xfJHJF!H`)3{pJ7I6yR!+GReNu5_zDiStl%
z3$tbF8$4F-7Xz6=s~|?RC&ajT+L{oP;$-HObtZcuO%L|bVyRxcF^e!jLo79GU57;|
z$PkNg{0y-U%sNgc4H;3ki#_)6fjcNmzdzzL*p)0z!r-+_B(b%{v&!*wS(U~omB-C%
zK8o>O0BT`gSsOt0-jTa`DyAv#$+l{xqE@A{9o+Q;uTpEZDy?Xa$o6D)yIygt)kyA;
z9m`Hkb}ei+C9XNU+HR9wzWt`{#&P6Vw_^z#XC!^AwOx(xwGR0LTpb5^ZsZ2_gD&k!
zx^Kr(l9&6E9pCGyO6=b2PxZ|;9*!h$#%}dL-b^}E7pWbDv9xh=XK|&~w#-pss-<bG
z>xb<2CaOe!Xd3S|mF>B)YpmDf)Z-xV+VfdsNxo%?&d=m-C%O(2^Kk5y^zt~yat4j}
z-s5<`fYaMA?>{a2oAEOo%+qx&X+ny+-!EW8Z+)8jmw;S{&ZF@meEJ=zbOUXjl~i<$
zQR^Iffc7pcsp!}nu(i&iztLV`B^4c8fUR{7O~E*sau{^1V(9E&M4-e<Dw-F;);fni
zgwZ|I-PjQPCNF?-Kh4FUW4o!2Q>f%20zaiX1M|4?9nYwF-(X=J*jhC2G!)jg{0d%4
z8$i7t-$LgbatTcdHV&^F-$~5j#`foECa)hn9xwBF?`qy}J-i9<*5P9w-_)A73f;`t
zG5Te{=JB`6<n0<fzR5N3{T|+D;OYACPivpY-zqcTmj;jbzs@&+$uoHmjDGnGp?Q-%
zygefy_pf<>LO0jrNAQl4=ix-CrDM!{SsOr|<0=#^>Aw5{UJ1U_@bI0&{c`{F@FBD>
Z6Zrn~zeFuMAOF8Fc`fi>*FliA`VY-nSl|Ev

literal 0
HcmV?d00001

diff --git a/media/libstagefright/vendor/plugin_link/liblink_video_parser.a b/media/libstagefright/vendor/plugin_link/liblink_video_parser.a
new file mode 100755
index 0000000000000000000000000000000000000000..18c103b52f0480b031e19a2d674324ec7ed50b95
GIT binary patch
literal 2952
zcmbVOTW=dh6h5<Sr%mj*PSQZz(BMJ}Ng=yw35^s=noA)Klp>WDA%Sq#-ifn{y<V-?
zsf)Noyz&4)fyeSh9*V>ZKY(Xm_zOrN!5avP@}1qCcwz^NIP&awF5k|XnKLu%PhPq4
zst|&d2%4s@MYKN<N3!!VOw*GzN#c6v8f^#bM*7nJ{{G&3&=Wf&7NLt)8vG|PM3rf#
z*hm?9pz#rznanf?#5?gbo5^~91balBFO22P!bD+2+!A*NiUSW;2fkUw@C=Kt=FP%l
z?xozb`His=F)Egah|Cj|%MoSfDT!^2UCm!XlI#@xOF8p6`hSXZq7iMPT|}$Ns2tSW
zHP0`5{#FwnqQ}s>EFM=pB;XSVkqop%cpkdw_6G<UaV|srSs2DF<E6)fi>=UU$h*yO
zr)4|4c0;<JW7oY(D{^XbEA(pHk-aN@w;9^$@amqwL&VSWuII{TIdH<346SNXzid3>
zaY05#oU;uRx$Ny`L)!Ib)v4PnYqvMvy!n>Bvs3r%T5DnMl4Co*8#X<cT-j)M4z0ra
z%{!&F(!6!q>de-f&01ZSF3nxUZ|-twItXPb>(Xh-nZD)wU$erz`zJ-~Yio<8X^dp%
zzYK&|{UHSN|FDoBCcO%*bM-fict9?w4L?G}+Z~G)^9_*TBF6C)&oP2@p79vb3?qs^
z%a|p4ff4*AM)bRy;*HcF_m9%_A`gZ6ER4LL7#k^`WE><qmD($OARXycJQ5e6W*25x
zXkh5r%5gDh44HW`nmH-P#pC8Faax=)Cd|pq^J({BA1!8_wHq@D6V$|vSFP(X2?Nr^
zBpf?U%tNb=6G_8bl<h)~T|9L6WazhtyzX7e#PjFcC6d_6;#KAKNy{2*6L|8xx#pvo
z-*Z4E%zIfG!1%qR_TE%PQ*Phh?ms5wa$J#e+rR7iZn+u+<sh6RvRqkd*UC<%63Sh&
zBH4+^sx})9iL1@3v|41X+<L=uqA2t#?MTALiAvuJ+Lh>D(C71UT^!;$q2t#MyObwM
z--^PdU(O{vp4*8>V)b5mac&-Ce<XP`aw`AwW|AzvJT1Q&Nef4I7S~vHN1qjzS?YFt
zQIOTz#wgK0G==vXvF$pMqt)tB>Io3I?tIQzlJ8fd^E0{6iLQafJRJF0dU+gUnMC7#
z_bA>E;PmFz?;iD?_&(*SaV*2uMdke*PUyj>X>b|H<52x5`~^Ps4ph31w#iB=D#oaE
z4&6t4o0U{l>~+{m=g?nh&#;n;iY>raI)|oUoJlzhDpuBX_Aen&VkH&D3t=mrL+``r
zp670C7=E4S!}vJui$TTqQXQu-mY)&$F4Y;B$Bpk9M#cLIg|T5PQM|KISXc5RcqL^3
zRXx6j&bQ+-8q4qCaozYI19P~s{TZ6h;|<31WghQc#rvs;R|IbpKIZW)t$6Fu_5K3z
zR9^Ng9)G8FUPt5cEv|U)_VD(=Q{&5NJimwcg~sFkulgIr;^}$6)bjGzLGe!a@a}8<
zael@71G-+1Z^1iCo`w^lK*gB%qB4N0k1J46sss5Iyb^q8;o&=l^K$-q_z*gfBEJ2%
U53Fu~{NF<7x!}D9pAx114NqQGbpQYW

literal 0
HcmV?d00001

diff --git a/media/libstagefright/vendor/plugin_link/link_decoder.c b/media/libstagefright/vendor/plugin_link/link_decoder.c
new file mode 100755
index 0000000..c7283dd
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/link_decoder.c
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: decoder linker
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     link_decoder.c
+ * \brief    提供不同平台下解码库插件链接所需的库
+ * \author   kkli
+ * \par      GENERAL DESCRIPTION:
+ *               这里对文件进行描述
+ * \par      EXTERNALIZED FUNCTIONS:
+ *               这里描述调用到外面的模块
+ * \version 1.0
+ * \date  2009/1/1
+*******************************************************************************/
+
+extern int audiodec_plugin_info;
+
+void *get_plugin_info(void)
+{
+    return (void *)&audiodec_plugin_info;
+}
diff --git a/media/libstagefright/vendor/plugin_link/link_encoder.c b/media/libstagefright/vendor/plugin_link/link_encoder.c
new file mode 100755
index 0000000..76f4f92
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/link_encoder.c
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ *                              5003
+ *                            Module: encoder linker
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     link_encoder.c
+ * \brief    提供不同平台下编码库插件链接所需的库
+ * \author   kkli
+ * \par      GENERAL DESCRIPTION:
+ *               这里对文件进行描述
+ * \par      EXTERNALIZED FUNCTIONS:
+ *               这里描述调用到外面的模块
+ * \version 1.0
+ * \date  2009/1/1
+*******************************************************************************/
+
+extern int audioenc_plugin_info;
+
+void *get_plugin_info(void)
+{
+    return (void *)&audioenc_plugin_info;
+}
diff --git a/media/libstagefright/vendor/plugin_link/link_parser.c b/media/libstagefright/vendor/plugin_link/link_parser.c
new file mode 100755
index 0000000..83b6a34
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/link_parser.c
@@ -0,0 +1,28 @@
+/*******************************************************************************
+ *                              这里填写项目名
+ *                            Module: 这里填写模块名
+ *                 Copyright(c) 2003-2008 Actions Semiconductor,
+ *                            All Rights Reserved. 
+ *
+ * History:         
+ *      <author>    <time>           <version >             <desc>
+ *       kkli     2009-01-01 15:00     1.0             build this file 
+*******************************************************************************/
+/*!
+ * \file     link.c
+ * \brief    提供不同平台下插件链接所需的库
+ * \author   kkli
+ * \par      GENERAL DESCRIPTION:
+ *               这里对文件进行描述
+ * \par      EXTERNALIZED FUNCTIONS:
+ *               这里描述调用到外面的模块
+ * \version 1.0
+ * \date  2009/1/1
+*******************************************************************************/
+
+extern int music_parser_plugin_info;
+
+void *get_plugin_info(void)
+{
+    return (void *)&music_parser_plugin_info;
+}
diff --git a/media/libstagefright/vendor/plugin_link/link_video_decoder.c b/media/libstagefright/vendor/plugin_link/link_video_decoder.c
new file mode 100755
index 0000000..aed2015
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/link_video_decoder.c
@@ -0,0 +1,22 @@
+extern int videodec_plugin_info;
+
+void *get_plugin_info(void)
+{
+    return (void *)&videodec_plugin_info;
+}
+
+#ifdef _OS_UC_1100_  
+#include <actal_posix_dev.h>
+
+int __attribute__((constructor)) so_init(void)
+{
+	return 0;
+}
+
+int __attribute__((destructor)) so_exit(void)
+{
+	return 0;
+}
+
+DL_EXPORT_SYMBOL(get_plugin_info);
+#endif // _OS_UC_1100_
diff --git a/media/libstagefright/vendor/plugin_link/link_video_parser.c b/media/libstagefright/vendor/plugin_link/link_video_parser.c
new file mode 100755
index 0000000..c24c1d0
--- /dev/null
+++ b/media/libstagefright/vendor/plugin_link/link_video_parser.c
@@ -0,0 +1,6 @@
+extern int demux_plugin_info;
+
+void *get_plugin_info(void)
+{
+    return (void *)&demux_plugin_info;
+}
diff --git a/media/libstagefright/wifi-display/ANetworkSession.cpp b/media/libstagefright/wifi-display/ANetworkSession.cpp
index 62a6e7f..0d6aed2 100644
--- a/media/libstagefright/wifi-display/ANetworkSession.cpp
+++ b/media/libstagefright/wifi-display/ANetworkSession.cpp
@@ -424,7 +424,7 @@ status_t ANetworkSession::Session::writeMore() {
                 data[6] = (rtpTime >> 8) & 0xff;
                 data[7] = rtpTime & 0xff;
             }
-
+            int64_t nowus = ALooper::GetNowUs();
             int n;
             do {
                 n = send(mSocket, datagram->data(), datagram->size(), 0);
diff --git a/media/libstagefright/wifi-display/source/Converter.cpp b/media/libstagefright/wifi-display/source/Converter.cpp
index 7a87444..0dfa558 100644
--- a/media/libstagefright/wifi-display/source/Converter.cpp
+++ b/media/libstagefright/wifi-display/source/Converter.cpp
@@ -161,10 +161,12 @@ status_t Converter::initEncoder() {
         mOutputFormat->setInt32("bitrate", videoBitrate);
         mOutputFormat->setInt32("bitrate-mode", OMX_Video_ControlRateConstant);
         mOutputFormat->setInt32("frame-rate", 30);
+//merge from 4.2.2(not support intra-fresh)
         mOutputFormat->setInt32("i-frame-interval", 15);  // Iframes every 15 secs
 
         // Configure encoder to use intra macroblock refresh mode
-        mOutputFormat->setInt32("intra-refresh-mode", OMX_VIDEO_IntraRefreshCyclic);
+        /*Not support intra cyclic refresh mode,.....20130320 by noahkong*/
+       // mOutputFormat->setInt32("intra-refresh-mode", OMX_VIDEO_IntraRefreshCyclic);
 
         int width, height, mbs;
         if (!mOutputFormat->findInt32("width", &width)
@@ -178,7 +180,8 @@ status_t Converter::initEncoder() {
         // it takes about 333 ms in the best case (if next frame is not an IDR)
         // to recover from a lost/corrupted packet.
         mbs = (((width + 15) / 16) * ((height + 15) / 16) * 10) / 100;
-        mOutputFormat->setInt32("intra-refresh-CIR-mbs", mbs);
+        /*Not support intra cyclic refresh mode,.....20130320 by noahkong*/
+        //mOutputFormat->setInt32("intra-refresh-CIR-mbs", mbs);
     }
 
     ALOGV("output format is '%s'", mOutputFormat->debugString(0).c_str());
@@ -395,6 +398,30 @@ void Converter::onMessageReceived(const sp<AMessage> &msg) {
             AString mime;
             CHECK(mInputFormat->findString("mime", &mime));
             ALOGI("encoder (%s) shut down.", mime.c_str());
+            
+          	while (!mInputBufferQueue.empty()) {
+			        sp<ABuffer> buffer = *mInputBufferQueue.begin();
+			        mInputBufferQueue.erase(mInputBufferQueue.begin());
+			        
+			        if (buffer != NULL) {			            
+									#if 1
+									void *mbuf;
+			            if (buffer->meta()->findPointer("mediaBuffer", &mbuf)
+			                    && mbuf != NULL) {
+			                 const int refcnt = static_cast<MediaBuffer *>(mbuf)->refcount();
+				             	{
+				               			 ALOGD("Mediabuf Num %d,%d,%d,%p",refcnt,mEncoderInputBuffers.size(),mIsVideo,mbuf);
+						                 buffer->meta()->setPointer("mediaBuffer", NULL);
+						                 static_cast<MediaBuffer *>(mbuf)->release();
+						                 mbuf = NULL;
+				               }
+			            }
+            		#endif
+            
+        			}
+    				}
+    
+    
             break;
         }
 
diff --git a/media/libstagefright/wifi-display/source/PlaybackSession.cpp b/media/libstagefright/wifi-display/source/PlaybackSession.cpp
index 916f797..5d38a22 100644
--- a/media/libstagefright/wifi-display/source/PlaybackSession.cpp
+++ b/media/libstagefright/wifi-display/source/PlaybackSession.cpp
@@ -802,7 +802,7 @@ int32_t WifiDisplaySource::PlaybackSession::height() const {
 #if USE_1080P
     return 1080;
 #else
-    return 720;
+    return 800;
 #endif
 }
 
diff --git a/media/libstagefright/wifi-display/source/Sender.cpp b/media/libstagefright/wifi-display/source/Sender.cpp
index 9048691..efba2c2 100644
--- a/media/libstagefright/wifi-display/source/Sender.cpp
+++ b/media/libstagefright/wifi-display/source/Sender.cpp
@@ -78,7 +78,7 @@ Sender::Sender(
 #endif
 {
 #if LOG_TRANSPORT_STREAM
-    mLogFile = fopen("/system/etc/log.ts", "wb");
+    mLogFile = fopen("/data/log.ts", "wb");
 #endif
 }
 
@@ -785,6 +785,9 @@ void Sender::onDrainQueue(const sp<ABuffer> &udpPackets) {
         12 + 188 * kMaxNumTSPacketsPerRTPPacket;
 
     size_t srcOffset = 0;
+    int64_t tmp_offset = 0;
+
+    int udpsize = udpPackets->size();
     while (srcOffset < udpPackets->size()) {
         uint8_t *rtp = udpPackets->data() + srcOffset;
 
@@ -843,8 +846,17 @@ void Sender::onDrainQueue(const sp<ABuffer> &udpPackets) {
 #if 0
     int64_t timeUs;
     CHECK(udpPackets->meta()->findInt64("timeUs", &timeUs));
-
-    ALOGI("dTimeUs = %lld us", ALooper::GetNowUs() - timeUs);
+    tmp_offset = ALooper::GetNowUs() - timeUs;
+    if(udpsize <= 2048){
+    	if(max_audio_offset < tmp_offset)
+    		max_audio_offset = tmp_offset;
+    	ALOGI("dTimeUs Audio = %lld us,%lld,%lld,%lld", ALooper::GetNowUs(),timeUs,tmp_offset,max_audio_offset);
+    }
+    else{
+    	if(max_video_offset < tmp_offset)
+    		max_video_offset = tmp_offset;
+    	ALOGI("dTimeUs Video = %lld us,%lld,%lld,%lld", ALooper::GetNowUs(),timeUs,tmp_offset,max_video_offset);
+    }
 #endif
 }
 
diff --git a/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp b/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp
index eecc59b..8659696 100644
--- a/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp
+++ b/media/libstagefright/wifi-display/source/WifiDisplaySource.cpp
@@ -535,7 +535,7 @@ status_t WifiDisplaySource::sendM1(int32_t sessionID) {
 
 status_t WifiDisplaySource::sendM3(int32_t sessionID) {
     AString body =
-        "wfd_content_protection\r\n"
+        //"wfd_content_protection\r\n"
         "wfd_video_formats\r\n"
         "wfd_audio_codecs\r\n"
         "wfd_client_rtp_ports\r\n";
@@ -604,7 +604,7 @@ status_t WifiDisplaySource::sendM4(int32_t sessionID) {
 #if USE_1080P
         "38 00 02 02 00000080 00000000 00000000 00 0000 0000 00 none none\r\n"
 #else
-        "28 00 02 02 00000020 00000000 00000000 00 0000 0000 00 none none\r\n"
+        "41 00 01 01 00000000 00000100 00000000 00 0000 0000 00 none none\r\n"
 #endif
         "wfd_audio_codecs: %s\r\n"
         "wfd_presentation_URL: rtsp://%s/wfd1.0/streamid=0 none\r\n"
diff --git a/services/audioflinger/AudioPolicyService.cpp b/services/audioflinger/AudioPolicyService.cpp
index 388ad6c..605c979 100644
--- a/services/audioflinger/AudioPolicyService.cpp
+++ b/services/audioflinger/AudioPolicyService.cpp
@@ -53,6 +53,8 @@ static const char kCmdDeadlockedString[] = "AudioPolicyService command thread ma
 static const int kDumpLockRetries = 50;
 static const int kDumpLockSleepUs = 20000;
 
+static const nsecs_t kAudioCommandTimeout = 3000000000; // 3 seconds
+
 namespace {
     extern struct audio_policy_service_ops aps_ops;
 };
@@ -708,7 +710,7 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                                                                     data->mIO);
                     if (command->mWaitStatus) {
                         command->mCond.signal();
-                        mWaitWorkCV.wait(mLock);
+                        command->mCond.waitRelative(mLock, kAudioCommandTimeout);
                     }
                     delete data;
                     }break;
@@ -719,7 +721,7 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                     command->mStatus = AudioSystem::setParameters(data->mIO, data->mKeyValuePairs);
                     if (command->mWaitStatus) {
                         command->mCond.signal();
-                        mWaitWorkCV.wait(mLock);
+                        command->mCond.waitRelative(mLock, kAudioCommandTimeout);
                     }
                     delete data;
                     }break;
@@ -730,7 +732,7 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                     command->mStatus = AudioSystem::setVoiceVolume(data->mVolume);
                     if (command->mWaitStatus) {
                         command->mCond.signal();
-                        mWaitWorkCV.wait(mLock);
+                        command->mCond.waitRelative(mLock, kAudioCommandTimeout);
                     }
                     delete data;
                     }break;
@@ -850,7 +852,7 @@ status_t AudioPolicyService::AudioCommandThread::volumeCommand(audio_stream_type
     if (command->mWaitStatus) {
         command->mCond.wait(mLock);
         status =  command->mStatus;
-        mWaitWorkCV.signal();
+        command->mCond.signal();
     }
     return status;
 }
@@ -875,7 +877,7 @@ status_t AudioPolicyService::AudioCommandThread::parametersCommand(audio_io_hand
     if (command->mWaitStatus) {
         command->mCond.wait(mLock);
         status =  command->mStatus;
-        mWaitWorkCV.signal();
+        command->mCond.signal();
     }
     return status;
 }
@@ -896,7 +898,7 @@ status_t AudioPolicyService::AudioCommandThread::voiceVolumeCommand(float volume
     if (command->mWaitStatus) {
         command->mCond.wait(mLock);
         status =  command->mStatus;
-        mWaitWorkCV.signal();
+       command->mCond.signal();
     }
     return status;
 }
diff --git a/services/audioflinger/AudioResampler.cpp b/services/audioflinger/AudioResampler.cpp
index 2c3c719..bfbc083 100644
--- a/services/audioflinger/AudioResampler.cpp
+++ b/services/audioflinger/AudioResampler.cpp
@@ -33,7 +33,7 @@
 namespace android {
 
 #ifdef __ARM_HAVE_HALFWORD_MULTIPLY // optimized asm option
-    #define ASM_ARM_RESAMP1 // enable asm optimisation for ResamplerOrder1
+    //#define ASM_ARM_RESAMP1 // enable asm optimisation for ResamplerOrder1
 #endif // __ARM_HAVE_HALFWORD_MULTIPLY
 // ----------------------------------------------------------------------------
 
diff --git a/services/audioflinger/AudioResampler.h b/services/audioflinger/AudioResampler.h
index 2b8694f..26dcacc 100644
--- a/services/audioflinger/AudioResampler.h
+++ b/services/audioflinger/AudioResampler.h
@@ -66,7 +66,7 @@ public:
 
 protected:
     // number of bits for phase fraction - 30 bits allows nearly 2x downsampling
-    static const int kNumPhaseBits = 30;
+    static const int kNumPhaseBits = 28; //cz_20130129
 
     // phase mask for fraction
     static const uint32_t kPhaseMask = (1LU<<kNumPhaseBits)-1;
-- 
1.8.1.5

